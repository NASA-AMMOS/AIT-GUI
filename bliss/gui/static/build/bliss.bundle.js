/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _mithril = __webpack_require__(1);

	var _mithril2 = _interopRequireDefault(_mithril);

	var _bliss = __webpack_require__(6);

	var bliss = _interopRequireWildcard(_bliss);

	var _index = __webpack_require__(237);

	var _index2 = _interopRequireDefault(_index);

	__webpack_require__(261);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	* Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	* Bespoke Link to Instruments and Small Satellites (BLISS)
	*
	* Copyright 2013, by the California Institute of Technology. ALL RIGHTS
	* RESERVED. United States Government Sponsorship acknowledged. Any
	* commercial use must be negotiated with the Office of Technology Transfer
	* at the California Institute of Technology.
	*
	* This software may be subject to U.S. export control laws. By accepting
	* this software, the user agrees to comply with all applicable U.S. export
	* laws and regulations. User has the responsibility to obtain export licenses,
	* or other export authority as may be required before exporting such
	* information to foreign countries or providing access to foreign persons.
	*/

	window.bliss = bliss;
	window.m = _mithril2.default;

	bliss.gui.init();

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, global, module) {;(function() {
	"use strict"
	function Vnode(tag, key, attrs0, children, text, dom) {
		return {tag: tag, key: key, attrs: attrs0, children: children, text: text, dom: dom, domSize: undefined, state: undefined, _state: undefined, events: undefined, instance: undefined, skip: false}
	}
	Vnode.normalize = function(node) {
		if (Array.isArray(node)) return Vnode("[", undefined, undefined, Vnode.normalizeChildren(node), undefined, undefined)
		if (node != null && typeof node !== "object") return Vnode("#", undefined, undefined, node === false ? "" : node, undefined, undefined)
		return node
	}
	Vnode.normalizeChildren = function normalizeChildren(children) {
		for (var i = 0; i < children.length; i++) {
			children[i] = Vnode.normalize(children[i])
		}
		return children
	}
	var selectorParser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[(.+?)(?:\s*=\s*("|'|)((?:\\["'\]]|.)*?)\5)?\])/g
	var selectorCache = {}
	var hasOwn = {}.hasOwnProperty
	function compileSelector(selector) {
		var match, tag = "div", classes = [], attrs = {}
		while (match = selectorParser.exec(selector)) {
			var type = match[1], value = match[2]
			if (type === "" && value !== "") tag = value
			else if (type === "#") attrs.id = value
			else if (type === ".") classes.push(value)
			else if (match[3][0] === "[") {
				var attrValue = match[6]
				if (attrValue) attrValue = attrValue.replace(/\\(["'])/g, "$1").replace(/\\\\/g, "\\")
				if (match[4] === "class") classes.push(attrValue)
				else attrs[match[4]] = attrValue === "" ? attrValue : attrValue || true
			}
		}
		if (classes.length > 0) attrs.className = classes.join(" ")
		return selectorCache[selector] = {tag: tag, attrs: attrs}
	}
	function execSelector(state, attrs, children) {
		var hasAttrs = false, childList, text
		var className = attrs.className || attrs.class
		for (var key in state.attrs) {
			if (hasOwn.call(state.attrs, key)) {
				attrs[key] = state.attrs[key]
			}
		}
		if (className !== undefined) {
			if (attrs.class !== undefined) {
				attrs.class = undefined
				attrs.className = className
			}
			if (state.attrs.className != null) {
				attrs.className = state.attrs.className + " " + className
			}
		}
		for (var key in attrs) {
			if (hasOwn.call(attrs, key) && key !== "key") {
				hasAttrs = true
				break
			}
		}
		if (Array.isArray(children) && children.length === 1 && children[0] != null && children[0].tag === "#") {
			text = children[0].children
		} else {
			childList = children
		}
		return Vnode(state.tag, attrs.key, hasAttrs ? attrs : undefined, childList, text)
	}
	function hyperscript(selector) {
		// Because sloppy mode sucks
		var attrs = arguments[1], start = 2, children
		if (selector == null || typeof selector !== "string" && typeof selector !== "function" && typeof selector.view !== "function") {
			throw Error("The selector must be either a string or a component.");
		}
		if (typeof selector === "string") {
			var cached = selectorCache[selector] || compileSelector(selector)
		}
		if (attrs == null) {
			attrs = {}
		} else if (typeof attrs !== "object" || attrs.tag != null || Array.isArray(attrs)) {
			attrs = {}
			start = 1
		}
		if (arguments.length === start + 1) {
			children = arguments[start]
			if (!Array.isArray(children)) children = [children]
		} else {
			children = []
			while (start < arguments.length) children.push(arguments[start++])
		}
		var normalized = Vnode.normalizeChildren(children)
		if (typeof selector === "string") {
			return execSelector(cached, attrs, normalized)
		} else {
			return Vnode(selector, attrs.key, attrs, normalized)
		}
	}
	hyperscript.trust = function(html) {
		if (html == null) html = ""
		return Vnode("<", undefined, undefined, html, undefined, undefined)
	}
	hyperscript.fragment = function(attrs1, children) {
		return Vnode("[", attrs1.key, attrs1, Vnode.normalizeChildren(children), undefined, undefined)
	}
	var m = hyperscript
	/** @constructor */
	var PromisePolyfill = function(executor) {
		if (!(this instanceof PromisePolyfill)) throw new Error("Promise must be called with `new`")
		if (typeof executor !== "function") throw new TypeError("executor must be a function")
		var self = this, resolvers = [], rejectors = [], resolveCurrent = handler(resolvers, true), rejectCurrent = handler(rejectors, false)
		var instance = self._instance = {resolvers: resolvers, rejectors: rejectors}
		var callAsync = typeof setImmediate === "function" ? setImmediate : setTimeout
		function handler(list, shouldAbsorb) {
			return function execute(value) {
				var then
				try {
					if (shouldAbsorb && value != null && (typeof value === "object" || typeof value === "function") && typeof (then = value.then) === "function") {
						if (value === self) throw new TypeError("Promise can't be resolved w/ itself")
						executeOnce(then.bind(value))
					}
					else {
						callAsync(function() {
							if (!shouldAbsorb && list.length === 0) console.error("Possible unhandled promise rejection:", value)
							for (var i = 0; i < list.length; i++) list[i](value)
							resolvers.length = 0, rejectors.length = 0
							instance.state = shouldAbsorb
							instance.retry = function() {execute(value)}
						})
					}
				}
				catch (e) {
					rejectCurrent(e)
				}
			}
		}
		function executeOnce(then) {
			var runs = 0
			function run(fn) {
				return function(value) {
					if (runs++ > 0) return
					fn(value)
				}
			}
			var onerror = run(rejectCurrent)
			try {then(run(resolveCurrent), onerror)} catch (e) {onerror(e)}
		}
		executeOnce(executor)
	}
	PromisePolyfill.prototype.then = function(onFulfilled, onRejection) {
		var self = this, instance = self._instance
		function handle(callback, list, next, state) {
			list.push(function(value) {
				if (typeof callback !== "function") next(value)
				else try {resolveNext(callback(value))} catch (e) {if (rejectNext) rejectNext(e)}
			})
			if (typeof instance.retry === "function" && state === instance.state) instance.retry()
		}
		var resolveNext, rejectNext
		var promise = new PromisePolyfill(function(resolve, reject) {resolveNext = resolve, rejectNext = reject})
		handle(onFulfilled, instance.resolvers, resolveNext, true), handle(onRejection, instance.rejectors, rejectNext, false)
		return promise
	}
	PromisePolyfill.prototype.catch = function(onRejection) {
		return this.then(null, onRejection)
	}
	PromisePolyfill.resolve = function(value) {
		if (value instanceof PromisePolyfill) return value
		return new PromisePolyfill(function(resolve) {resolve(value)})
	}
	PromisePolyfill.reject = function(value) {
		return new PromisePolyfill(function(resolve, reject) {reject(value)})
	}
	PromisePolyfill.all = function(list) {
		return new PromisePolyfill(function(resolve, reject) {
			var total = list.length, count = 0, values = []
			if (list.length === 0) resolve([])
			else for (var i = 0; i < list.length; i++) {
				(function(i) {
					function consume(value) {
						count++
						values[i] = value
						if (count === total) resolve(values)
					}
					if (list[i] != null && (typeof list[i] === "object" || typeof list[i] === "function") && typeof list[i].then === "function") {
						list[i].then(consume, reject)
					}
					else consume(list[i])
				})(i)
			}
		})
	}
	PromisePolyfill.race = function(list) {
		return new PromisePolyfill(function(resolve, reject) {
			for (var i = 0; i < list.length; i++) {
				list[i].then(resolve, reject)
			}
		})
	}
	if (typeof window !== "undefined") {
		if (typeof window.Promise === "undefined") window.Promise = PromisePolyfill
		var PromisePolyfill = window.Promise
	} else if (typeof global !== "undefined") {
		if (typeof global.Promise === "undefined") global.Promise = PromisePolyfill
		var PromisePolyfill = global.Promise
	} else {
	}
	var buildQueryString = function(object) {
		if (Object.prototype.toString.call(object) !== "[object Object]") return ""
		var args = []
		for (var key0 in object) {
			destructure(key0, object[key0])
		}
		return args.join("&")
		function destructure(key0, value) {
			if (Array.isArray(value)) {
				for (var i = 0; i < value.length; i++) {
					destructure(key0 + "[" + i + "]", value[i])
				}
			}
			else if (Object.prototype.toString.call(value) === "[object Object]") {
				for (var i in value) {
					destructure(key0 + "[" + i + "]", value[i])
				}
			}
			else args.push(encodeURIComponent(key0) + (value != null && value !== "" ? "=" + encodeURIComponent(value) : ""))
		}
	}
	var FILE_PROTOCOL_REGEX = new RegExp("^file://", "i")
	var _8 = function($window, Promise) {
		var callbackCount = 0
		var oncompletion
		function setCompletionCallback(callback) {oncompletion = callback}
		function finalizer() {
			var count = 0
			function complete() {if (--count === 0 && typeof oncompletion === "function") oncompletion()}
			return function finalize(promise0) {
				var then0 = promise0.then
				promise0.then = function() {
					count++
					var next = then0.apply(promise0, arguments)
					next.then(complete, function(e) {
						complete()
						if (count === 0) throw e
					})
					return finalize(next)
				}
				return promise0
			}
		}
		function normalize(args, extra) {
			if (typeof args === "string") {
				var url = args
				args = extra || {}
				if (args.url == null) args.url = url
			}
			return args
		}
		function request(args, extra) {
			var finalize = finalizer()
			args = normalize(args, extra)
			var promise0 = new Promise(function(resolve, reject) {
				if (args.method == null) args.method = "GET"
				args.method = args.method.toUpperCase()
				var useBody = (args.method === "GET" || args.method === "TRACE") ? false : (typeof args.useBody === "boolean" ? args.useBody : true)
				if (typeof args.serialize !== "function") args.serialize = typeof FormData !== "undefined" && args.data instanceof FormData ? function(value) {return value} : JSON.stringify
				if (typeof args.deserialize !== "function") args.deserialize = deserialize
				if (typeof args.extract !== "function") args.extract = extract
				args.url = interpolate(args.url, args.data)
				if (useBody) args.data = args.serialize(args.data)
				else args.url = assemble(args.url, args.data)
				var xhr = new $window.XMLHttpRequest(),
					aborted = false,
					_abort = xhr.abort
				xhr.abort = function abort() {
					aborted = true
					_abort.call(xhr)
				}
				xhr.open(args.method, args.url, typeof args.async === "boolean" ? args.async : true, typeof args.user === "string" ? args.user : undefined, typeof args.password === "string" ? args.password : undefined)
				if (args.serialize === JSON.stringify && useBody && !(args.headers && args.headers.hasOwnProperty("Content-Type"))) {
					xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
				}
				if (args.deserialize === deserialize && !(args.headers && args.headers.hasOwnProperty("Accept"))) {
					xhr.setRequestHeader("Accept", "application/json, text/*")
				}
				if (args.withCredentials) xhr.withCredentials = args.withCredentials
				for (var key in args.headers) if ({}.hasOwnProperty.call(args.headers, key)) {
					xhr.setRequestHeader(key, args.headers[key])
				}
				if (typeof args.config === "function") xhr = args.config(xhr, args) || xhr
				xhr.onreadystatechange = function() {
					// Don't throw errors on xhr.abort().
					if(aborted) return
					if (xhr.readyState === 4) {
						try {
							var response = (args.extract !== extract) ? args.extract(xhr, args) : args.deserialize(args.extract(xhr, args))
							if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || FILE_PROTOCOL_REGEX.test(args.url)) {
								resolve(cast(args.type, response))
							}
							else {
								var error = new Error(xhr.responseText)
								for (var key in response) error[key] = response[key]
								reject(error)
							}
						}
						catch (e) {
							reject(e)
						}
					}
				}
				if (useBody && (args.data != null)) xhr.send(args.data)
				else xhr.send()
			})
			return args.background === true ? promise0 : finalize(promise0)
		}
		function jsonp(args, extra) {
			var finalize = finalizer()
			args = normalize(args, extra)
			var promise0 = new Promise(function(resolve, reject) {
				var callbackName = args.callbackName || "_mithril_" + Math.round(Math.random() * 1e16) + "_" + callbackCount++
				var script = $window.document.createElement("script")
				$window[callbackName] = function(data) {
					script.parentNode.removeChild(script)
					resolve(cast(args.type, data))
					delete $window[callbackName]
				}
				script.onerror = function() {
					script.parentNode.removeChild(script)
					reject(new Error("JSONP request failed"))
					delete $window[callbackName]
				}
				if (args.data == null) args.data = {}
				args.url = interpolate(args.url, args.data)
				args.data[args.callbackKey || "callback"] = callbackName
				script.src = assemble(args.url, args.data)
				$window.document.documentElement.appendChild(script)
			})
			return args.background === true? promise0 : finalize(promise0)
		}
		function interpolate(url, data) {
			if (data == null) return url
			var tokens = url.match(/:[^\/]+/gi) || []
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1)
				if (data[key] != null) {
					url = url.replace(tokens[i], data[key])
				}
			}
			return url
		}
		function assemble(url, data) {
			var querystring = buildQueryString(data)
			if (querystring !== "") {
				var prefix = url.indexOf("?") < 0 ? "?" : "&"
				url += prefix + querystring
			}
			return url
		}
		function deserialize(data) {
			try {return data !== "" ? JSON.parse(data) : null}
			catch (e) {throw new Error(data)}
		}
		function extract(xhr) {return xhr.responseText}
		function cast(type0, data) {
			if (typeof type0 === "function") {
				if (Array.isArray(data)) {
					for (var i = 0; i < data.length; i++) {
						data[i] = new type0(data[i])
					}
				}
				else return new type0(data)
			}
			return data
		}
		return {request: request, jsonp: jsonp, setCompletionCallback: setCompletionCallback}
	}
	var requestService = _8(window, PromisePolyfill)
	var coreRenderer = function($window) {
		var $doc = $window.document
		var $emptyFragment = $doc.createDocumentFragment()
		var nameSpace = {
			svg: "http://www.w3.org/2000/svg",
			math: "http://www.w3.org/1998/Math/MathML"
		}
		var onevent
		function setEventCallback(callback) {return onevent = callback}
		function getNameSpace(vnode) {
			return vnode.attrs && vnode.attrs.xmlns || nameSpace[vnode.tag]
		}
		//create
		function createNodes(parent, vnodes, start, end, hooks, nextSibling, ns) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i]
				if (vnode != null) {
					createNode(parent, vnode, hooks, ns, nextSibling)
				}
			}
		}
		function createNode(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag
			if (typeof tag === "string") {
				vnode.state = {}
				if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
				switch (tag) {
					case "#": return createText(parent, vnode, nextSibling)
					case "<": return createHTML(parent, vnode, nextSibling)
					case "[": return createFragment(parent, vnode, hooks, ns, nextSibling)
					default: return createElement(parent, vnode, hooks, ns, nextSibling)
				}
			}
			else return createComponent(parent, vnode, hooks, ns, nextSibling)
		}
		function createText(parent, vnode, nextSibling) {
			vnode.dom = $doc.createTextNode(vnode.children)
			insertNode(parent, vnode.dom, nextSibling)
			return vnode.dom
		}
		function createHTML(parent, vnode, nextSibling) {
			var match1 = vnode.children.match(/^\s*?<(\w+)/im) || []
			var parent1 = {caption: "table", thead: "table", tbody: "table", tfoot: "table", tr: "tbody", th: "tr", td: "tr", colgroup: "table", col: "colgroup"}[match1[1]] || "div"
			var temp = $doc.createElement(parent1)
			temp.innerHTML = vnode.children
			vnode.dom = temp.firstChild
			vnode.domSize = temp.childNodes.length
			var fragment = $doc.createDocumentFragment()
			var child
			while (child = temp.firstChild) {
				fragment.appendChild(child)
			}
			insertNode(parent, fragment, nextSibling)
			return fragment
		}
		function createFragment(parent, vnode, hooks, ns, nextSibling) {
			var fragment = $doc.createDocumentFragment()
			if (vnode.children != null) {
				var children = vnode.children
				createNodes(fragment, children, 0, children.length, hooks, null, ns)
			}
			vnode.dom = fragment.firstChild
			vnode.domSize = fragment.childNodes.length
			insertNode(parent, fragment, nextSibling)
			return fragment
		}
		function createElement(parent, vnode, hooks, ns, nextSibling) {
			var tag = vnode.tag
			var attrs2 = vnode.attrs
			var is = attrs2 && attrs2.is
			ns = getNameSpace(vnode) || ns
			var element = ns ?
				is ? $doc.createElementNS(ns, tag, {is: is}) : $doc.createElementNS(ns, tag) :
				is ? $doc.createElement(tag, {is: is}) : $doc.createElement(tag)
			vnode.dom = element
			if (attrs2 != null) {
				setAttrs(vnode, attrs2, ns)
			}
			insertNode(parent, element, nextSibling)
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode)
			}
			else {
				if (vnode.text != null) {
					if (vnode.text !== "") element.textContent = vnode.text
					else vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
				}
				if (vnode.children != null) {
					var children = vnode.children
					createNodes(element, children, 0, children.length, hooks, null, ns)
					setLateAttrs(vnode)
				}
			}
			return element
		}
		function initComponent(vnode, hooks) {
			var sentinel
			if (typeof vnode.tag.view === "function") {
				vnode.state = Object.create(vnode.tag)
				sentinel = vnode.state.view
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
				sentinel.$$reentrantLock$$ = true
			} else {
				vnode.state = void 0
				sentinel = vnode.tag
				if (sentinel.$$reentrantLock$$ != null) return $emptyFragment
				sentinel.$$reentrantLock$$ = true
				vnode.state = (vnode.tag.prototype != null && typeof vnode.tag.prototype.view === "function") ? new vnode.tag(vnode) : vnode.tag(vnode)
			}
			vnode._state = vnode.state
			if (vnode.attrs != null) initLifecycle(vnode.attrs, vnode, hooks)
			initLifecycle(vnode._state, vnode, hooks)
			vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
			if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
			sentinel.$$reentrantLock$$ = null
		}
		function createComponent(parent, vnode, hooks, ns, nextSibling) {
			initComponent(vnode, hooks)
			if (vnode.instance != null) {
				var element = createNode(parent, vnode.instance, hooks, ns, nextSibling)
				vnode.dom = vnode.instance.dom
				vnode.domSize = vnode.dom != null ? vnode.instance.domSize : 0
				insertNode(parent, element, nextSibling)
				return element
			}
			else {
				vnode.domSize = 0
				return $emptyFragment
			}
		}
		//update
		function updateNodes(parent, old, vnodes, recycling, hooks, nextSibling, ns) {
			if (old === vnodes || old == null && vnodes == null) return
			else if (old == null) createNodes(parent, vnodes, 0, vnodes.length, hooks, nextSibling, ns)
			else if (vnodes == null) removeNodes(old, 0, old.length, vnodes)
			else {
				if (old.length === vnodes.length) {
					var isUnkeyed = false
					for (var i = 0; i < vnodes.length; i++) {
						if (vnodes[i] != null && old[i] != null) {
							isUnkeyed = vnodes[i].key == null && old[i].key == null
							break
						}
					}
					if (isUnkeyed) {
						for (var i = 0; i < old.length; i++) {
							if (old[i] === vnodes[i]) continue
							else if (old[i] == null && vnodes[i] != null) createNode(parent, vnodes[i], hooks, ns, getNextSibling(old, i + 1, nextSibling))
							else if (vnodes[i] == null) removeNodes(old, i, i + 1, vnodes)
							else updateNode(parent, old[i], vnodes[i], hooks, getNextSibling(old, i + 1, nextSibling), recycling, ns)
						}
						return
					}
				}
				recycling = recycling || isRecyclable(old, vnodes)
				if (recycling) {
					var pool = old.pool
					old = old.concat(old.pool)
				}
				var oldStart = 0, start = 0, oldEnd = old.length - 1, end = vnodes.length - 1, map
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldStart], v = vnodes[start]
					if (o === v && !recycling) oldStart++, start++
					else if (o == null) oldStart++
					else if (v == null) start++
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldStart >= old.length - pool.length) || ((pool == null) && recycling)
						oldStart++, start++
						updateNode(parent, o, v, hooks, getNextSibling(old, oldStart, nextSibling), shouldRecycle, ns)
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
					}
					else {
						var o = old[oldEnd]
						if (o === v && !recycling) oldEnd--, start++
						else if (o == null) oldEnd--
						else if (v == null) start++
						else if (o.key === v.key) {
							var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
							updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
							if (recycling || start < end) insertNode(parent, toFragment(o), getNextSibling(old, oldStart, nextSibling))
							oldEnd--, start++
						}
						else break
					}
				}
				while (oldEnd >= oldStart && end >= start) {
					var o = old[oldEnd], v = vnodes[end]
					if (o === v && !recycling) oldEnd--, end--
					else if (o == null) oldEnd--
					else if (v == null) end--
					else if (o.key === v.key) {
						var shouldRecycle = (pool != null && oldEnd >= old.length - pool.length) || ((pool == null) && recycling)
						updateNode(parent, o, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), shouldRecycle, ns)
						if (recycling && o.tag === v.tag) insertNode(parent, toFragment(o), nextSibling)
						if (o.dom != null) nextSibling = o.dom
						oldEnd--, end--
					}
					else {
						if (!map) map = getKeyMap(old, oldEnd)
						if (v != null) {
							var oldIndex = map[v.key]
							if (oldIndex != null) {
								var movable = old[oldIndex]
								var shouldRecycle = (pool != null && oldIndex >= old.length - pool.length) || ((pool == null) && recycling)
								updateNode(parent, movable, v, hooks, getNextSibling(old, oldEnd + 1, nextSibling), recycling, ns)
								insertNode(parent, toFragment(movable), nextSibling)
								old[oldIndex].skip = true
								if (movable.dom != null) nextSibling = movable.dom
							}
							else {
								var dom = createNode(parent, v, hooks, ns, nextSibling)
								nextSibling = dom
							}
						}
						end--
					}
					if (end < start) break
				}
				createNodes(parent, vnodes, start, end + 1, hooks, nextSibling, ns)
				removeNodes(old, oldStart, oldEnd + 1, vnodes)
			}
		}
		function updateNode(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			var oldTag = old.tag, tag = vnode.tag
			if (oldTag === tag) {
				vnode.state = old.state
				vnode._state = old._state
				vnode.events = old.events
				if (!recycling && shouldNotUpdate(vnode, old)) return
				if (typeof oldTag === "string") {
					if (vnode.attrs != null) {
						if (recycling) {
							vnode.state = {}
							initLifecycle(vnode.attrs, vnode, hooks)
						}
						else updateLifecycle(vnode.attrs, vnode, hooks)
					}
					switch (oldTag) {
						case "#": updateText(old, vnode); break
						case "<": updateHTML(parent, old, vnode, nextSibling); break
						case "[": updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns); break
						default: updateElement(old, vnode, recycling, hooks, ns)
					}
				}
				else updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns)
			}
			else {
				removeNode(old, null)
				createNode(parent, vnode, hooks, ns, nextSibling)
			}
		}
		function updateText(old, vnode) {
			if (old.children.toString() !== vnode.children.toString()) {
				old.dom.nodeValue = vnode.children
			}
			vnode.dom = old.dom
		}
		function updateHTML(parent, old, vnode, nextSibling) {
			if (old.children !== vnode.children) {
				toFragment(old)
				createHTML(parent, vnode, nextSibling)
			}
			else vnode.dom = old.dom, vnode.domSize = old.domSize
		}
		function updateFragment(parent, old, vnode, recycling, hooks, nextSibling, ns) {
			updateNodes(parent, old.children, vnode.children, recycling, hooks, nextSibling, ns)
			var domSize = 0, children = vnode.children
			vnode.dom = null
			if (children != null) {
				for (var i = 0; i < children.length; i++) {
					var child = children[i]
					if (child != null && child.dom != null) {
						if (vnode.dom == null) vnode.dom = child.dom
						domSize += child.domSize || 1
					}
				}
				if (domSize !== 1) vnode.domSize = domSize
			}
		}
		function updateElement(old, vnode, recycling, hooks, ns) {
			var element = vnode.dom = old.dom
			ns = getNameSpace(vnode) || ns
			if (vnode.tag === "textarea") {
				if (vnode.attrs == null) vnode.attrs = {}
				if (vnode.text != null) {
					vnode.attrs.value = vnode.text //FIXME handle0 multiple children
					vnode.text = undefined
				}
			}
			updateAttrs(vnode, old.attrs, vnode.attrs, ns)
			if (vnode.attrs != null && vnode.attrs.contenteditable != null) {
				setContentEditable(vnode)
			}
			else if (old.text != null && vnode.text != null && vnode.text !== "") {
				if (old.text.toString() !== vnode.text.toString()) old.dom.firstChild.nodeValue = vnode.text
			}
			else {
				if (old.text != null) old.children = [Vnode("#", undefined, undefined, old.text, undefined, old.dom.firstChild)]
				if (vnode.text != null) vnode.children = [Vnode("#", undefined, undefined, vnode.text, undefined, undefined)]
				updateNodes(element, old.children, vnode.children, recycling, hooks, null, ns)
			}
		}
		function updateComponent(parent, old, vnode, hooks, nextSibling, recycling, ns) {
			if (recycling) {
				initComponent(vnode, hooks)
			} else {
				vnode.instance = Vnode.normalize(vnode._state.view.call(vnode.state, vnode))
				if (vnode.instance === vnode) throw Error("A view cannot return the vnode it received as argument")
				if (vnode.attrs != null) updateLifecycle(vnode.attrs, vnode, hooks)
				updateLifecycle(vnode._state, vnode, hooks)
			}
			if (vnode.instance != null) {
				if (old.instance == null) createNode(parent, vnode.instance, hooks, ns, nextSibling)
				else updateNode(parent, old.instance, vnode.instance, hooks, nextSibling, recycling, ns)
				vnode.dom = vnode.instance.dom
				vnode.domSize = vnode.instance.domSize
			}
			else if (old.instance != null) {
				removeNode(old.instance, null)
				vnode.dom = undefined
				vnode.domSize = 0
			}
			else {
				vnode.dom = old.dom
				vnode.domSize = old.domSize
			}
		}
		function isRecyclable(old, vnodes) {
			if (old.pool != null && Math.abs(old.pool.length - vnodes.length) <= Math.abs(old.length - vnodes.length)) {
				var oldChildrenLength = old[0] && old[0].children && old[0].children.length || 0
				var poolChildrenLength = old.pool[0] && old.pool[0].children && old.pool[0].children.length || 0
				var vnodesChildrenLength = vnodes[0] && vnodes[0].children && vnodes[0].children.length || 0
				if (Math.abs(poolChildrenLength - vnodesChildrenLength) <= Math.abs(oldChildrenLength - vnodesChildrenLength)) {
					return true
				}
			}
			return false
		}
		function getKeyMap(vnodes, end) {
			var map = {}, i = 0
			for (var i = 0; i < end; i++) {
				var vnode = vnodes[i]
				if (vnode != null) {
					var key2 = vnode.key
					if (key2 != null) map[key2] = i
				}
			}
			return map
		}
		function toFragment(vnode) {
			var count0 = vnode.domSize
			if (count0 != null || vnode.dom == null) {
				var fragment = $doc.createDocumentFragment()
				if (count0 > 0) {
					var dom = vnode.dom
					while (--count0) fragment.appendChild(dom.nextSibling)
					fragment.insertBefore(dom, fragment.firstChild)
				}
				return fragment
			}
			else return vnode.dom
		}
		function getNextSibling(vnodes, i, nextSibling) {
			for (; i < vnodes.length; i++) {
				if (vnodes[i] != null && vnodes[i].dom != null) return vnodes[i].dom
			}
			return nextSibling
		}
		function insertNode(parent, dom, nextSibling) {
			if (nextSibling && nextSibling.parentNode) parent.insertBefore(dom, nextSibling)
			else parent.appendChild(dom)
		}
		function setContentEditable(vnode) {
			var children = vnode.children
			if (children != null && children.length === 1 && children[0].tag === "<") {
				var content = children[0].children
				if (vnode.dom.innerHTML !== content) vnode.dom.innerHTML = content
			}
			else if (vnode.text != null || children != null && children.length !== 0) throw new Error("Child node of a contenteditable must be trusted")
		}
		//remove
		function removeNodes(vnodes, start, end, context) {
			for (var i = start; i < end; i++) {
				var vnode = vnodes[i]
				if (vnode != null) {
					if (vnode.skip) vnode.skip = false
					else removeNode(vnode, context)
				}
			}
		}
		function removeNode(vnode, context) {
			var expected = 1, called = 0
			if (vnode.attrs && typeof vnode.attrs.onbeforeremove === "function") {
				var result = vnode.attrs.onbeforeremove.call(vnode.state, vnode)
				if (result != null && typeof result.then === "function") {
					expected++
					result.then(continuation, continuation)
				}
			}
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeremove === "function") {
				var result = vnode._state.onbeforeremove.call(vnode.state, vnode)
				if (result != null && typeof result.then === "function") {
					expected++
					result.then(continuation, continuation)
				}
			}
			continuation()
			function continuation() {
				if (++called === expected) {
					onremove(vnode)
					if (vnode.dom) {
						var count0 = vnode.domSize || 1
						if (count0 > 1) {
							var dom = vnode.dom
							while (--count0) {
								removeNodeFromDOM(dom.nextSibling)
							}
						}
						removeNodeFromDOM(vnode.dom)
						if (context != null && vnode.domSize == null && !hasIntegrationMethods(vnode.attrs) && typeof vnode.tag === "string") { //TODO test custom elements
							if (!context.pool) context.pool = [vnode]
							else context.pool.push(vnode)
						}
					}
				}
			}
		}
		function removeNodeFromDOM(node) {
			var parent = node.parentNode
			if (parent != null) parent.removeChild(node)
		}
		function onremove(vnode) {
			if (vnode.attrs && typeof vnode.attrs.onremove === "function") vnode.attrs.onremove.call(vnode.state, vnode)
			if (typeof vnode.tag !== "string" && typeof vnode._state.onremove === "function") vnode._state.onremove.call(vnode.state, vnode)
			if (vnode.instance != null) onremove(vnode.instance)
			else {
				var children = vnode.children
				if (Array.isArray(children)) {
					for (var i = 0; i < children.length; i++) {
						var child = children[i]
						if (child != null) onremove(child)
					}
				}
			}
		}
		//attrs2
		function setAttrs(vnode, attrs2, ns) {
			for (var key2 in attrs2) {
				setAttr(vnode, key2, null, attrs2[key2], ns)
			}
		}
		function setAttr(vnode, key2, old, value, ns) {
			var element = vnode.dom
			if (key2 === "key" || key2 === "is" || (old === value && !isFormAttribute(vnode, key2)) && typeof value !== "object" || typeof value === "undefined" || isLifecycleMethod(key2)) return
			var nsLastIndex = key2.indexOf(":")
			if (nsLastIndex > -1 && key2.substr(0, nsLastIndex) === "xlink") {
				element.setAttributeNS("http://www.w3.org/1999/xlink", key2.slice(nsLastIndex + 1), value)
			}
			else if (key2[0] === "o" && key2[1] === "n" && typeof value === "function") updateEvent(vnode, key2, value)
			else if (key2 === "style") updateStyle(element, old, value)
			else if (key2 in element && !isAttribute(key2) && ns === undefined && !isCustomElement(vnode)) {
				if (key2 === "value") {
					var normalized0 = "" + value // eslint-disable-line no-implicit-coercion
					//setting input[value] to same value by typing on focused element moves cursor to end in Chrome
					if ((vnode.tag === "input" || vnode.tag === "textarea") && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
					//setting select[value] to same value while having select open blinks select dropdown in Chrome
					if (vnode.tag === "select") {
						if (value === null) {
							if (vnode.dom.selectedIndex === -1 && vnode.dom === $doc.activeElement) return
						} else {
							if (old !== null && vnode.dom.value === normalized0 && vnode.dom === $doc.activeElement) return
						}
					}
					//setting option[value] to same value while having select open blinks select dropdown in Chrome
					if (vnode.tag === "option" && old != null && vnode.dom.value === normalized0) return
				}
				// If you assign an input type1 that is not supported by IE 11 with an assignment expression, an error0 will occur.
				if (vnode.tag === "input" && key2 === "type") {
					element.setAttribute(key2, value)
					return
				}
				element[key2] = value
			}
			else {
				if (typeof value === "boolean") {
					if (value) element.setAttribute(key2, "")
					else element.removeAttribute(key2)
				}
				else element.setAttribute(key2 === "className" ? "class" : key2, value)
			}
		}
		function setLateAttrs(vnode) {
			var attrs2 = vnode.attrs
			if (vnode.tag === "select" && attrs2 != null) {
				if ("value" in attrs2) setAttr(vnode, "value", null, attrs2.value, undefined)
				if ("selectedIndex" in attrs2) setAttr(vnode, "selectedIndex", null, attrs2.selectedIndex, undefined)
			}
		}
		function updateAttrs(vnode, old, attrs2, ns) {
			if (attrs2 != null) {
				for (var key2 in attrs2) {
					setAttr(vnode, key2, old && old[key2], attrs2[key2], ns)
				}
			}
			if (old != null) {
				for (var key2 in old) {
					if (attrs2 == null || !(key2 in attrs2)) {
						if (key2 === "className") key2 = "class"
						if (key2[0] === "o" && key2[1] === "n" && !isLifecycleMethod(key2)) updateEvent(vnode, key2, undefined)
						else if (key2 !== "key") vnode.dom.removeAttribute(key2)
					}
				}
			}
		}
		function isFormAttribute(vnode, attr) {
			return attr === "value" || attr === "checked" || attr === "selectedIndex" || attr === "selected" && vnode.dom === $doc.activeElement
		}
		function isLifecycleMethod(attr) {
			return attr === "oninit" || attr === "oncreate" || attr === "onupdate" || attr === "onremove" || attr === "onbeforeremove" || attr === "onbeforeupdate"
		}
		function isAttribute(attr) {
			return attr === "href" || attr === "list" || attr === "form" || attr === "width" || attr === "height"// || attr === "type"
		}
		function isCustomElement(vnode){
			return vnode.attrs.is || vnode.tag.indexOf("-") > -1
		}
		function hasIntegrationMethods(source) {
			return source != null && (source.oncreate || source.onupdate || source.onbeforeremove || source.onremove)
		}
		//style
		function updateStyle(element, old, style) {
			if (old === style) element.style.cssText = "", old = null
			if (style == null) element.style.cssText = ""
			else if (typeof style === "string") element.style.cssText = style
			else {
				if (typeof old === "string") element.style.cssText = ""
				for (var key2 in style) {
					element.style[key2] = style[key2]
				}
				if (old != null && typeof old !== "string") {
					for (var key2 in old) {
						if (!(key2 in style)) element.style[key2] = ""
					}
				}
			}
		}
		//event
		function updateEvent(vnode, key2, value) {
			var element = vnode.dom
			var callback = typeof onevent !== "function" ? value : function(e) {
				var result = value.call(element, e)
				onevent.call(element, e)
				return result
			}
			if (key2 in element) element[key2] = typeof value === "function" ? callback : null
			else {
				var eventName = key2.slice(2)
				if (vnode.events === undefined) vnode.events = {}
				if (vnode.events[key2] === callback) return
				if (vnode.events[key2] != null) element.removeEventListener(eventName, vnode.events[key2], false)
				if (typeof value === "function") {
					vnode.events[key2] = callback
					element.addEventListener(eventName, vnode.events[key2], false)
				}
			}
		}
		//lifecycle
		function initLifecycle(source, vnode, hooks) {
			if (typeof source.oninit === "function") source.oninit.call(vnode.state, vnode)
			if (typeof source.oncreate === "function") hooks.push(source.oncreate.bind(vnode.state, vnode))
		}
		function updateLifecycle(source, vnode, hooks) {
			if (typeof source.onupdate === "function") hooks.push(source.onupdate.bind(vnode.state, vnode))
		}
		function shouldNotUpdate(vnode, old) {
			var forceVnodeUpdate, forceComponentUpdate
			if (vnode.attrs != null && typeof vnode.attrs.onbeforeupdate === "function") forceVnodeUpdate = vnode.attrs.onbeforeupdate.call(vnode.state, vnode, old)
			if (typeof vnode.tag !== "string" && typeof vnode._state.onbeforeupdate === "function") forceComponentUpdate = vnode._state.onbeforeupdate.call(vnode.state, vnode, old)
			if (!(forceVnodeUpdate === undefined && forceComponentUpdate === undefined) && !forceVnodeUpdate && !forceComponentUpdate) {
				vnode.dom = old.dom
				vnode.domSize = old.domSize
				vnode.instance = old.instance
				return true
			}
			return false
		}
		function render(dom, vnodes) {
			if (!dom) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.")
			var hooks = []
			var active = $doc.activeElement
			var namespace = dom.namespaceURI
			// First time0 rendering into a node clears it out
			if (dom.vnodes == null) dom.textContent = ""
			if (!Array.isArray(vnodes)) vnodes = [vnodes]
			updateNodes(dom, dom.vnodes, Vnode.normalizeChildren(vnodes), false, hooks, null, namespace === "http://www.w3.org/1999/xhtml" ? undefined : namespace)
			dom.vnodes = vnodes
			for (var i = 0; i < hooks.length; i++) hooks[i]()
			// document.activeElement can return null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
			if (active != null && $doc.activeElement !== active) active.focus()
		}
		return {render: render, setEventCallback: setEventCallback}
	}
	function throttle(callback) {
		//60fps translates to 16.6ms, round it down since setTimeout requires int
		var time = 16
		var last = 0, pending = null
		var timeout = typeof requestAnimationFrame === "function" ? requestAnimationFrame : setTimeout
		return function() {
			var now = Date.now()
			if (last === 0 || now - last >= time) {
				last = now
				callback()
			}
			else if (pending === null) {
				pending = timeout(function() {
					pending = null
					callback()
					last = Date.now()
				}, time - (now - last))
			}
		}
	}
	var _11 = function($window) {
		var renderService = coreRenderer($window)
		renderService.setEventCallback(function(e) {
			if (e.redraw === false) e.redraw = undefined
			else redraw()
		})
		var callbacks = []
		function subscribe(key1, callback) {
			unsubscribe(key1)
			callbacks.push(key1, throttle(callback))
		}
		function unsubscribe(key1) {
			var index = callbacks.indexOf(key1)
			if (index > -1) callbacks.splice(index, 2)
		}
		function redraw() {
			for (var i = 1; i < callbacks.length; i += 2) {
				callbacks[i]()
			}
		}
		return {subscribe: subscribe, unsubscribe: unsubscribe, redraw: redraw, render: renderService.render}
	}
	var redrawService = _11(window)
	requestService.setCompletionCallback(redrawService.redraw)
	var _16 = function(redrawService0) {
		return function(root, component) {
			if (component === null) {
				redrawService0.render(root, [])
				redrawService0.unsubscribe(root)
				return
			}
			
			if (component.view == null && typeof component !== "function") throw new Error("m.mount(element, component) expects a component, not a vnode")
			
			var run0 = function() {
				redrawService0.render(root, Vnode(component))
			}
			redrawService0.subscribe(root, run0)
			redrawService0.redraw()
		}
	}
	m.mount = _16(redrawService)
	var Promise = PromisePolyfill
	var parseQueryString = function(string) {
		if (string === "" || string == null) return {}
		if (string.charAt(0) === "?") string = string.slice(1)
		var entries = string.split("&"), data0 = {}, counters = {}
		for (var i = 0; i < entries.length; i++) {
			var entry = entries[i].split("=")
			var key5 = decodeURIComponent(entry[0])
			var value = entry.length === 2 ? decodeURIComponent(entry[1]) : ""
			if (value === "true") value = true
			else if (value === "false") value = false
			var levels = key5.split(/\]\[?|\[/)
			var cursor = data0
			if (key5.indexOf("[") > -1) levels.pop()
			for (var j = 0; j < levels.length; j++) {
				var level = levels[j], nextLevel = levels[j + 1]
				var isNumber = nextLevel == "" || !isNaN(parseInt(nextLevel, 10))
				var isValue = j === levels.length - 1
				if (level === "") {
					var key5 = levels.slice(0, j).join()
					if (counters[key5] == null) counters[key5] = 0
					level = counters[key5]++
				}
				if (cursor[level] == null) {
					cursor[level] = isValue ? value : isNumber ? [] : {}
				}
				cursor = cursor[level]
			}
		}
		return data0
	}
	var coreRouter = function($window) {
		var supportsPushState = typeof $window.history.pushState === "function"
		var callAsync0 = typeof setImmediate === "function" ? setImmediate : setTimeout
		function normalize1(fragment0) {
			var data = $window.location[fragment0].replace(/(?:%[a-f89][a-f0-9])+/gim, decodeURIComponent)
			if (fragment0 === "pathname" && data[0] !== "/") data = "/" + data
			return data
		}
		var asyncId
		function debounceAsync(callback0) {
			return function() {
				if (asyncId != null) return
				asyncId = callAsync0(function() {
					asyncId = null
					callback0()
				})
			}
		}
		function parsePath(path, queryData, hashData) {
			var queryIndex = path.indexOf("?")
			var hashIndex = path.indexOf("#")
			var pathEnd = queryIndex > -1 ? queryIndex : hashIndex > -1 ? hashIndex : path.length
			if (queryIndex > -1) {
				var queryEnd = hashIndex > -1 ? hashIndex : path.length
				var queryParams = parseQueryString(path.slice(queryIndex + 1, queryEnd))
				for (var key4 in queryParams) queryData[key4] = queryParams[key4]
			}
			if (hashIndex > -1) {
				var hashParams = parseQueryString(path.slice(hashIndex + 1))
				for (var key4 in hashParams) hashData[key4] = hashParams[key4]
			}
			return path.slice(0, pathEnd)
		}
		var router = {prefix: "#!"}
		router.getPath = function() {
			var type2 = router.prefix.charAt(0)
			switch (type2) {
				case "#": return normalize1("hash").slice(router.prefix.length)
				case "?": return normalize1("search").slice(router.prefix.length) + normalize1("hash")
				default: return normalize1("pathname").slice(router.prefix.length) + normalize1("search") + normalize1("hash")
			}
		}
		router.setPath = function(path, data, options) {
			var queryData = {}, hashData = {}
			path = parsePath(path, queryData, hashData)
			if (data != null) {
				for (var key4 in data) queryData[key4] = data[key4]
				path = path.replace(/:([^\/]+)/g, function(match2, token) {
					delete queryData[token]
					return data[token]
				})
			}
			var query = buildQueryString(queryData)
			if (query) path += "?" + query
			var hash = buildQueryString(hashData)
			if (hash) path += "#" + hash
			if (supportsPushState) {
				var state = options ? options.state : null
				var title = options ? options.title : null
				$window.onpopstate()
				if (options && options.replace) $window.history.replaceState(state, title, router.prefix + path)
				else $window.history.pushState(state, title, router.prefix + path)
			}
			else $window.location.href = router.prefix + path
		}
		router.defineRoutes = function(routes, resolve, reject) {
			function resolveRoute() {
				var path = router.getPath()
				var params = {}
				var pathname = parsePath(path, params, params)
				var state = $window.history.state
				if (state != null) {
					for (var k in state) params[k] = state[k]
				}
				for (var route0 in routes) {
					var matcher = new RegExp("^" + route0.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$")
					if (matcher.test(pathname)) {
						pathname.replace(matcher, function() {
							var keys = route0.match(/:[^\/]+/g) || []
							var values = [].slice.call(arguments, 1, -2)
							for (var i = 0; i < keys.length; i++) {
								params[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i])
							}
							resolve(routes[route0], params, path, route0)
						})
						return
					}
				}
				reject(path, params)
			}
			if (supportsPushState) $window.onpopstate = debounceAsync(resolveRoute)
			else if (router.prefix.charAt(0) === "#") $window.onhashchange = resolveRoute
			resolveRoute()
		}
		return router
	}
	var _20 = function($window, redrawService0) {
		var routeService = coreRouter($window)
		var identity = function(v) {return v}
		var render1, component, attrs3, currentPath, lastUpdate
		var route = function(root, defaultRoute, routes) {
			if (root == null) throw new Error("Ensure the DOM element that was passed to `m.route` is not undefined")
			var run1 = function() {
				if (render1 != null) redrawService0.render(root, render1(Vnode(component, attrs3.key, attrs3)))
			}
			var bail = function(path) {
				if (path !== defaultRoute) routeService.setPath(defaultRoute, null, {replace: true})
				else throw new Error("Could not resolve default route " + defaultRoute)
			}
			routeService.defineRoutes(routes, function(payload, params, path) {
				var update = lastUpdate = function(routeResolver, comp) {
					if (update !== lastUpdate) return
					component = comp != null && (typeof comp.view === "function" || typeof comp === "function")? comp : "div"
					attrs3 = params, currentPath = path, lastUpdate = null
					render1 = (routeResolver.render || identity).bind(routeResolver)
					run1()
				}
				if (payload.view || typeof payload === "function") update({}, payload)
				else {
					if (payload.onmatch) {
						Promise.resolve(payload.onmatch(params, path)).then(function(resolved) {
							update(payload, resolved)
						}, bail)
					}
					else update(payload, "div")
				}
			}, bail)
			redrawService0.subscribe(root, run1)
		}
		route.set = function(path, data, options) {
			if (lastUpdate != null) {
				options = options || {}
				options.replace = true
			}
			lastUpdate = null
			routeService.setPath(path, data, options)
		}
		route.get = function() {return currentPath}
		route.prefix = function(prefix0) {routeService.prefix = prefix0}
		route.link = function(vnode1) {
			vnode1.dom.setAttribute("href", routeService.prefix + vnode1.attrs.href)
			vnode1.dom.onclick = function(e) {
				if (e.ctrlKey || e.metaKey || e.shiftKey || e.which === 2) return
				e.preventDefault()
				e.redraw = false
				var href = this.getAttribute("href")
				if (href.indexOf(routeService.prefix) === 0) href = href.slice(routeService.prefix.length)
				route.set(href, undefined, undefined)
			}
		}
		route.param = function(key3) {
			if(typeof attrs3 !== "undefined" && typeof key3 !== "undefined") return attrs3[key3]
			return attrs3
		}
		return route
	}
	m.route = _20(window, redrawService)
	m.withAttr = function(attrName, callback1, context) {
		return function(e) {
			callback1.call(context || this, attrName in e.currentTarget ? e.currentTarget[attrName] : e.currentTarget.getAttribute(attrName))
		}
	}
	var _28 = coreRenderer(window)
	m.render = _28.render
	m.redraw = redrawService.redraw
	m.request = requestService.request
	m.jsonp = requestService.jsonp
	m.parseQueryString = parseQueryString
	m.buildQueryString = buildQueryString
	m.version = "1.1.5"
	m.vnode = Vnode
	if (true) module["exports"] = m
	else window.m = m
	}());
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).setImmediate, (function() { return this; }()), __webpack_require__(5)(module)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// setimmediate attaches itself to the global object
	__webpack_require__(3);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";

	    if (global.setImmediate) {
	        return;
	    }

	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;

	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }

	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }

	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }

	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }

	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }

	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }

	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };

	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }

	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }

	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };

	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }

	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }

	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }

	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();

	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();

	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();

	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 68
	        installReadyStateChangeImplementation();

	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }

	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.util = exports.tlm = exports.time = exports.packets = exports.gui = exports.format = exports.evr = exports.events = exports.cmd = undefined;

	var _events = __webpack_require__(7);

	var _events2 = _interopRequireDefault(_events);

	var _packets = __webpack_require__(8);

	var _packets2 = _interopRequireDefault(_packets);

	var _cmd = __webpack_require__(9);

	var cmd = _interopRequireWildcard(_cmd);

	var _evr = __webpack_require__(10);

	var evr = _interopRequireWildcard(_evr);

	var _format = __webpack_require__(11);

	var format = _interopRequireWildcard(_format);

	var _gui = __webpack_require__(13);

	var gui = _interopRequireWildcard(_gui);

	var _time = __webpack_require__(12);

	var time = _interopRequireWildcard(_time);

	var _tlm = __webpack_require__(235);

	var tlm = _interopRequireWildcard(_tlm);

	var _util = __webpack_require__(226);

	var util = _interopRequireWildcard(_util);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.cmd = cmd;
	exports.events = _events2.default;
	exports.evr = evr;
	exports.format = format;
	exports.gui = gui;
	exports.packets = _packets2.default;
	exports.time = time;
	exports.tlm = tlm;
	exports.util = util; /*
	                      * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	                      * Bespoke Link to Instruments and Small Satellites (BLISS)
	                      *
	                      * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	                      * RESERVED. United States Government Sponsorship acknowledged. Any
	                      * commercial use must be negotiated with the Office of Technology Transfer
	                      * at the California Institute of Technology.
	                      *
	                      * This software may be subject to U.S. export control laws. By accepting
	                      * this software, the user agrees to comply with all applicable U.S. export
	                      * laws and regulations. User has the responsibility to obtain export licenses,
	                      * or other export authority as may be required before exporting such
	                      * information to foreign countries or providing access to foreign persons.
	                      */

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	var EventBus = function () {
	    function EventBus() {
	        _classCallCheck(this, EventBus);

	        this._listeners = {};
	    }

	    _createClass(EventBus, [{
	        key: "emit",
	        value: function emit(event /* , ... */) {
	            var _this = this;

	            var listeners = this._listeners[event];

	            if (listeners !== undefined) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                listeners.forEach(function (fn) {
	                    return fn.apply(_this, args);
	                });
	            }
	        }
	    }, {
	        key: "off",
	        value: function off(event, fn) {
	            var listeners = this._listeners[event];
	            var index = listeners && listeners.indexOf(fn);
	            var found = index !== undefined && index !== -1;

	            if (found) {
	                listeners.splice(index, 1);
	            }

	            return found;
	        }
	    }, {
	        key: "on",
	        value: function on(event, fn) {
	            this._listeners[event] = this._listeners[event] || [];
	            this._listeners[event].push(fn);
	        }
	    }]);

	    return EventBus;
	}();

	exports.default = new EventBus();

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	/**
	 * PacketBuffer
	 *
	 * A `PacketBuffer` implements a circular FIFO queue with
	 * constant-time insert and remove operations.  PacketBuffers have a
	 * fixed-size `capacity` for a certain number of packets.  This allows
	 * for a history of packets to be maintained (e.g. 600 1Hz packets
	 * stores the last 10 minutes of packet data).
	 *
	 * Clients of `PacketBuffer` peek at packets in LIFO order.  That is,
	 * they're often interested in the most recent packets.  Therefore,
	 * `PacketBuffer.get(0)` is always the most current packet, `get(1)`
	 * the next most current, and so on.  The oldest packet is retreived
	 * via `get(capacity - 1)`.
	 */
	var PacketBuffer = function () {
	    /**
	     * Creates a new PacketBuffer to hold up to capacity packets.
	     */
	    function PacketBuffer() {
	        var capacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 600;

	        _classCallCheck(this, PacketBuffer);

	        this._buffer = new Array(capacity);
	        this.flush();
	    }

	    /**
	     * Maps a client packet index onto the underlying circular _buffer
	     * index.
	     *
	     * @return the underlying circular _buffer index for n.
	     */


	    _createClass(PacketBuffer, [{
	        key: "_index",
	        value: function _index(n) {

	            return (this._start + this._length + n) % this._buffer.length;
	        }

	        /**
	         * @return the total capacity of this PacketBuffer.
	         */

	    }, {
	        key: "flush",


	        /**
	         * Flushes (empties) the contents of this PacketBuffer.
	         */
	        value: function flush() {
	            this._length = 0;
	            this._start = 0;
	            this._buffer.fill(undefined);
	        }

	        /**
	         * @return the nth most recent packet (starting at zero).
	         */

	    }, {
	        key: "get",
	        value: function get(n) {
	            var newest = this._start + this._length - 1;
	            var index = (newest - n) % this._buffer.length;
	            return this._buffer[index];
	        }

	        /**
	         * Inserts a packet into this PacketBuffer, removing the oldest
	         * packet, if the buffer is at capacity.
	         */

	    }, {
	        key: "insert",
	        value: function insert(packet) {
	            if (this._length + 1 > this._buffer.length) {
	                this.remove();
	            }

	            var next = this._start + this._length;
	            var index = next % this._buffer.length;
	            this._buffer[index] = packet;
	            this._length += 1;
	        }

	        /**
	         * @return the length of this PacketBuffer.
	         */

	    }, {
	        key: "remove",


	        /**
	         * Removes the oldest packet from this PacketBuffer.
	         *
	         * @return the removed packet
	         */
	        value: function remove() {
	            var packet = this._buffer[this._start];
	            this._start = (this._start + 1) % this._buffer.length;
	            this._length -= 1;

	            return packet;
	        }
	    }, {
	        key: "capacity",
	        get: function get() {
	            return this._capacity;
	        }
	    }, {
	        key: "length",
	        get: function get() {
	            return this._length;
	        }
	    }]);

	    return PacketBuffer;
	}();

	var PacketBuffers = function () {
	    function PacketBuffers() {
	        _classCallCheck(this, PacketBuffers);
	    }

	    _createClass(PacketBuffers, [{
	        key: "create",
	        value: function create(name) {
	            var capacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 600;

	            var created = false;

	            if (this[name] === undefined) {
	                this[name] = new PacketBuffer(capacity);
	                created = true;
	            }

	            return created;
	        }
	    }, {
	        key: "insert",
	        value: function insert(name, packet) {
	            if (this[name] === undefined) {
	                this.create(name);
	            }

	            this[name].insert(packet);
	        }
	    }]);

	    return PacketBuffers;
	}();

	exports.default = new PacketBuffers();

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*
	* Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	* Bespoke Link to Instruments and Small Satellites (BLISS)
	*
	* Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	* RESERVED. United States Government Sponsorship acknowledged. Any
	* commercial use must be negotiated with the Office of Technology Transfer
	* at the California Institute of Technology.
	*
	* This software may be subject to U.S. export control laws. By accepting
	* this software, the user agrees to comply with all applicable U.S. export
	* laws and regulations. User has the responsibility to obtain export licenses,
	* or other export authority as may be required before exporting such
	* information to foreign countries or providing access to foreign persons.
	*/

	var CommandDictionary = function () {
	    /**
	     * Creates a new (empty) CommandDictionary.
	     */
	    function CommandDictionary() {
	        _classCallCheck(this, CommandDictionary);

	        this._byOpcode = {};
	        this._bySubsystem = {};
	    }

	    /**
	     * Adds the given CommandDefinition to this CommandDictionary.
	     */


	    _createClass(CommandDictionary, [{
	        key: 'add',
	        value: function add(defn) {
	            if (defn instanceof CommandDefinition) {
	                this[defn.name] = defn;
	                this._byOpcode[defn.opcode] = defn;

	                if (defn.subsystem) {
	                    var commands = this._bySubsystem[defn.subsystem] || [];

	                    commands.push(defn);
	                    this._bySubsystem[defn.subsystem] = commands;
	                }
	            }
	        }
	    }, {
	        key: 'getByOpcode',


	        /**
	         * Returns the CommandDefinition with the given opcode or the
	         * given opcode if no definition exists for it.
	         */
	        value: function getByOpcode(opcode) {
	            if (this._byOpcode[opcode]) {
	                return this._byOpcode[opcode];
	            } else {
	                return opcode;
	            }
	        }

	        /**
	         * Parses the given plain Javascript Object or JSON string and
	         * returns a new CommandDictionary, mapping packet names to
	         * PacketDefinitions.
	         */

	    }, {
	        key: 'bySubsystem',
	        get: function get() {
	            return this._bySubsystem;
	        }
	    }], [{
	        key: 'parse',
	        value: function parse(obj) {
	            var dict = new CommandDictionary();

	            if (typeof obj === 'string') {
	                obj = JSON.parse(obj);
	            }

	            for (var name in obj) {
	                dict.add(new CommandDefinition(obj[name]));
	            }

	            return dict;
	        }
	    }]);

	    return CommandDictionary;
	}();

	var CommandDefinition = function () {
	    function CommandDefinition(obj) {
	        _classCallCheck(this, CommandDefinition);

	        this._arguments = obj.arguments;
	        this._desc = obj.desc;
	        this._name = obj.name;
	        this._opcode = obj.opcode;
	        this._subsystem = obj.subsystem;
	        this._title = obj.title;
	    }

	    _createClass(CommandDefinition, [{
	        key: 'arguments',
	        get: function get() {
	            return this._arguments;
	        }
	    }, {
	        key: 'desc',
	        get: function get() {
	            return this._desc;
	        }
	    }, {
	        key: 'name',
	        get: function get() {
	            return this._name;
	        }
	    }, {
	        key: 'opcode',
	        get: function get() {
	            return this._opcode;
	        }
	    }, {
	        key: 'subsystem',
	        get: function get() {
	            return this._subsystem;
	        }
	    }, {
	        key: 'title',
	        get: function get() {
	            return this._title;
	        }
	    }], [{
	        key: 'parse',
	        value: function parse(obj) {
	            if (typeof obj === 'string') {
	                obj = JSON.parse(obj);
	            }

	            return new CommandDefinition(obj);
	        }
	    }]);

	    return CommandDefinition;
	}();

	exports.CommandDictionary = CommandDictionary;
	exports.CommandDefinition = CommandDefinition;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	var EVRDictionary = function () {
	    /**
	     * Creates a new (empty) EVRDictionary.
	     */
	    function EVRDictionary() {
	        _classCallCheck(this, EVRDictionary);

	        this._codes = {};
	    }

	    /**
	     * Adds the given EVRDefinition to this EVRDictionary.
	     */


	    _createClass(EVRDictionary, [{
	        key: 'add',
	        value: function add(defn) {
	            if (defn instanceof EVRDefinition) {
	                this[defn.name] = defn;
	                this._codes[defn.code] = defn;
	            }
	        }

	        /**
	         * Returns the EVRDefinition with the given code or the
	         * supplied code if no definition exists for it.
	         */

	    }, {
	        key: 'getByCode',
	        value: function getByCode(code) {
	            if (this._codes[code]) {
	                return this._codes[code];
	            } else {
	                return code;
	            }
	        }

	        /**
	         * Parses the given plain Javascript Object or JSON string and
	         * returns a new EVRDictionary, mapping EVR names to
	         * EVRDefinitions.
	         */

	    }], [{
	        key: 'parse',
	        value: function parse(obj) {
	            var dict = new EVRDictionary();

	            if (typeof obj === 'string') {
	                obj = JSON.parse(obj);
	            }

	            for (var k in obj) {
	                dict.add(new EVRDefinition(obj[k]));
	            }

	            return dict;
	        }
	    }]);

	    return EVRDictionary;
	}();

	var EVRDefinition = function () {
	    function EVRDefinition(obj) {
	        _classCallCheck(this, EVRDefinition);

	        this._desc = obj.desc;
	        this._name = obj.name;
	        this._code = obj.code;
	    }

	    _createClass(EVRDefinition, [{
	        key: 'desc',
	        get: function get() {
	            return this._desc;
	        }
	    }, {
	        key: 'name',
	        get: function get() {
	            return this._name;
	        }
	    }, {
	        key: 'code',
	        get: function get() {
	            return this._code;
	        }
	    }], [{
	        key: 'parse',
	        value: function parse(obj) {
	            if (typeof obj === 'string') {
	                obj = JSON.parse(obj);
	            }

	            return new EVRDefinition(obj);
	        }
	    }]);

	    return EVRDefinition;
	}();

	exports.EVRDictionary = EVRDictionary;
	exports.EVRDefinition = EVRDefinition;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.tz = exports.time = exports.datetime = exports.date = undefined;

	var _time = __webpack_require__(12);

	function date(obj) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        _ref$doy = _ref.doy,
	        doy = _ref$doy === undefined ? false : _ref$doy,
	        _ref$utc = _ref.utc,
	        utc = _ref$utc === undefined ? true : _ref$utc;

	    var yyyy = void 0,
	        mm = void 0,
	        dd = void 0,
	        formatted = void 0;
	    var date = normalize(obj);

	    if (utc) {
	        yyyy = date.getUTCFullYear();
	        mm = date.getUTCMonth();
	        dd = date.getUTCDate();
	    } else {
	        yyyy = date.getFullYear();
	        mm = date.getMonth();
	        dd = date.getDate();
	    }

	    if (doy) {
	        formatted = yyyy + '-' + pad3((0, _time.DOY)(yyyy, mm, dd));
	    } else {
	        formatted = yyyy + '-' + pad2(mm + 1) + '-' + pad2(dd);
	    }

	    return formatted;
	} /*
	   * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	   * Bespoke Link to Instruments and Small Satellites (BLISS)
	   *
	   * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	   * RESERVED. United States Government Sponsorship acknowledged. Any
	   * commercial use must be negotiated with the Office of Technology Transfer
	   * at the California Institute of Technology.
	   *
	   * This software may be subject to U.S. export control laws. By accepting
	   * this software, the user agrees to comply with all applicable U.S. export
	   * laws and regulations. User has the responsibility to obtain export licenses,
	   * or other export authority as may be required before exporting such
	   * information to foreign countries or providing access to foreign persons.
	   */

	function datetime(obj) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    return date(obj, opts) + ' ' + time(obj, opts) + ' ' + tz(obj, opts);
	}

	/**
	 * @returns a Javascript Date object given either a date string or a
	 * Javascript Date object.
	 */
	function normalize(obj) {
	    var result = obj;

	    if (typeof obj === 'string') {
	        result = Date.parse(obj);
	    } else if (typeof obj === 'number') {
	        result = new Date(obj);
	    }

	    return result;
	}

	/**
	 * @returns the number n, as a string, padded with a leading zero if
	 * less-than 10.
	 */
	function pad2(n) {
	    return n < 10 ? '0' + n : n;
	}

	/**
	 * @returns the number n, as a string, padded with one or two leading
	 * zero if less-than 100 and 10, respectively.
	 */
	function pad3(n) {
	    return n < 100 ? '0' + pad2(n) : n;
	}

	function time(obj) {
	    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        _ref2$h = _ref2.h24,
	        h24 = _ref2$h === undefined ? true : _ref2$h,
	        _ref2$utc = _ref2.utc,
	        utc = _ref2$utc === undefined ? true : _ref2$utc;

	    var hh = void 0,
	        mm = void 0,
	        ss = void 0,
	        formatted = void 0;
	    var suffix = ' AM';
	    var time = normalize(obj);

	    if (utc) {
	        hh = time.getUTCHours();
	        mm = time.getUTCMinutes();
	        ss = time.getUTCSeconds();
	    } else {
	        hh = time.getHours();
	        mm = time.getMinutes();
	        ss = time.getSeconds();
	    }

	    if (!h24 && hh > 12) {
	        hh -= 12;
	        suffix = ' PM';
	    }

	    formatted = pad2(hh) + ':' + pad2(mm) + ':' + pad2(ss);

	    if (!h24) {
	        formatted += suffix;
	    }

	    return formatted;
	}

	function tz(obj) {
	    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        _ref3$utc = _ref3.utc,
	        utc = _ref3$utc === undefined ? true : _ref3$utc;

	    return utc ? 'UTC' : (0, _time.timezone)(obj);
	}

	exports.date = date;
	exports.datetime = datetime;
	exports.time = time;
	exports.tz = tz;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	/**
	 * @returns the Day Of Year (DOY) for the given date.
	 */
	function DOY(year, month, day) {
	  var days = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
	  var doy = days[month] + day;
	  if (isLeap(year) && month >= 2) {
	    doy += 1;
	  }

	  return doy;
	}

	/**
	 * @returns true if year is a leap year, false otherwise.
	 */
	function isLeap(year) {
	  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
	}

	/**
	 * @returns the timezone string for the given Javascript Date.
	 */
	function timezone(date) {
	  var match = /\((\w+)\)$/.exec(date.toString());
	  return Array.isArray(match) && match.length > 1 ? match[1] : '';
	}

	exports.DOY = DOY;
	exports.isLeap = isLeap;
	exports.timezone = timezone;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.filterNodes = exports.init = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
	                                                                                                                                                                                                                                                                               * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	                                                                                                                                                                                                                                                                               * Bespoke Link to Instruments and Small Satellites (BLISS)
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	                                                                                                                                                                                                                                                                               * RESERVED. United States Government Sponsorship acknowledged. Any
	                                                                                                                                                                                                                                                                               * commercial use must be negotiated with the Office of Technology Transfer
	                                                                                                                                                                                                                                                                               * at the California Institute of Technology.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * This software may be subject to U.S. export control laws. By accepting
	                                                                                                                                                                                                                                                                               * this software, the user agrees to comply with all applicable U.S. export
	                                                                                                                                                                                                                                                                               * laws and regulations. User has the responsibility to obtain export licenses,
	                                                                                                                                                                                                                                                                               * or other export authority as may be required before exporting such
	                                                                                                                                                                                                                                                                               * information to foreign countries or providing access to foreign persons.
	                                                                                                                                                                                                                                                                               */

	var _Clock = __webpack_require__(14);

	Object.keys(_Clock).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Clock[key];
	        }
	    });
	});

	var _Command = __webpack_require__(15);

	Object.keys(_Command).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Command[key];
	        }
	    });
	});

	var _Field = __webpack_require__(158);

	Object.keys(_Field).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Field[key];
	        }
	    });
	});

	var _Messages = __webpack_require__(161);

	Object.keys(_Messages).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Messages[key];
	        }
	    });
	});

	var _Plot = __webpack_require__(162);

	Object.keys(_Plot).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Plot[key];
	        }
	    });
	});

	var _Script = __webpack_require__(188);

	Object.keys(_Script).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Script[key];
	        }
	    });
	});

	var _Query = __webpack_require__(218);

	Object.keys(_Query).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Query[key];
	        }
	    });
	});

	var _Search = __webpack_require__(219);

	Object.keys(_Search).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Search[key];
	        }
	    });
	});

	var _Sequence = __webpack_require__(223);

	Object.keys(_Sequence).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Sequence[key];
	        }
	    });
	});

	var _Status = __webpack_require__(224);

	Object.keys(_Status).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Status[key];
	        }
	    });
	});

	var _TabSet = __webpack_require__(225);

	Object.keys(_TabSet).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _TabSet[key];
	        }
	    });
	});

	var _Util = __webpack_require__(234);

	Object.keys(_Util).forEach(function (key) {
	    if (key === "default" || key === "__esModule") return;
	    Object.defineProperty(exports, key, {
	        enumerable: true,
	        get: function get() {
	            return _Util[key];
	        }
	    });
	});

	var _filter = __webpack_require__(55);

	var _filter2 = _interopRequireDefault(_filter);

	var _map = __webpack_require__(146);

	var _map2 = _interopRequireDefault(_map);

	var _cmd = __webpack_require__(9);

	var _evr = __webpack_require__(10);

	var _tlm = __webpack_require__(235);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Registry = {};

	// NOTE: The `exports` symbol in the two lines below used to read
	// `bliss.gui` before I moved this code inside the `bliss.gui` module.
	// Looking at the Babel ES6 => ES5 transpiled code, `exports` resolves
	// as the current module.  I'm not sure whether reyling on `exports`
	// is valid ES6, but from my quick perusal of The ECMAScript 2015
	// Language Specification, Section 9.4.6 Module Namespace Exotic
	// Objects (p. 105), it just might be valid.

	Object.keys(exports).map(function (name) {
	    Registry['bliss-' + name.toLowerCase()] = exports[name];
	});

	/**
	 * @returns a plain Javascript object representation of the HTML
	 * element attributes in a DOM NamedNodeMap.  That is:
	 *
	 *     `<... name="value" ...>`
	 *
	 * pairs become:
	 *
	 * `{ ..., name: value, ... }`
	 *
	 * pairs.
	 */
	function attrs2obj(attrs) {
	    var obj = {};

	    for (var n = 0; n < attrs.length; ++n) {
	        var item = attrs.item(n);
	        var value = item.value;

	        if (value == 'true') value = true;
	        if (value == 'false') value = false;

	        obj[item.name] = value;
	    }

	    return obj;
	}

	/**
	 * Creates a Mithril vnode for the given DOM element `elem`.
	 *
	 * @returns a Mithril vnode
	 */
	function createMithrilNode(elem) {
	    var node = null;

	    if (elem.nodeType == Node.ELEMENT_NODE) {
	        var name = elem.nodeName.toLowerCase();
	        var attrs = attrs2obj(elem.attributes);
	        var children = createMithrilNodes(elem.childNodes);

	        if (name.substring(0, 6) === 'bliss-') {
	            name = 'bliss-' + name.substring(6).replace('-', '');
	        }

	        node = m(Registry[name] || name, attrs, children);
	    } else if (elem.nodeType == Node.TEXT_NODE) {
	        node = elem.nodeValue;
	    }

	    return node;
	}

	function makeMithrilNode(e) {
	    //console.log(e)
	    //console.log(e.tag)
	    if (e === undefined || e.tag === undefined) {
	        return e;
	    }

	    if (e.children && _typeof(e.children) === 'object') {
	        e.children = filterNodes(e.children);
	    }

	    //console.log(e.attrs)
	    //console.log(e.attrs.className)
	    if (e.attrs && e.attrs.className && e.attrs.className.indexOf('make-mithril-node') !== -1) {
	        var template = document.createElement('template');
	        template.innerHTML = e.text;
	        var name = template.content.firstChild.nodeName.toLowerCase();
	        var attrs = {};
	        for (var i = 0; i < template.content.firstChild.attributes.length; i++) {
	            var a = template.content.firstChild.attributes.item(i);
	            attrs[a.name] = a.value;
	        }
	        return m(Registry[name] || name, attrs);
	    } else {
	        return e;
	    }
	}

	function filterNodes(n) {
	    var nodes = (0, _map2.default)(n, makeMithrilNode);
	    console.log(nodes);
	    return nodes;
	}

	/**
	 * Creates a Mithril vnode for each DOM element in `elems`.
	 *
	 * @returns an array of Mithril vnodes.
	 */
	function createMithrilNodes(elems) {
	    return (0, _filter2.default)((0, _map2.default)(elems, createMithrilNode), function (n) {
	        return n !== null;
	    });
	}

	/**
	 * Initializes the BLISS GUI.
	 */
	function init() {
	    ready(function () {
	        var root = document.body;
	        root.appendChild(document.createElement('bliss-prompt'));
	        root.appendChild(document.createElement('bliss-modal'));
	        var cloned = root.cloneNode(true);
	        var elems = (0, _map2.default)(cloned.childNodes, function (c) {
	            return c;
	        });

	        bliss.cmd = { dict: {} };
	        bliss.cmd.promise = m.request({ url: '/cmd/dict' });
	        bliss.cmd.promise.then(function (dict) {
	            bliss.cmd.dict = _cmd.CommandDictionary.parse(dict);
	        });

	        m.request({ url: '/evr/dict' }).then(function (dict) {
	            bliss.evr.dict = _evr.EVRDictionary.parse(dict);
	        });

	        bliss.tlm = { dict: {} };
	        bliss.tlm.promise = m.request({ url: '/tlm/dict' });
	        bliss.tlm.promise.then(function (dict) {
	            var proto = location.protocol === 'https:' ? 'wss' : 'ws';
	            var url = proto + '://' + location.host + '/tlm/realtime';

	            bliss.tlm.dict = _tlm.TelemetryDictionary.parse(dict);
	            bliss.tlm.stream = new _tlm.TelemetryStream(url, bliss.tlm.dict);

	            bliss.events.on('bliss:tlm:packet', function () {
	                m.redraw();
	            });
	        });

	        m.request({ url: '/limits/dict' }).then(function (dict) {
	            bliss.limits = {};
	            bliss.limits.dict = dict;
	        });

	        var source = new EventSource('/events');
	        source.addEventListener('message', function (event) {
	            var e = JSON.parse(event.data);
	            bliss.events.emit(e.name, e.data);
	        });

	        m.mount(root, { view: function view() {
	                return createMithrilNodes(elems);
	            } });
	    });
	}

	/**
	 * Calls the given when the HTML document is loaded and ready.
	 */
	function ready(fn) {
	    if (document.readyState !== 'loading') {
	        fn();
	    } else {
	        document.addEventListener('DOMContentLoaded', fn);
	    }
	}

	exports.init = init;
	exports.filterNodes = filterNodes;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Clock = undefined;

	var _mithril = __webpack_require__(1);

	var _mithril2 = _interopRequireDefault(_mithril);

	var _format = __webpack_require__(11);

	var format = _interopRequireWildcard(_format);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * BLISS Clock UI Widget
	 *
	 * The BLISS Clock UI Widget displays a clock with date and time that
	 * updates every second.  The display is configurable with at
	 * initialization time or by clicking on specific parts of the time.
	 *
	 * Configurable / Toggleable options include:
	 *
	 *   - 12-hour or 24-hour time
	 *   - Date (month and day) or Day of Year (DOY)
	 *   - UTC or localtime
	 */
	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	var Clock = {
	    _now: null,
	    _h24: true,
	    _utc: true,
	    _doy: false,

	    toggleH24: function toggleH24() {
	        this._h24 = !this._h24;
	    },
	    toggleUTC: function toggleUTC() {
	        this._utc = !this._utc;
	    },
	    toggleDOY: function toggleDOY() {
	        this._doy = !this._doy;
	    },
	    update: function update() {
	        this._now = new Date();
	    },


	    // Mithril lifecycle method
	    oninit: function oninit(vnode) {
	        var attrs = vnode.attrs;

	        this._h24 = attrs.h24 !== undefined ? attrs.h24 : Clock._h24;
	        this._utc = attrs.utc !== undefined ? attrs.utc : Clock._utc;
	        this._doy = attrs.doy !== undefined ? attrs.doy : Clock._doy;
	        this.update();
	    },


	    // Mithril lifecycle method
	    oncreate: function oncreate(vnode) {
	        var _this = this;

	        setInterval(function () {
	            Clock.update.call(_this);_mithril2.default.redraw();
	        }, 1000);
	    },


	    // Mithril view() method
	    view: function view(vnode) {
	        var opts = { doy: this._doy, h24: this._h24, utc: this._utc };
	        var date = format.date(this._now, opts);
	        var time = format.time(this._now, opts);
	        var tz = format.tz(this._now, opts);

	        return (0, _mithril2.default)('bliss-clock', vnode.attrs, [(0, _mithril2.default)('span.date', { onclick: Clock.toggleDOY.bind(this) }, date), ' ', (0, _mithril2.default)('span.time', { onclick: Clock.toggleH24.bind(this) }, time), ' ', (0, _mithril2.default)('span.tz', { onclick: Clock.toggleUTC.bind(this) }, tz)]);
	    }
	};

	exports.default = Clock;
	exports.Clock = Clock;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.CommandConfigure = exports.CommandSearch = exports.CommandInput = exports.CommandHistory = undefined;

	var _each = __webpack_require__(17);

	var _each2 = _interopRequireDefault(_each);

	var _filter = __webpack_require__(55);

	var _filter2 = _interopRequireDefault(_filter);

	var _flatten = __webpack_require__(142);

	var _flatten2 = _interopRequireDefault(_flatten);

	var _flatMap = __webpack_require__(145);

	var _flatMap2 = _interopRequireDefault(_flatMap);

	var _groupBy = __webpack_require__(148);

	var _groupBy2 = _interopRequireDefault(_groupBy);

	var _map = __webpack_require__(146);

	var _map2 = _interopRequireDefault(_map);

	var _values = __webpack_require__(154);

	var _values2 = _interopRequireDefault(_values);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var typeahead = __webpack_require__(156); /*
	                                                                * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	                                                                * Bespoke Link to Instruments and Small Satellites (BLISS)
	                                                                *
	                                                                * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	                                                                * RESERVED. United States Government Sponsorship acknowledged. Any
	                                                                * commercial use must be negotiated with the Office of Technology Transfer
	                                                                * at the California Institute of Technology.
	                                                                *
	                                                                * This software may be subject to U.S. export control laws. By accepting
	                                                                * this software, the user agrees to comply with all applicable U.S. export
	                                                                * laws and regulations. User has the responsibility to obtain export licenses,
	                                                                * or other export authority as may be required before exporting such
	                                                                * information to foreign countries or providing access to foreign persons.
	                                                                */

	var Bloodhound = __webpack_require__(157);

	var CommandHistory = {
	    _cmdHistory: null,

	    refreshCommandHistory: function refreshCommandHistory() {
	        var _this = this;

	        m.request({ url: '/cmd/hist.json?detailed=true' }).then(function (dict) {
	            _this._cmdHistory = dict;
	        });
	    },
	    oninit: function oninit(vnode) {
	        var _this2 = this;

	        this.refreshCommandHistory();

	        bliss.events.on('cmd:hist', function () {
	            _this2.refreshCommandHistory();
	        });

	        bliss.events.on('seq:done', function () {
	            _this2.refreshCommandHistory();
	        });
	    },
	    view: function view(vnode) {
	        return m('bliss-commandhistory', m('table', { class: 'table table-striped' }, [m('thead', m('tr', [m('th', 'Timestamp'), m('th', 'Command Sent')])), m('tbody', (0, _map2.default)(this._cmdHistory, function (c) {
	            return m('tr', [m('td', c['timestamp']), m('td', c['command'])]);
	        }))]));
	    }
	};

	var CommandInput = {
	    _cntrl_toggled: false,
	    _cmding_disabled: false,
	    _user_input_timer: null,
	    _cmd_valid: false,
	    _validating: false,
	    _validation_msgs: [],

	    oninit: function oninit(vnode) {
	        var _this3 = this;

	        bliss.cmd.typeahead = { dict: {}, hist: {} };

	        bliss.events.on('cmd:hist', function (cmdname) {
	            bliss.cmd.typeahead.hist.add([cmdname]);
	        });

	        bliss.events.on('seq:exec', function () {
	            _this3._cmding_disabled = true;
	        });

	        bliss.events.on('seq:done', function () {
	            _this3._cmding_disabled = false;
	        });

	        bliss.events.on('seq:err', function () {
	            _this3._cmding_disabled = false;
	        });
	    },
	    oncreate: function oncreate(vnode) {
	        var _this4 = this;

	        bliss.cmd.promise.then(function (dict) {
	            var tokenize = function tokenize(str) {
	                return str ? str.split('_') : [];
	            };

	            bliss.cmd.typeahead.dict = new Bloodhound({
	                datumTokenizer: tokenize,
	                queryTokenizer: tokenize,
	                local: (0, _map2.default)(dict, function (value, key) {
	                    return value.name;
	                })
	            });

	            bliss.cmd.typeahead.hist = new Bloodhound({
	                datumTokenizer: tokenize,
	                queryTokenizer: tokenize,
	                prefetch: { url: '/cmd/hist.json', cache: false }
	            });

	            $('input[name="command"]', vnode.dom).typeahead({
	                highlight: true
	            }, {
	                name: 'cmd-hist',
	                limit: 10,
	                source: bliss.cmd.typeahead.hist,
	                templates: { header: '<h4 class="typeahead-heading">History</h4>' }
	            }, {
	                name: 'cmd-dict',
	                limit: 10,
	                source: bliss.cmd.typeahead.dict,
	                templates: { header: '<h4 class="typeahead-heading">Dictionary</h4>' }
	            }).bind('typeahead:select', function (ev, suggestion) {
	                _this4._typeaheadEventHandler(ev, suggestion);
	            }).bind('typeahead:autocomplete', function (ev, suggestion) {
	                _this4._typeaheadEventHandler(ev, suggestion);
	            }).bind('typeahead:close', function (ev, suggestion) {
	                _this4._typeaheadEventHandler(ev, suggestion);
	            }).bind('typeahead:cursorchange', function (ev, suggestion) {
	                clearTimeout(_this4._user_input_timer);
	                _this4._validating = false;
	                _this4._validation_msgs = [];
	                _this4._cmd_valid = false;
	            });
	        });
	    },
	    view: function view(vnode) {
	        var _this5 = this;

	        var btnText = 'Send';
	        var submitBtnAttrs = { class: 'btn btn-success', type: 'submit' };

	        if (this._cmding_disabled) {
	            submitBtnAttrs['disabled'] = 'disabled';
	        }

	        if (this._validating || !this._cmd_valid) {
	            submitBtnAttrs['class'] = 'btn btn-danger';
	            submitBtnAttrs['disabled'] = 'disabled';

	            if (this._validating) {
	                btnText = m('span', { class: 'glyphicon glyphicon-refresh right-spin' });
	            }
	        }

	        var errorDisplay = '';
	        if (this._validation_msgs.length !== 0) {
	            var errorAttrs = { class: 'alert alert-danger alert-dismissible error_display' };
	            errorDisplay = m('div', errorAttrs, [m('div', [m('button', {
	                type: 'button',
	                class: 'close',
	                'data-dimiss': 'alert',
	                onclick: function onclick() {
	                    _this5._validation_msgs = [];
	                }
	            }, m('span', '\xD7')), m('span', { class: 'glyphicon glyphicon-info-sign' }), m('strong', ' Command Validation Errors')]), (0, _map2.default)(this._validation_msgs, function (msg) {
	                return m('p', msg);
	            })]);
	        }

	        return m('bliss-commandinput', [m('form', {
	            class: 'form-horizontal',
	            role: 'form',
	            method: 'POST',
	            action: '/cmd',
	            onsubmit: function onsubmit(e) {
	                e.preventDefault();
	                var url = e.currentTarget.getAttribute('action');
	                var data = new FormData();
	                data.append('command', e.currentTarget.elements['command'].value);
	                m.request({ method: 'POST', url: url, data: data });
	                $(e.currentTarget.elements['command']).typeahead('val', '').focus();
	            }
	        }, [m('label', 'Send Command:'), m('div', { class: 'input-group' }, [m('input', {
	            class: 'typeahead form-control',
	            type: 'text',
	            name: 'command',
	            placeholder: 'Select Command ...',
	            oninput: function oninput(e) {
	                _this5._cmd_valid = false;
	                _this5._validating = true;
	                _this5._validation_msgs = [];
	                clearTimeout(_this5._user_input_timer);
	                var form = e.target.closest('form');

	                if (form.elements['command'].value !== '') {
	                    _this5._user_input_timer = setTimeout(function () {
	                        _this5._validateCommand(form);
	                    }, 1000);
	                } else {
	                    _this5._validating = false;
	                }
	            },
	            onkeyup: function onkeyup(e) {
	                if (e.keyCode == 17) {
	                    _this5._cntrl_toggled = false;
	                }
	            },
	            onkeydown: function onkeydown(e) {
	                if (e.keyCode == 17) {
	                    _this5._cntrl_toggled = true;
	                }

	                // Cancel submission if
	                //  - Enter was pressed without pressing Ctrl
	                //  - Enter + Ctrl was pressed but the command isn't valid
	                //  - Commanding is currently disabled
	                if (e.keyCode == 13 && !_this5._cntrl_toggled || e.keyCode == 13 && !_this5._cmd_valid || _this5.cmding_disabled) {
	                    e.preventDefault();
	                    return false;
	                }

	                return true;
	            }
	        }), m('span', { class: 'input-group-btn' }, m('button', submitBtnAttrs, btnText))]), m('span', { class: 'help-block' }, 'Ctrl + Enter to send command')]), errorDisplay]);
	    },
	    _typeaheadEventHandler: function _typeaheadEventHandler(ev, suggestion) {
	        var _this6 = this;

	        // We can end up with empty / undefined suggestions depending on the
	        // input value when the input field is blurred. For instance, clicking
	        // in the input box and then outside of it will trigger a typeahead:close
	        // event even though the suggestion box isn't displayed for empty input.
	        if (suggestion === '' || suggestion === undefined) return;

	        var form = ev.target.closest('form');
	        this._cmd_valid = false;
	        this._validating = true;
	        this._validation_msgs = [];

	        clearTimeout(this._user_input_timer);
	        this._user_input_timer = setTimeout(function () {
	            _this6._validateCommand(form);
	        }, 1000);

	        m.redraw();
	    },
	    _validateCommand: function _validateCommand(form) {
	        var _this7 = this;

	        var cmd = form.elements['command'].value;
	        var data = new FormData();
	        data.append('command', cmd);

	        m.request({
	            method: 'POST',
	            url: '/cmd/validate',
	            data: data
	        }).then(function () {
	            _this7._cmd_valid = true;
	            _this7._validating = false;
	        }).catch(function (res) {
	            _this7._cmd_valid = false;
	            _this7._validating = false;
	            _this7._validation_msgs = res.msgs;
	        });
	    }
	};

	var CommandSelectionData = {
	    activeCommand: null
	};

	var CommandSearch = {
	    groupedCommands: {},
	    commandFilter: '',

	    oninit: function oninit(vnode) {
	        var _this8 = this;

	        bliss.cmd.promise.then(function () {
	            _this8.groupedCommands = bliss.cmd.dict.bySubsystem;
	        });
	    },
	    oncreate: function oncreate(vnode) {
	        $(function () {
	            $('[data-toggle="popover"]').popover();
	        });
	    },
	    view: function view(vnode) {
	        var _this9 = this;

	        var cmdAccordions = "";
	        if (Object.keys(this.groupedCommands).length > 0) {
	            var displayCommands = this.groupedCommands;

	            // Filter commands based on user search if necessary
	            if (this.commandFilter.length !== 0) {
	                var filteredCommands = {};
	                (0, _each2.default)(displayCommands, function (value, key) {
	                    filteredCommands[key] = (0, _filter2.default)(value, function (cmd) {
	                        return cmd.name.toLowerCase().includes(_this9.commandFilter.toLowerCase());
	                    });
	                });
	                displayCommands = filteredCommands;
	            }

	            var sortedKeys = Object.keys(displayCommands).sort();
	            cmdAccordions = (0, _map2.default)(sortedKeys, function (k) {
	                var v = displayCommands[k];

	                // if there aren't any commands for this accordion, skip ...
	                if (v.length === 0) {
	                    return [];
	                }

	                v = v.sort(function (a, b) {
	                    if (a.name < b.name) {
	                        return -1;
	                    } else if (b.name < a.name) {
	                        return 1;
	                    } else {
	                        return 0;
	                    }
	                });

	                // Generate the accordion header for the current subsystem key
	                var header = m('a', {
	                    class: 'panel-heading',
	                    role: 'tab',
	                    id: 'heading' + k,
	                    'data-toggle': 'collapse',
	                    'data-target': '#collapse' + k
	                }, m('h4', { class: 'panel-title' }, k));
	                var commandList = (0, _map2.default)(v, function (v) {
	                    return m('li', m('a', {
	                        class: 'btn',
	                        role: 'button',
	                        onmousedown: function onmousedown() {
	                            CommandSelectionData.activeCommand = v;
	                        }
	                    }, v.name));
	                });

	                // Generate the accordion body containing each of the commands
	                var body = m('div', {
	                    class: 'panel-collapse collapse',
	                    role: 'tabpanel',
	                    id: 'collapse' + k
	                }, m('div', { class: 'panel-body' }, m('ul', { class: 'command_list' }, commandList)));
	                return m('div', {
	                    class: 'panel panel-default'
	                }, [header, body]);
	            });
	        }

	        var commandSearchInput = m('input', {
	            class: 'form-control',
	            name: 'command-search',
	            placeholder: 'Search ...',
	            type: 'search',
	            onfocus: function onfocus(e) {
	                $('.panel-collapse').collapse('show');
	            },
	            onkeyup: function onkeyup(e) {
	                _this9.commandFilter = e.currentTarget.value;
	            }
	        });
	        var commandSearchReset = m('div', { class: 'input-group-btn' }, m('button', {
	            class: 'btn btn-default',
	            onmousedown: function onmousedown(e) {
	                e.preventDefault();
	                e.currentTarget.parentElement.parentElement.elements['command-search'].value = '';
	                _this9.commandFilter = '';
	                // This redraw is mandatory. We need to re-render the accordions before we
	                // toggle focus on the input box so that we end up with the accordions
	                // being properly expanded.
	                m.redraw();
	                e.currentTarget.parentElement.parentElement.elements['command-search'].blur();
	                e.currentTarget.parentElement.parentElement.elements['command-search'].focus();
	            }
	        }, m('span', {
	            class: 'glyphicon glyphicon-remove-circle'
	        })));
	        var commandSearchBox = m('form', { class: 'input-group', onsubmit: function onsubmit() {
	                return false;
	            } }, [commandSearchInput, commandSearchReset]);
	        var cmdTree = m('bliss-commandsearch', {
	            onmouseleave: function onmouseleave() {
	                if (CommandSelectionData.activeCommand !== null) {
	                    $('.panel-collapse').collapse('hide');
	                }
	            },
	            onmouseenter: function onmouseenter() {
	                if (CommandSelectionData.activeCommand === null || _this9.commandFilter !== '') {
	                    $('.panel-collapse').collapse('show');
	                }
	            }
	        }, m('div', {
	            class: 'panel-group command_tree',
	            role: 'tablist'
	        }, [commandSearchBox, m('div', {
	            class: 'command_accordions_list'
	        }, cmdAccordions)]));
	        return cmdTree;
	    }
	};

	/**
	 * Handle the configuration of command arguments for the currently select
	 * command (specified via CommandSelectionData.activeCommand)
	 */
	var CommandConfigure = {
	    _cmding_disabled: false,
	    _cmd_valid: false,
	    _validating: false,

	    // We need to keep track of the selected command state for initial command
	    // validation so we can handle commands that are always valid (commands
	    // with no arguments or only enumerated values).
	    _needsInitialValidityCheck: true,
	    _prevActiveCmd: null,

	    oninit: function oninit(vnode) {
	        var _this10 = this;

	        this._display_enum_raw = 'display-enum-raw' in vnode.attrs;

	        bliss.events.on('seq:exec', function () {
	            _this10._cmding_disabled = true;
	        });

	        bliss.events.on('seq:done', function () {
	            _this10._cmding_disabled = false;
	        });

	        bliss.events.on('seq:err', function () {
	            _this10._cmding_disabled = false;
	        });
	    },
	    view: function view(vnode) {
	        if (this._prevActiveCmd !== CommandSelectionData.activeCommand) {
	            this._prevActiveCmd = CommandSelectionData.activeCommand;
	            this._needsInitialValidityCheck = true;
	        }

	        var commandSelection = null;
	        // If a command has been selected, render the command customization screen
	        if (CommandSelectionData.activeCommand !== null) {
	            commandSelection = m('div', [m('div', { class: 'row' }, m('div', { class: 'col-lg-10' }, m('h3', CommandSelectionData.activeCommand.name))), m('div', { class: 'row' }, m('div', { class: 'col-lg-10 col-lg-offset-1' }, m('div', m.trust(CommandSelectionData.activeCommand.desc.replace(/(\r\n|\n|\r)/gm, "<br>"))))), m('div', { class: 'row' }, m('div', { class: 'col-lg-10 col-lg-offset-1' }, m('div', this.generateCommandArgumentsForm(CommandSelectionData.activeCommand))))]);
	            // If no command has been selected, render some help info
	        } else {
	            commandSelection = m('div', { class: 'row' }, m('div', {
	                class: 'col-lg-6 col-lg-offset-3 alert alert-info command_selection_help',
	                role: 'alert'
	            }, [m('span', { class: 'glyphicon glyphicon-info-sign' }), ' Please select a command to configure']));
	        }
	        return m('bliss-commandconfigure', commandSelection);
	    },


	    /**
	     * Generate the argument configuring form for a given command
	     * dictionary object.
	     */
	    generateCommandArgumentsForm: function generateCommandArgumentsForm(command) {
	        var _this11 = this;

	        var argdefns = Object.keys(command.arguments).map(function (k) {
	            return command.arguments[k];
	        }).filter(function (arg) {
	            if (arg.fixed === true) {
	                return false;
	            } else {
	                return true;
	            }
	        });

	        // Argument definitions needs to be sorted in byte order for display
	        argdefns.sort(function (a, b) {
	            var aCmp = void 0,
	                bCmp = null;
	            if (Array.isArray(a.bytes)) {
	                aCmp = a.bytes[0];
	            } else {
	                aCmp = a.bytes;
	            }

	            if (Array.isArray(b.bytes)) {
	                bCmp = b.bytes[0];
	            } else {
	                bCmp = b.bytes;
	            }

	            if (aCmp < bCmp) return -1;else if (bCmp < aCmp) return 1;else return 0;
	        });

	        var cmdArgs = (0, _map2.default)(argdefns, function (arg) {
	            return m('div', { class: 'form-group' }, (0, _flatten2.default)([m('label', { class: 'control-label' }, _this11.prettifyName(arg.name)), _this11.generateArgumentInput(arg)]));
	        });

	        // Run an initial validity check for the current command to make sure that
	        // we don't require validation for commands that are always
	        // going to be valid (Specifically, commands with no arguments or only
	        // enumerated values). If we don't do an initial check for these commands
	        // they'll never enter into a state where they're marked as valid / sent
	        // by the user.
	        if (this._needsInitialValidityCheck) {
	            this._needsInitialValidityCheck = false;
	            this._cmd_valid = true;

	            var _iteratorNormalCompletion = true;
	            var _didIteratorError = false;
	            var _iteratorError = undefined;

	            try {
	                for (var _iterator = cmdArgs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                    var arg = _step.value;
	                    var _iteratorNormalCompletion2 = true;
	                    var _didIteratorError2 = false;
	                    var _iteratorError2 = undefined;

	                    try {
	                        for (var _iterator2 = arg.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                            var child = _step2.value;

	                            if (child.tag === 'input') {
	                                this._cmd_valid = false;
	                                break;
	                            }
	                        }
	                    } catch (err) {
	                        _didIteratorError2 = true;
	                        _iteratorError2 = err;
	                    } finally {
	                        try {
	                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                                _iterator2.return();
	                            }
	                        } finally {
	                            if (_didIteratorError2) {
	                                throw _iteratorError2;
	                            }
	                        }
	                    }
	                }
	            } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion && _iterator.return) {
	                        _iterator.return();
	                    }
	                } finally {
	                    if (_didIteratorError) {
	                        throw _iteratorError;
	                    }
	                }
	            }
	        }

	        var submitBtnAttrs = { class: 'btn btn-success', type: 'submit' };
	        var btnText = "Send Command";

	        if (this._cmding_disabled) {
	            submitBtnAttrs['disabled'] = 'disabled';
	        }

	        if (this._validating || !this._cmd_valid) {
	            submitBtnAttrs['class'] = 'btn btn-danger';
	            submitBtnAttrs['disabled'] = 'disabled';

	            if (this._validating) {
	                btnText = m('span', ['Validating ', m('span', { class: 'glyphicon glyphicon-refresh right-spin' })]);
	            }
	        }

	        return m('form', {
	            class: 'command_customization_form',
	            onchange: this.handleCommandFormValidation.bind(this),
	            onsubmit: this.handleCommandFormSubmission.bind(this),
	            method: 'POST',
	            action: '/cmd',
	            novalidate: ''
	        }, [m('input', {
	            name: 'command-arg-name',
	            type: 'hidden',
	            value: CommandSelectionData.activeCommand.name
	        }), cmdArgs, m('button', submitBtnAttrs, btnText)]);
	    },


	    /**
	     *
	     */
	    prettifyName: function prettifyName(name) {
	        var name_parts = name.split('_');
	        name_parts = (0, _map2.default)(name_parts, function (v) {
	            return v.charAt(0).toUpperCase() + v.slice(1);
	        });
	        return name_parts.join(' ');
	    },


	    /**
	     * Generate the argument input field for a given command's argument object.
	     */
	    generateArgumentInput: function generateArgumentInput(argument) {
	        var _this12 = this;

	        var argInput = null;
	        if ('enum' in argument) {
	            argInput = m('select', { class: 'form-control' }, (0, _map2.default)(argument.enum, function (v, k) {
	                return _this12._display_enum_raw ? m('option', { value: k }, k + ' (' + v + ')') : m('option', { value: k }, k);
	            }));
	        } else {
	            argInput = m('input', {
	                class: 'form-control',
	                oninput: function oninput(e) {
	                    var event = new Event('change', { bubbles: true });
	                    e.target.dispatchEvent(event);
	                }
	            });
	        }

	        if ('units' in argument && argument.units !== 'none') {
	            return m('div', { class: 'input-group' }, [argInput, m('div', { class: 'input-group-addon' }, argument.units)]);
	        } else {
	            return argInput;
	        }
	    },
	    validateCommand: function validateCommand(cmd) {
	        var _this13 = this;

	        var data = new FormData();
	        data.append('command', cmd);
	        this._validating = true;
	        clearTimeout(this._validation_timer);
	        this._validation_timer = setTimeout(function () {
	            m.request({
	                method: 'POST',
	                url: '/cmd/validate',
	                data: data,
	                extract: function extract(xhr) {}
	            }).then(function () {
	                _this13._cmd_valid = true;
	                _this13._validating = false;
	            }).catch(function () {
	                _this13._cmd_valid = false;
	                _this13._validating = false;
	            });
	        }, 500);
	    },
	    buildCommand: function buildCommand(form) {
	        var command = form.elements['command-arg-name'].value;

	        $(':input', form).each(function (index, input) {
	            if (!$(input).hasClass('form-control')) return;
	            command += ' ' + $(input).val();
	        });

	        return command;
	    },


	    /*
	     *
	     */
	    handleCommandFormValidation: function handleCommandFormValidation(e) {
	        var shouldRunValidation = true;

	        if (!this._validating) {
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;

	            try {
	                for (var _iterator3 = e.currentTarget.elements[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                    var elem = _step3.value;

	                    if (elem.getAttribute('type') === 'hidden' || elem.getAttribute('type') === 'submit') {
	                        continue;
	                    }

	                    if (elem.value === '') {
	                        shouldRunValidation = false;
	                        this._cmd_valid = false;
	                        break;
	                    }
	                }
	            } catch (err) {
	                _didIteratorError3 = true;
	                _iteratorError3 = err;
	            } finally {
	                try {
	                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                        _iterator3.return();
	                    }
	                } finally {
	                    if (_didIteratorError3) {
	                        throw _iteratorError3;
	                    }
	                }
	            }
	        }

	        if (shouldRunValidation) {
	            this.validateCommand(this.buildCommand(e.currentTarget));
	        }
	    },


	    /*
	     * Handles construction of the command and submission to the backend
	     */
	    handleCommandFormSubmission: function handleCommandFormSubmission(e) {
	        e.preventDefault();

	        var url = e.currentTarget.action;
	        var command = this.buildCommand(e.currentTarget);

	        // Note: FormData resoles issues with m.request passing data to the
	        // backend in a form that the existing /cmd endpoint doesn't like.
	        var data = new FormData();
	        data.append('command', command);
	        m.request({ method: 'POST', url: url, data: data });

	        CommandSelectionData.activeCommand = null;
	        bliss.events.emit('cmd:submit', {});
	    }
	};

	exports.default = { CommandHistory: CommandHistory, CommandInput: CommandInput, CommandSearch: CommandSearch, CommandConfigure: CommandConfigure };
	exports.CommandHistory = CommandHistory;
	exports.CommandInput = CommandInput;
	exports.CommandSearch = CommandSearch;
	exports.CommandConfigure = CommandConfigure;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.2.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2017-03-20T18:59Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};



		function DOMEval( code, doc ) {
			doc = doc || document;

			var script = doc.createElement( "script" );

			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.2.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&

				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Simple selector that can be filtered directly, removing non-Elements
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter( qualifier, elements );
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( ">tbody", elem )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i,
			val = 0;

		// If we already have the right measurement, avoid augmentation
		if ( extra === ( isBorderBox ? "border" : "content" ) ) {
			i = 4;

		// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with computed style
		var valueIsBorderBox,
			styles = getStyles( elem ),
			val = curCSS( elem, name, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Fall back to offsetWidth/Height when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		if ( val === "auto" ) {
			val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
		}

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnothtmlwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var doc, docElem, rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			rect = elem.getBoundingClientRect();

			doc = elem.ownerDocument;
			docElem = doc.documentElement;
			win = doc.defaultView;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( jQuery.isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(18);


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayEach = __webpack_require__(19),
	    baseEach = __webpack_require__(20),
	    castFunction = __webpack_require__(53),
	    isArray = __webpack_require__(36);

	/**
	 * Iterates over elements of `collection` and invokes `iteratee` for each element.
	 * The iteratee is invoked with three arguments: (value, index|key, collection).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length"
	 * property are iterated like arrays. To avoid this behavior use `_.forIn`
	 * or `_.forOwn` for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @alias each
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 * @see _.forEachRight
	 * @example
	 *
	 * _.forEach([1, 2], function(value) {
	 *   console.log(value);
	 * });
	 * // => Logs `1` then `2`.
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	 */
	function forEach(collection, iteratee) {
	  var func = isArray(collection) ? arrayEach : baseEach;
	  return func(collection, castFunction(iteratee));
	}

	module.exports = forEach;


/***/ }),
/* 19 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	module.exports = arrayEach;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(21),
	    createBaseEach = __webpack_require__(52);

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	module.exports = baseEach;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(22),
	    keys = __webpack_require__(24);

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	module.exports = baseForOwn;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(23);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(25),
	    baseKeys = __webpack_require__(45),
	    isArrayLike = __webpack_require__(49);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = keys;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(26),
	    isArguments = __webpack_require__(27),
	    isArray = __webpack_require__(36),
	    isBuffer = __webpack_require__(37),
	    isIndex = __webpack_require__(39),
	    isTypedArray = __webpack_require__(40);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(28),
	    isObjectLike = __webpack_require__(35);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(29),
	    isObjectLike = __webpack_require__(35);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(30),
	    getRawTag = __webpack_require__(33),
	    objectToString = __webpack_require__(34);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(31);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(32);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(30);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ }),
/* 35 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ }),
/* 36 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(31),
	    stubFalse = __webpack_require__(38);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module)))

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 39 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsTypedArray = __webpack_require__(41),
	    baseUnary = __webpack_require__(43),
	    nodeUtil = __webpack_require__(44);

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	module.exports = isTypedArray;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(29),
	    isLength = __webpack_require__(42),
	    isObjectLike = __webpack_require__(35);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	module.exports = baseIsTypedArray;


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ }),
/* 43 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(32);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(46),
	    nativeKeys = __webpack_require__(47);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeys;


/***/ }),
/* 46 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(48);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ }),
/* 48 */
/***/ (function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(50),
	    isLength = __webpack_require__(42);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(29),
	    isObject = __webpack_require__(51);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ }),
/* 51 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(49);

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	module.exports = createBaseEach;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(54);

	/**
	 * Casts `value` to `identity` if it's not a function.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Function} Returns cast function.
	 */
	function castFunction(value) {
	  return typeof value == 'function' ? value : identity;
	}

	module.exports = castFunction;


/***/ }),
/* 54 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(56),
	    baseFilter = __webpack_require__(57),
	    baseIteratee = __webpack_require__(58),
	    isArray = __webpack_require__(36);

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * **Note:** Unlike `_.remove`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.reject
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * _.filter(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, { 'age': 36, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.filter(users, 'active');
	 * // => objects for ['barney']
	 */
	function filter(collection, predicate) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  return func(collection, baseIteratee(predicate, 3));
	}

	module.exports = filter;


/***/ }),
/* 56 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(20);

	/**
	 * The base implementation of `_.filter` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}

	module.exports = baseFilter;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(59),
	    baseMatchesProperty = __webpack_require__(123),
	    identity = __webpack_require__(54),
	    isArray = __webpack_require__(36),
	    property = __webpack_require__(139);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(60),
	    getMatchData = __webpack_require__(120),
	    matchesStrictComparable = __webpack_require__(122);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(61),
	    baseIsEqual = __webpack_require__(97);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(62),
	    stackClear = __webpack_require__(70),
	    stackDelete = __webpack_require__(71),
	    stackGet = __webpack_require__(72),
	    stackHas = __webpack_require__(73),
	    stackSet = __webpack_require__(74);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(63),
	    listCacheDelete = __webpack_require__(64),
	    listCacheGet = __webpack_require__(67),
	    listCacheHas = __webpack_require__(68),
	    listCacheSet = __webpack_require__(69);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ }),
/* 63 */
/***/ (function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(65);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(66);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ }),
/* 66 */
/***/ (function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(65);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(65);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(65);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(62);

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	module.exports = stackClear;


/***/ }),
/* 71 */
/***/ (function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	module.exports = stackDelete;


/***/ }),
/* 72 */
/***/ (function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	module.exports = stackGet;


/***/ }),
/* 73 */
/***/ (function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	module.exports = stackHas;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(62),
	    Map = __webpack_require__(75),
	    MapCache = __webpack_require__(82);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	module.exports = stackSet;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(76),
	    root = __webpack_require__(31);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsNative = __webpack_require__(77),
	    getValue = __webpack_require__(81);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(50),
	    isMasked = __webpack_require__(78),
	    isObject = __webpack_require__(51),
	    toSource = __webpack_require__(80);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var coreJsData = __webpack_require__(79);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(31);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ }),
/* 80 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ }),
/* 81 */
/***/ (function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	var mapCacheClear = __webpack_require__(83),
	    mapCacheDelete = __webpack_require__(91),
	    mapCacheGet = __webpack_require__(94),
	    mapCacheHas = __webpack_require__(95),
	    mapCacheSet = __webpack_require__(96);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var Hash = __webpack_require__(84),
	    ListCache = __webpack_require__(62),
	    Map = __webpack_require__(75);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	var hashClear = __webpack_require__(85),
	    hashDelete = __webpack_require__(87),
	    hashGet = __webpack_require__(88),
	    hashHas = __webpack_require__(89),
	    hashSet = __webpack_require__(90);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(86);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(76);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ }),
/* 87 */
/***/ (function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(86);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(86);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	var nativeCreate = __webpack_require__(86);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(92);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	var isKeyable = __webpack_require__(93);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ }),
/* 93 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(92);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(92);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	var getMapData = __webpack_require__(92);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(98),
	    isObjectLike = __webpack_require__(35);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	module.exports = baseIsEqual;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(61),
	    equalArrays = __webpack_require__(99),
	    equalByTag = __webpack_require__(105),
	    equalObjects = __webpack_require__(109),
	    getTag = __webpack_require__(115),
	    isArray = __webpack_require__(36),
	    isBuffer = __webpack_require__(37),
	    isTypedArray = __webpack_require__(40);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(100),
	    arraySome = __webpack_require__(103),
	    cacheHas = __webpack_require__(104);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(82),
	    setCacheAdd = __webpack_require__(101),
	    setCacheHas = __webpack_require__(102);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ }),
/* 101 */
/***/ (function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ }),
/* 104 */
/***/ (function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(30),
	    Uint8Array = __webpack_require__(106),
	    eq = __webpack_require__(66),
	    equalArrays = __webpack_require__(99),
	    mapToArray = __webpack_require__(107),
	    setToArray = __webpack_require__(108);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(31);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ }),
/* 107 */
/***/ (function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	module.exports = mapToArray;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	var getAllKeys = __webpack_require__(110);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetAllKeys = __webpack_require__(111),
	    getSymbols = __webpack_require__(113),
	    keys = __webpack_require__(24);

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	module.exports = getAllKeys;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(112),
	    isArray = __webpack_require__(36);

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	module.exports = baseGetAllKeys;


/***/ }),
/* 112 */
/***/ (function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(56),
	    stubArray = __webpack_require__(114);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	module.exports = getSymbols;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(116),
	    Map = __webpack_require__(75),
	    Promise = __webpack_require__(117),
	    Set = __webpack_require__(118),
	    WeakMap = __webpack_require__(119),
	    baseGetTag = __webpack_require__(29),
	    toSource = __webpack_require__(80);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	module.exports = getTag;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(76),
	    root = __webpack_require__(31);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	module.exports = DataView;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(76),
	    root = __webpack_require__(31);

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	module.exports = Promise;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(76),
	    root = __webpack_require__(31);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(76),
	    root = __webpack_require__(31);

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	module.exports = WeakMap;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(121),
	    keys = __webpack_require__(24);

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	module.exports = getMatchData;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(51);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	module.exports = isStrictComparable;


/***/ }),
/* 122 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	module.exports = matchesStrictComparable;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(97),
	    get = __webpack_require__(124),
	    hasIn = __webpack_require__(136),
	    isKey = __webpack_require__(127),
	    isStrictComparable = __webpack_require__(121),
	    matchesStrictComparable = __webpack_require__(122),
	    toKey = __webpack_require__(135);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(125);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(126),
	    toKey = __webpack_require__(135);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(36),
	    isKey = __webpack_require__(127),
	    stringToPath = __webpack_require__(129),
	    toString = __webpack_require__(132);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	module.exports = castPath;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(36),
	    isSymbol = __webpack_require__(128);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(29),
	    isObjectLike = __webpack_require__(35);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(130);

	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(131);

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	module.exports = memoizeCapped;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	var MapCache = __webpack_require__(82);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(133);

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	module.exports = toString;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(30),
	    arrayMap = __webpack_require__(134),
	    isArray = __webpack_require__(36),
	    isSymbol = __webpack_require__(128);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = baseToString;


/***/ }),
/* 134 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(128);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toKey;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(137),
	    hasPath = __webpack_require__(138);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ }),
/* 137 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	module.exports = baseHasIn;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(126),
	    isArguments = __webpack_require__(27),
	    isArray = __webpack_require__(36),
	    isIndex = __webpack_require__(39),
	    isLength = __webpack_require__(42),
	    toKey = __webpack_require__(135);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(140),
	    basePropertyDeep = __webpack_require__(141),
	    isKey = __webpack_require__(127),
	    toKey = __webpack_require__(135);

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = property;


/***/ }),
/* 140 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(125);

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	module.exports = basePropertyDeep;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(143);

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	module.exports = flatten;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(112),
	    isFlattenable = __webpack_require__(144);

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	module.exports = baseFlatten;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(30),
	    isArguments = __webpack_require__(27),
	    isArray = __webpack_require__(36);

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	module.exports = isFlattenable;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(143),
	    map = __webpack_require__(146);

	/**
	 * Creates a flattened array of values by running each element in `collection`
	 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	 * with three arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * function duplicate(n) {
	 *   return [n, n];
	 * }
	 *
	 * _.flatMap([1, 2], duplicate);
	 * // => [1, 1, 2, 2]
	 */
	function flatMap(collection, iteratee) {
	  return baseFlatten(map(collection, iteratee), 1);
	}

	module.exports = flatMap;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(134),
	    baseIteratee = __webpack_require__(58),
	    baseMap = __webpack_require__(147),
	    isArray = __webpack_require__(36);

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee, 3));
	}

	module.exports = map;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(20),
	    isArrayLike = __webpack_require__(49);

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	module.exports = baseMap;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(149),
	    createAggregator = __webpack_require__(151);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an object composed of keys generated from the results of running
	 * each element of `collection` thru `iteratee`. The order of grouped values
	 * is determined by the order they occur in `collection`. The corresponding
	 * value of each key is an array of elements responsible for generating the
	 * key. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	 * @returns {Object} Returns the composed aggregate object.
	 * @example
	 *
	 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	 * // => { '4': [4.2], '6': [6.1, 6.3] }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.groupBy(['one', 'two', 'three'], 'length');
	 * // => { '3': ['one', 'two'], '5': ['three'] }
	 */
	var groupBy = createAggregator(function(result, value, key) {
	  if (hasOwnProperty.call(result, key)) {
	    result[key].push(value);
	  } else {
	    baseAssignValue(result, key, [value]);
	  }
	});

	module.exports = groupBy;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(150);

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(76);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayAggregator = __webpack_require__(152),
	    baseAggregator = __webpack_require__(153),
	    baseIteratee = __webpack_require__(58),
	    isArray = __webpack_require__(36);

	/**
	 * Creates a function like `_.groupBy`.
	 *
	 * @private
	 * @param {Function} setter The function to set accumulator values.
	 * @param {Function} [initializer] The accumulator object initializer.
	 * @returns {Function} Returns the new aggregator function.
	 */
	function createAggregator(setter, initializer) {
	  return function(collection, iteratee) {
	    var func = isArray(collection) ? arrayAggregator : baseAggregator,
	        accumulator = initializer ? initializer() : {};

	    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
	  };
	}

	module.exports = createAggregator;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `baseAggregator` for arrays.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function arrayAggregator(array, setter, iteratee, accumulator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    var value = array[index];
	    setter(accumulator, value, iteratee(value), array);
	  }
	  return accumulator;
	}

	module.exports = arrayAggregator;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(20);

	/**
	 * Aggregates elements of `collection` on `accumulator` with keys transformed
	 * by `iteratee` and values set by `setter`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function baseAggregator(collection, setter, iteratee, accumulator) {
	  baseEach(collection, function(value, key, collection) {
	    setter(accumulator, value, iteratee(value), collection);
	  });
	  return accumulator;
	}

	module.exports = baseAggregator;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	var baseValues = __webpack_require__(155),
	    keys = __webpack_require__(24);

	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return object == null ? [] : baseValues(object, keys(object));
	}

	module.exports = values;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(134);

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}

	module.exports = baseValues;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
	 * typeahead.js 0.11.1
	 * https://github.com/twitter/typeahead.js
	 * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
	 */

	(function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(16) ], __WEBPACK_AMD_DEFINE_RESULT__ = function(a0) {
	            return factory(a0);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === "object") {
	        module.exports = factory(require("jquery"));
	    } else {
	        factory(jQuery);
	    }
	})(this, function($) {
	    var _ = function() {
	        "use strict";
	        return {
	            isMsie: function() {
	                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
	            },
	            isBlankString: function(str) {
	                return !str || /^\s*$/.test(str);
	            },
	            escapeRegExChars: function(str) {
	                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	            },
	            isString: function(obj) {
	                return typeof obj === "string";
	            },
	            isNumber: function(obj) {
	                return typeof obj === "number";
	            },
	            isArray: $.isArray,
	            isFunction: $.isFunction,
	            isObject: $.isPlainObject,
	            isUndefined: function(obj) {
	                return typeof obj === "undefined";
	            },
	            isElement: function(obj) {
	                return !!(obj && obj.nodeType === 1);
	            },
	            isJQuery: function(obj) {
	                return obj instanceof $;
	            },
	            toStr: function toStr(s) {
	                return _.isUndefined(s) || s === null ? "" : s + "";
	            },
	            bind: $.proxy,
	            each: function(collection, cb) {
	                $.each(collection, reverseArgs);
	                function reverseArgs(index, value) {
	                    return cb(value, index);
	                }
	            },
	            map: $.map,
	            filter: $.grep,
	            every: function(obj, test) {
	                var result = true;
	                if (!obj) {
	                    return result;
	                }
	                $.each(obj, function(key, val) {
	                    if (!(result = test.call(null, val, key, obj))) {
	                        return false;
	                    }
	                });
	                return !!result;
	            },
	            some: function(obj, test) {
	                var result = false;
	                if (!obj) {
	                    return result;
	                }
	                $.each(obj, function(key, val) {
	                    if (result = test.call(null, val, key, obj)) {
	                        return false;
	                    }
	                });
	                return !!result;
	            },
	            mixin: $.extend,
	            identity: function(x) {
	                return x;
	            },
	            clone: function(obj) {
	                return $.extend(true, {}, obj);
	            },
	            getIdGenerator: function() {
	                var counter = 0;
	                return function() {
	                    return counter++;
	                };
	            },
	            templatify: function templatify(obj) {
	                return $.isFunction(obj) ? obj : template;
	                function template() {
	                    return String(obj);
	                }
	            },
	            defer: function(fn) {
	                setTimeout(fn, 0);
	            },
	            debounce: function(func, wait, immediate) {
	                var timeout, result;
	                return function() {
	                    var context = this, args = arguments, later, callNow;
	                    later = function() {
	                        timeout = null;
	                        if (!immediate) {
	                            result = func.apply(context, args);
	                        }
	                    };
	                    callNow = immediate && !timeout;
	                    clearTimeout(timeout);
	                    timeout = setTimeout(later, wait);
	                    if (callNow) {
	                        result = func.apply(context, args);
	                    }
	                    return result;
	                };
	            },
	            throttle: function(func, wait) {
	                var context, args, timeout, result, previous, later;
	                previous = 0;
	                later = function() {
	                    previous = new Date();
	                    timeout = null;
	                    result = func.apply(context, args);
	                };
	                return function() {
	                    var now = new Date(), remaining = wait - (now - previous);
	                    context = this;
	                    args = arguments;
	                    if (remaining <= 0) {
	                        clearTimeout(timeout);
	                        timeout = null;
	                        previous = now;
	                        result = func.apply(context, args);
	                    } else if (!timeout) {
	                        timeout = setTimeout(later, remaining);
	                    }
	                    return result;
	                };
	            },
	            stringify: function(val) {
	                return _.isString(val) ? val : JSON.stringify(val);
	            },
	            noop: function() {}
	        };
	    }();
	    var WWW = function() {
	        "use strict";
	        var defaultClassNames = {
	            wrapper: "twitter-typeahead",
	            input: "tt-input",
	            hint: "tt-hint",
	            menu: "tt-menu",
	            dataset: "tt-dataset",
	            suggestion: "tt-suggestion",
	            selectable: "tt-selectable",
	            empty: "tt-empty",
	            open: "tt-open",
	            cursor: "tt-cursor",
	            highlight: "tt-highlight"
	        };
	        return build;
	        function build(o) {
	            var www, classes;
	            classes = _.mixin({}, defaultClassNames, o);
	            www = {
	                css: buildCss(),
	                classes: classes,
	                html: buildHtml(classes),
	                selectors: buildSelectors(classes)
	            };
	            return {
	                css: www.css,
	                html: www.html,
	                classes: www.classes,
	                selectors: www.selectors,
	                mixin: function(o) {
	                    _.mixin(o, www);
	                }
	            };
	        }
	        function buildHtml(c) {
	            return {
	                wrapper: '<span class="' + c.wrapper + '"></span>',
	                menu: '<div class="' + c.menu + '"></div>'
	            };
	        }
	        function buildSelectors(classes) {
	            var selectors = {};
	            _.each(classes, function(v, k) {
	                selectors[k] = "." + v;
	            });
	            return selectors;
	        }
	        function buildCss() {
	            var css = {
	                wrapper: {
	                    position: "relative",
	                    display: "inline-block"
	                },
	                hint: {
	                    position: "absolute",
	                    top: "0",
	                    left: "0",
	                    borderColor: "transparent",
	                    boxShadow: "none",
	                    opacity: "1"
	                },
	                input: {
	                    position: "relative",
	                    verticalAlign: "top",
	                    backgroundColor: "transparent"
	                },
	                inputWithNoHint: {
	                    position: "relative",
	                    verticalAlign: "top"
	                },
	                menu: {
	                    position: "absolute",
	                    top: "100%",
	                    left: "0",
	                    zIndex: "100",
	                    display: "none"
	                },
	                ltr: {
	                    left: "0",
	                    right: "auto"
	                },
	                rtl: {
	                    left: "auto",
	                    right: " 0"
	                }
	            };
	            if (_.isMsie()) {
	                _.mixin(css.input, {
	                    backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
	                });
	            }
	            return css;
	        }
	    }();
	    var EventBus = function() {
	        "use strict";
	        var namespace, deprecationMap;
	        namespace = "typeahead:";
	        deprecationMap = {
	            render: "rendered",
	            cursorchange: "cursorchanged",
	            select: "selected",
	            autocomplete: "autocompleted"
	        };
	        function EventBus(o) {
	            if (!o || !o.el) {
	                $.error("EventBus initialized without el");
	            }
	            this.$el = $(o.el);
	        }
	        _.mixin(EventBus.prototype, {
	            _trigger: function(type, args) {
	                var $e;
	                $e = $.Event(namespace + type);
	                (args = args || []).unshift($e);
	                this.$el.trigger.apply(this.$el, args);
	                return $e;
	            },
	            before: function(type) {
	                var args, $e;
	                args = [].slice.call(arguments, 1);
	                $e = this._trigger("before" + type, args);
	                return $e.isDefaultPrevented();
	            },
	            trigger: function(type) {
	                var deprecatedType;
	                this._trigger(type, [].slice.call(arguments, 1));
	                if (deprecatedType = deprecationMap[type]) {
	                    this._trigger(deprecatedType, [].slice.call(arguments, 1));
	                }
	            }
	        });
	        return EventBus;
	    }();
	    var EventEmitter = function() {
	        "use strict";
	        var splitter = /\s+/, nextTick = getNextTick();
	        return {
	            onSync: onSync,
	            onAsync: onAsync,
	            off: off,
	            trigger: trigger
	        };
	        function on(method, types, cb, context) {
	            var type;
	            if (!cb) {
	                return this;
	            }
	            types = types.split(splitter);
	            cb = context ? bindContext(cb, context) : cb;
	            this._callbacks = this._callbacks || {};
	            while (type = types.shift()) {
	                this._callbacks[type] = this._callbacks[type] || {
	                    sync: [],
	                    async: []
	                };
	                this._callbacks[type][method].push(cb);
	            }
	            return this;
	        }
	        function onAsync(types, cb, context) {
	            return on.call(this, "async", types, cb, context);
	        }
	        function onSync(types, cb, context) {
	            return on.call(this, "sync", types, cb, context);
	        }
	        function off(types) {
	            var type;
	            if (!this._callbacks) {
	                return this;
	            }
	            types = types.split(splitter);
	            while (type = types.shift()) {
	                delete this._callbacks[type];
	            }
	            return this;
	        }
	        function trigger(types) {
	            var type, callbacks, args, syncFlush, asyncFlush;
	            if (!this._callbacks) {
	                return this;
	            }
	            types = types.split(splitter);
	            args = [].slice.call(arguments, 1);
	            while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
	                syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args));
	                asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args));
	                syncFlush() && nextTick(asyncFlush);
	            }
	            return this;
	        }
	        function getFlush(callbacks, context, args) {
	            return flush;
	            function flush() {
	                var cancelled;
	                for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
	                    cancelled = callbacks[i].apply(context, args) === false;
	                }
	                return !cancelled;
	            }
	        }
	        function getNextTick() {
	            var nextTickFn;
	            if (window.setImmediate) {
	                nextTickFn = function nextTickSetImmediate(fn) {
	                    setImmediate(function() {
	                        fn();
	                    });
	                };
	            } else {
	                nextTickFn = function nextTickSetTimeout(fn) {
	                    setTimeout(function() {
	                        fn();
	                    }, 0);
	                };
	            }
	            return nextTickFn;
	        }
	        function bindContext(fn, context) {
	            return fn.bind ? fn.bind(context) : function() {
	                fn.apply(context, [].slice.call(arguments, 0));
	            };
	        }
	    }();
	    var highlight = function(doc) {
	        "use strict";
	        var defaults = {
	            node: null,
	            pattern: null,
	            tagName: "strong",
	            className: null,
	            wordsOnly: false,
	            caseSensitive: false
	        };
	        return function hightlight(o) {
	            var regex;
	            o = _.mixin({}, defaults, o);
	            if (!o.node || !o.pattern) {
	                return;
	            }
	            o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];
	            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
	            traverse(o.node, hightlightTextNode);
	            function hightlightTextNode(textNode) {
	                var match, patternNode, wrapperNode;
	                if (match = regex.exec(textNode.data)) {
	                    wrapperNode = doc.createElement(o.tagName);
	                    o.className && (wrapperNode.className = o.className);
	                    patternNode = textNode.splitText(match.index);
	                    patternNode.splitText(match[0].length);
	                    wrapperNode.appendChild(patternNode.cloneNode(true));
	                    textNode.parentNode.replaceChild(wrapperNode, patternNode);
	                }
	                return !!match;
	            }
	            function traverse(el, hightlightTextNode) {
	                var childNode, TEXT_NODE_TYPE = 3;
	                for (var i = 0; i < el.childNodes.length; i++) {
	                    childNode = el.childNodes[i];
	                    if (childNode.nodeType === TEXT_NODE_TYPE) {
	                        i += hightlightTextNode(childNode) ? 1 : 0;
	                    } else {
	                        traverse(childNode, hightlightTextNode);
	                    }
	                }
	            }
	        };
	        function getRegex(patterns, caseSensitive, wordsOnly) {
	            var escapedPatterns = [], regexStr;
	            for (var i = 0, len = patterns.length; i < len; i++) {
	                escapedPatterns.push(_.escapeRegExChars(patterns[i]));
	            }
	            regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
	            return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
	        }
	    }(window.document);
	    var Input = function() {
	        "use strict";
	        var specialKeyCodeMap;
	        specialKeyCodeMap = {
	            9: "tab",
	            27: "esc",
	            37: "left",
	            39: "right",
	            13: "enter",
	            38: "up",
	            40: "down"
	        };
	        function Input(o, www) {
	            o = o || {};
	            if (!o.input) {
	                $.error("input is missing");
	            }
	            www.mixin(this);
	            this.$hint = $(o.hint);
	            this.$input = $(o.input);
	            this.query = this.$input.val();
	            this.queryWhenFocused = this.hasFocus() ? this.query : null;
	            this.$overflowHelper = buildOverflowHelper(this.$input);
	            this._checkLanguageDirection();
	            if (this.$hint.length === 0) {
	                this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
	            }
	        }
	        Input.normalizeQuery = function(str) {
	            return _.toStr(str).replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
	        };
	        _.mixin(Input.prototype, EventEmitter, {
	            _onBlur: function onBlur() {
	                this.resetInputValue();
	                this.trigger("blurred");
	            },
	            _onFocus: function onFocus() {
	                this.queryWhenFocused = this.query;
	                this.trigger("focused");
	            },
	            _onKeydown: function onKeydown($e) {
	                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
	                this._managePreventDefault(keyName, $e);
	                if (keyName && this._shouldTrigger(keyName, $e)) {
	                    this.trigger(keyName + "Keyed", $e);
	                }
	            },
	            _onInput: function onInput() {
	                this._setQuery(this.getInputValue());
	                this.clearHintIfInvalid();
	                this._checkLanguageDirection();
	            },
	            _managePreventDefault: function managePreventDefault(keyName, $e) {
	                var preventDefault;
	                switch (keyName) {
	                  case "up":
	                  case "down":
	                    preventDefault = !withModifier($e);
	                    break;

	                  default:
	                    preventDefault = false;
	                }
	                preventDefault && $e.preventDefault();
	            },
	            _shouldTrigger: function shouldTrigger(keyName, $e) {
	                var trigger;
	                switch (keyName) {
	                  case "tab":
	                    trigger = !withModifier($e);
	                    break;

	                  default:
	                    trigger = true;
	                }
	                return trigger;
	            },
	            _checkLanguageDirection: function checkLanguageDirection() {
	                var dir = (this.$input.css("direction") || "ltr").toLowerCase();
	                if (this.dir !== dir) {
	                    this.dir = dir;
	                    this.$hint.attr("dir", dir);
	                    this.trigger("langDirChanged", dir);
	                }
	            },
	            _setQuery: function setQuery(val, silent) {
	                var areEquivalent, hasDifferentWhitespace;
	                areEquivalent = areQueriesEquivalent(val, this.query);
	                hasDifferentWhitespace = areEquivalent ? this.query.length !== val.length : false;
	                this.query = val;
	                if (!silent && !areEquivalent) {
	                    this.trigger("queryChanged", this.query);
	                } else if (!silent && hasDifferentWhitespace) {
	                    this.trigger("whitespaceChanged", this.query);
	                }
	            },
	            bind: function() {
	                var that = this, onBlur, onFocus, onKeydown, onInput;
	                onBlur = _.bind(this._onBlur, this);
	                onFocus = _.bind(this._onFocus, this);
	                onKeydown = _.bind(this._onKeydown, this);
	                onInput = _.bind(this._onInput, this);
	                this.$input.on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
	                if (!_.isMsie() || _.isMsie() > 9) {
	                    this.$input.on("input.tt", onInput);
	                } else {
	                    this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
	                        if (specialKeyCodeMap[$e.which || $e.keyCode]) {
	                            return;
	                        }
	                        _.defer(_.bind(that._onInput, that, $e));
	                    });
	                }
	                return this;
	            },
	            focus: function focus() {
	                this.$input.focus();
	            },
	            blur: function blur() {
	                this.$input.blur();
	            },
	            getLangDir: function getLangDir() {
	                return this.dir;
	            },
	            getQuery: function getQuery() {
	                return this.query || "";
	            },
	            setQuery: function setQuery(val, silent) {
	                this.setInputValue(val);
	                this._setQuery(val, silent);
	            },
	            hasQueryChangedSinceLastFocus: function hasQueryChangedSinceLastFocus() {
	                return this.query !== this.queryWhenFocused;
	            },
	            getInputValue: function getInputValue() {
	                return this.$input.val();
	            },
	            setInputValue: function setInputValue(value) {
	                this.$input.val(value);
	                this.clearHintIfInvalid();
	                this._checkLanguageDirection();
	            },
	            resetInputValue: function resetInputValue() {
	                this.setInputValue(this.query);
	            },
	            getHint: function getHint() {
	                return this.$hint.val();
	            },
	            setHint: function setHint(value) {
	                this.$hint.val(value);
	            },
	            clearHint: function clearHint() {
	                this.setHint("");
	            },
	            clearHintIfInvalid: function clearHintIfInvalid() {
	                var val, hint, valIsPrefixOfHint, isValid;
	                val = this.getInputValue();
	                hint = this.getHint();
	                valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
	                isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
	                !isValid && this.clearHint();
	            },
	            hasFocus: function hasFocus() {
	                return this.$input.is(":focus");
	            },
	            hasOverflow: function hasOverflow() {
	                var constraint = this.$input.width() - 2;
	                this.$overflowHelper.text(this.getInputValue());
	                return this.$overflowHelper.width() >= constraint;
	            },
	            isCursorAtEnd: function() {
	                var valueLength, selectionStart, range;
	                valueLength = this.$input.val().length;
	                selectionStart = this.$input[0].selectionStart;
	                if (_.isNumber(selectionStart)) {
	                    return selectionStart === valueLength;
	                } else if (document.selection) {
	                    range = document.selection.createRange();
	                    range.moveStart("character", -valueLength);
	                    return valueLength === range.text.length;
	                }
	                return true;
	            },
	            destroy: function destroy() {
	                this.$hint.off(".tt");
	                this.$input.off(".tt");
	                this.$overflowHelper.remove();
	                this.$hint = this.$input = this.$overflowHelper = $("<div>");
	            }
	        });
	        return Input;
	        function buildOverflowHelper($input) {
	            return $('<pre aria-hidden="true"></pre>').css({
	                position: "absolute",
	                visibility: "hidden",
	                whiteSpace: "pre",
	                fontFamily: $input.css("font-family"),
	                fontSize: $input.css("font-size"),
	                fontStyle: $input.css("font-style"),
	                fontVariant: $input.css("font-variant"),
	                fontWeight: $input.css("font-weight"),
	                wordSpacing: $input.css("word-spacing"),
	                letterSpacing: $input.css("letter-spacing"),
	                textIndent: $input.css("text-indent"),
	                textRendering: $input.css("text-rendering"),
	                textTransform: $input.css("text-transform")
	            }).insertAfter($input);
	        }
	        function areQueriesEquivalent(a, b) {
	            return Input.normalizeQuery(a) === Input.normalizeQuery(b);
	        }
	        function withModifier($e) {
	            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
	        }
	    }();
	    var Dataset = function() {
	        "use strict";
	        var keys, nameGenerator;
	        keys = {
	            val: "tt-selectable-display",
	            obj: "tt-selectable-object"
	        };
	        nameGenerator = _.getIdGenerator();
	        function Dataset(o, www) {
	            o = o || {};
	            o.templates = o.templates || {};
	            o.templates.notFound = o.templates.notFound || o.templates.empty;
	            if (!o.source) {
	                $.error("missing source");
	            }
	            if (!o.node) {
	                $.error("missing node");
	            }
	            if (o.name && !isValidName(o.name)) {
	                $.error("invalid dataset name: " + o.name);
	            }
	            www.mixin(this);
	            this.highlight = !!o.highlight;
	            this.name = o.name || nameGenerator();
	            this.limit = o.limit || 5;
	            this.displayFn = getDisplayFn(o.display || o.displayKey);
	            this.templates = getTemplates(o.templates, this.displayFn);
	            this.source = o.source.__ttAdapter ? o.source.__ttAdapter() : o.source;
	            this.async = _.isUndefined(o.async) ? this.source.length > 2 : !!o.async;
	            this._resetLastSuggestion();
	            this.$el = $(o.node).addClass(this.classes.dataset).addClass(this.classes.dataset + "-" + this.name);
	        }
	        Dataset.extractData = function extractData(el) {
	            var $el = $(el);
	            if ($el.data(keys.obj)) {
	                return {
	                    val: $el.data(keys.val) || "",
	                    obj: $el.data(keys.obj) || null
	                };
	            }
	            return null;
	        };
	        _.mixin(Dataset.prototype, EventEmitter, {
	            _overwrite: function overwrite(query, suggestions) {
	                suggestions = suggestions || [];
	                if (suggestions.length) {
	                    this._renderSuggestions(query, suggestions);
	                } else if (this.async && this.templates.pending) {
	                    this._renderPending(query);
	                } else if (!this.async && this.templates.notFound) {
	                    this._renderNotFound(query);
	                } else {
	                    this._empty();
	                }
	                this.trigger("rendered", this.name, suggestions, false);
	            },
	            _append: function append(query, suggestions) {
	                suggestions = suggestions || [];
	                if (suggestions.length && this.$lastSuggestion.length) {
	                    this._appendSuggestions(query, suggestions);
	                } else if (suggestions.length) {
	                    this._renderSuggestions(query, suggestions);
	                } else if (!this.$lastSuggestion.length && this.templates.notFound) {
	                    this._renderNotFound(query);
	                }
	                this.trigger("rendered", this.name, suggestions, true);
	            },
	            _renderSuggestions: function renderSuggestions(query, suggestions) {
	                var $fragment;
	                $fragment = this._getSuggestionsFragment(query, suggestions);
	                this.$lastSuggestion = $fragment.children().last();
	                this.$el.html($fragment).prepend(this._getHeader(query, suggestions)).append(this._getFooter(query, suggestions));
	            },
	            _appendSuggestions: function appendSuggestions(query, suggestions) {
	                var $fragment, $lastSuggestion;
	                $fragment = this._getSuggestionsFragment(query, suggestions);
	                $lastSuggestion = $fragment.children().last();
	                this.$lastSuggestion.after($fragment);
	                this.$lastSuggestion = $lastSuggestion;
	            },
	            _renderPending: function renderPending(query) {
	                var template = this.templates.pending;
	                this._resetLastSuggestion();
	                template && this.$el.html(template({
	                    query: query,
	                    dataset: this.name
	                }));
	            },
	            _renderNotFound: function renderNotFound(query) {
	                var template = this.templates.notFound;
	                this._resetLastSuggestion();
	                template && this.$el.html(template({
	                    query: query,
	                    dataset: this.name
	                }));
	            },
	            _empty: function empty() {
	                this.$el.empty();
	                this._resetLastSuggestion();
	            },
	            _getSuggestionsFragment: function getSuggestionsFragment(query, suggestions) {
	                var that = this, fragment;
	                fragment = document.createDocumentFragment();
	                _.each(suggestions, function getSuggestionNode(suggestion) {
	                    var $el, context;
	                    context = that._injectQuery(query, suggestion);
	                    $el = $(that.templates.suggestion(context)).data(keys.obj, suggestion).data(keys.val, that.displayFn(suggestion)).addClass(that.classes.suggestion + " " + that.classes.selectable);
	                    fragment.appendChild($el[0]);
	                });
	                this.highlight && highlight({
	                    className: this.classes.highlight,
	                    node: fragment,
	                    pattern: query
	                });
	                return $(fragment);
	            },
	            _getFooter: function getFooter(query, suggestions) {
	                return this.templates.footer ? this.templates.footer({
	                    query: query,
	                    suggestions: suggestions,
	                    dataset: this.name
	                }) : null;
	            },
	            _getHeader: function getHeader(query, suggestions) {
	                return this.templates.header ? this.templates.header({
	                    query: query,
	                    suggestions: suggestions,
	                    dataset: this.name
	                }) : null;
	            },
	            _resetLastSuggestion: function resetLastSuggestion() {
	                this.$lastSuggestion = $();
	            },
	            _injectQuery: function injectQuery(query, obj) {
	                return _.isObject(obj) ? _.mixin({
	                    _query: query
	                }, obj) : obj;
	            },
	            update: function update(query) {
	                var that = this, canceled = false, syncCalled = false, rendered = 0;
	                this.cancel();
	                this.cancel = function cancel() {
	                    canceled = true;
	                    that.cancel = $.noop;
	                    that.async && that.trigger("asyncCanceled", query);
	                };
	                this.source(query, sync, async);
	                !syncCalled && sync([]);
	                function sync(suggestions) {
	                    if (syncCalled) {
	                        return;
	                    }
	                    syncCalled = true;
	                    suggestions = (suggestions || []).slice(0, that.limit);
	                    rendered = suggestions.length;
	                    that._overwrite(query, suggestions);
	                    if (rendered < that.limit && that.async) {
	                        that.trigger("asyncRequested", query);
	                    }
	                }
	                function async(suggestions) {
	                    suggestions = suggestions || [];
	                    if (!canceled && rendered < that.limit) {
	                        that.cancel = $.noop;
	                        rendered += suggestions.length;
	                        that._append(query, suggestions.slice(0, that.limit - rendered));
	                        that.async && that.trigger("asyncReceived", query);
	                    }
	                }
	            },
	            cancel: $.noop,
	            clear: function clear() {
	                this._empty();
	                this.cancel();
	                this.trigger("cleared");
	            },
	            isEmpty: function isEmpty() {
	                return this.$el.is(":empty");
	            },
	            destroy: function destroy() {
	                this.$el = $("<div>");
	            }
	        });
	        return Dataset;
	        function getDisplayFn(display) {
	            display = display || _.stringify;
	            return _.isFunction(display) ? display : displayFn;
	            function displayFn(obj) {
	                return obj[display];
	            }
	        }
	        function getTemplates(templates, displayFn) {
	            return {
	                notFound: templates.notFound && _.templatify(templates.notFound),
	                pending: templates.pending && _.templatify(templates.pending),
	                header: templates.header && _.templatify(templates.header),
	                footer: templates.footer && _.templatify(templates.footer),
	                suggestion: templates.suggestion || suggestionTemplate
	            };
	            function suggestionTemplate(context) {
	                return $("<div>").text(displayFn(context));
	            }
	        }
	        function isValidName(str) {
	            return /^[_a-zA-Z0-9-]+$/.test(str);
	        }
	    }();
	    var Menu = function() {
	        "use strict";
	        function Menu(o, www) {
	            var that = this;
	            o = o || {};
	            if (!o.node) {
	                $.error("node is required");
	            }
	            www.mixin(this);
	            this.$node = $(o.node);
	            this.query = null;
	            this.datasets = _.map(o.datasets, initializeDataset);
	            function initializeDataset(oDataset) {
	                var node = that.$node.find(oDataset.node).first();
	                oDataset.node = node.length ? node : $("<div>").appendTo(that.$node);
	                return new Dataset(oDataset, www);
	            }
	        }
	        _.mixin(Menu.prototype, EventEmitter, {
	            _onSelectableClick: function onSelectableClick($e) {
	                this.trigger("selectableClicked", $($e.currentTarget));
	            },
	            _onRendered: function onRendered(type, dataset, suggestions, async) {
	                this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
	                this.trigger("datasetRendered", dataset, suggestions, async);
	            },
	            _onCleared: function onCleared() {
	                this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
	                this.trigger("datasetCleared");
	            },
	            _propagate: function propagate() {
	                this.trigger.apply(this, arguments);
	            },
	            _allDatasetsEmpty: function allDatasetsEmpty() {
	                return _.every(this.datasets, isDatasetEmpty);
	                function isDatasetEmpty(dataset) {
	                    return dataset.isEmpty();
	                }
	            },
	            _getSelectables: function getSelectables() {
	                return this.$node.find(this.selectors.selectable);
	            },
	            _removeCursor: function _removeCursor() {
	                var $selectable = this.getActiveSelectable();
	                $selectable && $selectable.removeClass(this.classes.cursor);
	            },
	            _ensureVisible: function ensureVisible($el) {
	                var elTop, elBottom, nodeScrollTop, nodeHeight;
	                elTop = $el.position().top;
	                elBottom = elTop + $el.outerHeight(true);
	                nodeScrollTop = this.$node.scrollTop();
	                nodeHeight = this.$node.height() + parseInt(this.$node.css("paddingTop"), 10) + parseInt(this.$node.css("paddingBottom"), 10);
	                if (elTop < 0) {
	                    this.$node.scrollTop(nodeScrollTop + elTop);
	                } else if (nodeHeight < elBottom) {
	                    this.$node.scrollTop(nodeScrollTop + (elBottom - nodeHeight));
	                }
	            },
	            bind: function() {
	                var that = this, onSelectableClick;
	                onSelectableClick = _.bind(this._onSelectableClick, this);
	                this.$node.on("click.tt", this.selectors.selectable, onSelectableClick);
	                _.each(this.datasets, function(dataset) {
	                    dataset.onSync("asyncRequested", that._propagate, that).onSync("asyncCanceled", that._propagate, that).onSync("asyncReceived", that._propagate, that).onSync("rendered", that._onRendered, that).onSync("cleared", that._onCleared, that);
	                });
	                return this;
	            },
	            isOpen: function isOpen() {
	                return this.$node.hasClass(this.classes.open);
	            },
	            open: function open() {
	                this.$node.addClass(this.classes.open);
	            },
	            close: function close() {
	                this.$node.removeClass(this.classes.open);
	                this._removeCursor();
	            },
	            setLanguageDirection: function setLanguageDirection(dir) {
	                this.$node.attr("dir", dir);
	            },
	            selectableRelativeToCursor: function selectableRelativeToCursor(delta) {
	                var $selectables, $oldCursor, oldIndex, newIndex;
	                $oldCursor = this.getActiveSelectable();
	                $selectables = this._getSelectables();
	                oldIndex = $oldCursor ? $selectables.index($oldCursor) : -1;
	                newIndex = oldIndex + delta;
	                newIndex = (newIndex + 1) % ($selectables.length + 1) - 1;
	                newIndex = newIndex < -1 ? $selectables.length - 1 : newIndex;
	                return newIndex === -1 ? null : $selectables.eq(newIndex);
	            },
	            setCursor: function setCursor($selectable) {
	                this._removeCursor();
	                if ($selectable = $selectable && $selectable.first()) {
	                    $selectable.addClass(this.classes.cursor);
	                    this._ensureVisible($selectable);
	                }
	            },
	            getSelectableData: function getSelectableData($el) {
	                return $el && $el.length ? Dataset.extractData($el) : null;
	            },
	            getActiveSelectable: function getActiveSelectable() {
	                var $selectable = this._getSelectables().filter(this.selectors.cursor).first();
	                return $selectable.length ? $selectable : null;
	            },
	            getTopSelectable: function getTopSelectable() {
	                var $selectable = this._getSelectables().first();
	                return $selectable.length ? $selectable : null;
	            },
	            update: function update(query) {
	                var isValidUpdate = query !== this.query;
	                if (isValidUpdate) {
	                    this.query = query;
	                    _.each(this.datasets, updateDataset);
	                }
	                return isValidUpdate;
	                function updateDataset(dataset) {
	                    dataset.update(query);
	                }
	            },
	            empty: function empty() {
	                _.each(this.datasets, clearDataset);
	                this.query = null;
	                this.$node.addClass(this.classes.empty);
	                function clearDataset(dataset) {
	                    dataset.clear();
	                }
	            },
	            destroy: function destroy() {
	                this.$node.off(".tt");
	                this.$node = $("<div>");
	                _.each(this.datasets, destroyDataset);
	                function destroyDataset(dataset) {
	                    dataset.destroy();
	                }
	            }
	        });
	        return Menu;
	    }();
	    var DefaultMenu = function() {
	        "use strict";
	        var s = Menu.prototype;
	        function DefaultMenu() {
	            Menu.apply(this, [].slice.call(arguments, 0));
	        }
	        _.mixin(DefaultMenu.prototype, Menu.prototype, {
	            open: function open() {
	                !this._allDatasetsEmpty() && this._show();
	                return s.open.apply(this, [].slice.call(arguments, 0));
	            },
	            close: function close() {
	                this._hide();
	                return s.close.apply(this, [].slice.call(arguments, 0));
	            },
	            _onRendered: function onRendered() {
	                if (this._allDatasetsEmpty()) {
	                    this._hide();
	                } else {
	                    this.isOpen() && this._show();
	                }
	                return s._onRendered.apply(this, [].slice.call(arguments, 0));
	            },
	            _onCleared: function onCleared() {
	                if (this._allDatasetsEmpty()) {
	                    this._hide();
	                } else {
	                    this.isOpen() && this._show();
	                }
	                return s._onCleared.apply(this, [].slice.call(arguments, 0));
	            },
	            setLanguageDirection: function setLanguageDirection(dir) {
	                this.$node.css(dir === "ltr" ? this.css.ltr : this.css.rtl);
	                return s.setLanguageDirection.apply(this, [].slice.call(arguments, 0));
	            },
	            _hide: function hide() {
	                this.$node.hide();
	            },
	            _show: function show() {
	                this.$node.css("display", "block");
	            }
	        });
	        return DefaultMenu;
	    }();
	    var Typeahead = function() {
	        "use strict";
	        function Typeahead(o, www) {
	            var onFocused, onBlurred, onEnterKeyed, onTabKeyed, onEscKeyed, onUpKeyed, onDownKeyed, onLeftKeyed, onRightKeyed, onQueryChanged, onWhitespaceChanged;
	            o = o || {};
	            if (!o.input) {
	                $.error("missing input");
	            }
	            if (!o.menu) {
	                $.error("missing menu");
	            }
	            if (!o.eventBus) {
	                $.error("missing event bus");
	            }
	            www.mixin(this);
	            this.eventBus = o.eventBus;
	            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
	            this.input = o.input;
	            this.menu = o.menu;
	            this.enabled = true;
	            this.active = false;
	            this.input.hasFocus() && this.activate();
	            this.dir = this.input.getLangDir();
	            this._hacks();
	            this.menu.bind().onSync("selectableClicked", this._onSelectableClicked, this).onSync("asyncRequested", this._onAsyncRequested, this).onSync("asyncCanceled", this._onAsyncCanceled, this).onSync("asyncReceived", this._onAsyncReceived, this).onSync("datasetRendered", this._onDatasetRendered, this).onSync("datasetCleared", this._onDatasetCleared, this);
	            onFocused = c(this, "activate", "open", "_onFocused");
	            onBlurred = c(this, "deactivate", "_onBlurred");
	            onEnterKeyed = c(this, "isActive", "isOpen", "_onEnterKeyed");
	            onTabKeyed = c(this, "isActive", "isOpen", "_onTabKeyed");
	            onEscKeyed = c(this, "isActive", "_onEscKeyed");
	            onUpKeyed = c(this, "isActive", "open", "_onUpKeyed");
	            onDownKeyed = c(this, "isActive", "open", "_onDownKeyed");
	            onLeftKeyed = c(this, "isActive", "isOpen", "_onLeftKeyed");
	            onRightKeyed = c(this, "isActive", "isOpen", "_onRightKeyed");
	            onQueryChanged = c(this, "_openIfActive", "_onQueryChanged");
	            onWhitespaceChanged = c(this, "_openIfActive", "_onWhitespaceChanged");
	            this.input.bind().onSync("focused", onFocused, this).onSync("blurred", onBlurred, this).onSync("enterKeyed", onEnterKeyed, this).onSync("tabKeyed", onTabKeyed, this).onSync("escKeyed", onEscKeyed, this).onSync("upKeyed", onUpKeyed, this).onSync("downKeyed", onDownKeyed, this).onSync("leftKeyed", onLeftKeyed, this).onSync("rightKeyed", onRightKeyed, this).onSync("queryChanged", onQueryChanged, this).onSync("whitespaceChanged", onWhitespaceChanged, this).onSync("langDirChanged", this._onLangDirChanged, this);
	        }
	        _.mixin(Typeahead.prototype, {
	            _hacks: function hacks() {
	                var $input, $menu;
	                $input = this.input.$input || $("<div>");
	                $menu = this.menu.$node || $("<div>");
	                $input.on("blur.tt", function($e) {
	                    var active, isActive, hasActive;
	                    active = document.activeElement;
	                    isActive = $menu.is(active);
	                    hasActive = $menu.has(active).length > 0;
	                    if (_.isMsie() && (isActive || hasActive)) {
	                        $e.preventDefault();
	                        $e.stopImmediatePropagation();
	                        _.defer(function() {
	                            $input.focus();
	                        });
	                    }
	                });
	                $menu.on("mousedown.tt", function($e) {
	                    $e.preventDefault();
	                });
	            },
	            _onSelectableClicked: function onSelectableClicked(type, $el) {
	                this.select($el);
	            },
	            _onDatasetCleared: function onDatasetCleared() {
	                this._updateHint();
	            },
	            _onDatasetRendered: function onDatasetRendered(type, dataset, suggestions, async) {
	                this._updateHint();
	                this.eventBus.trigger("render", suggestions, async, dataset);
	            },
	            _onAsyncRequested: function onAsyncRequested(type, dataset, query) {
	                this.eventBus.trigger("asyncrequest", query, dataset);
	            },
	            _onAsyncCanceled: function onAsyncCanceled(type, dataset, query) {
	                this.eventBus.trigger("asynccancel", query, dataset);
	            },
	            _onAsyncReceived: function onAsyncReceived(type, dataset, query) {
	                this.eventBus.trigger("asyncreceive", query, dataset);
	            },
	            _onFocused: function onFocused() {
	                this._minLengthMet() && this.menu.update(this.input.getQuery());
	            },
	            _onBlurred: function onBlurred() {
	                if (this.input.hasQueryChangedSinceLastFocus()) {
	                    this.eventBus.trigger("change", this.input.getQuery());
	                }
	            },
	            _onEnterKeyed: function onEnterKeyed(type, $e) {
	                var $selectable;
	                if ($selectable = this.menu.getActiveSelectable()) {
	                    this.select($selectable) && $e.preventDefault();
	                }
	            },
	            _onTabKeyed: function onTabKeyed(type, $e) {
	                var $selectable;
	                if ($selectable = this.menu.getActiveSelectable()) {
	                    this.select($selectable) && $e.preventDefault();
	                } else if ($selectable = this.menu.getTopSelectable()) {
	                    this.autocomplete($selectable) && $e.preventDefault();
	                }
	            },
	            _onEscKeyed: function onEscKeyed() {
	                this.close();
	            },
	            _onUpKeyed: function onUpKeyed() {
	                this.moveCursor(-1);
	            },
	            _onDownKeyed: function onDownKeyed() {
	                this.moveCursor(+1);
	            },
	            _onLeftKeyed: function onLeftKeyed() {
	                if (this.dir === "rtl" && this.input.isCursorAtEnd()) {
	                    this.autocomplete(this.menu.getTopSelectable());
	                }
	            },
	            _onRightKeyed: function onRightKeyed() {
	                if (this.dir === "ltr" && this.input.isCursorAtEnd()) {
	                    this.autocomplete(this.menu.getTopSelectable());
	                }
	            },
	            _onQueryChanged: function onQueryChanged(e, query) {
	                this._minLengthMet(query) ? this.menu.update(query) : this.menu.empty();
	            },
	            _onWhitespaceChanged: function onWhitespaceChanged() {
	                this._updateHint();
	            },
	            _onLangDirChanged: function onLangDirChanged(e, dir) {
	                if (this.dir !== dir) {
	                    this.dir = dir;
	                    this.menu.setLanguageDirection(dir);
	                }
	            },
	            _openIfActive: function openIfActive() {
	                this.isActive() && this.open();
	            },
	            _minLengthMet: function minLengthMet(query) {
	                query = _.isString(query) ? query : this.input.getQuery() || "";
	                return query.length >= this.minLength;
	            },
	            _updateHint: function updateHint() {
	                var $selectable, data, val, query, escapedQuery, frontMatchRegEx, match;
	                $selectable = this.menu.getTopSelectable();
	                data = this.menu.getSelectableData($selectable);
	                val = this.input.getInputValue();
	                if (data && !_.isBlankString(val) && !this.input.hasOverflow()) {
	                    query = Input.normalizeQuery(val);
	                    escapedQuery = _.escapeRegExChars(query);
	                    frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
	                    match = frontMatchRegEx.exec(data.val);
	                    match && this.input.setHint(val + match[1]);
	                } else {
	                    this.input.clearHint();
	                }
	            },
	            isEnabled: function isEnabled() {
	                return this.enabled;
	            },
	            enable: function enable() {
	                this.enabled = true;
	            },
	            disable: function disable() {
	                this.enabled = false;
	            },
	            isActive: function isActive() {
	                return this.active;
	            },
	            activate: function activate() {
	                if (this.isActive()) {
	                    return true;
	                } else if (!this.isEnabled() || this.eventBus.before("active")) {
	                    return false;
	                } else {
	                    this.active = true;
	                    this.eventBus.trigger("active");
	                    return true;
	                }
	            },
	            deactivate: function deactivate() {
	                if (!this.isActive()) {
	                    return true;
	                } else if (this.eventBus.before("idle")) {
	                    return false;
	                } else {
	                    this.active = false;
	                    this.close();
	                    this.eventBus.trigger("idle");
	                    return true;
	                }
	            },
	            isOpen: function isOpen() {
	                return this.menu.isOpen();
	            },
	            open: function open() {
	                if (!this.isOpen() && !this.eventBus.before("open")) {
	                    this.menu.open();
	                    this._updateHint();
	                    this.eventBus.trigger("open");
	                }
	                return this.isOpen();
	            },
	            close: function close() {
	                if (this.isOpen() && !this.eventBus.before("close")) {
	                    this.menu.close();
	                    this.input.clearHint();
	                    this.input.resetInputValue();
	                    this.eventBus.trigger("close");
	                }
	                return !this.isOpen();
	            },
	            setVal: function setVal(val) {
	                this.input.setQuery(_.toStr(val));
	            },
	            getVal: function getVal() {
	                return this.input.getQuery();
	            },
	            select: function select($selectable) {
	                var data = this.menu.getSelectableData($selectable);
	                if (data && !this.eventBus.before("select", data.obj)) {
	                    this.input.setQuery(data.val, true);
	                    this.eventBus.trigger("select", data.obj);
	                    this.close();
	                    return true;
	                }
	                return false;
	            },
	            autocomplete: function autocomplete($selectable) {
	                var query, data, isValid;
	                query = this.input.getQuery();
	                data = this.menu.getSelectableData($selectable);
	                isValid = data && query !== data.val;
	                if (isValid && !this.eventBus.before("autocomplete", data.obj)) {
	                    this.input.setQuery(data.val);
	                    this.eventBus.trigger("autocomplete", data.obj);
	                    return true;
	                }
	                return false;
	            },
	            moveCursor: function moveCursor(delta) {
	                var query, $candidate, data, payload, cancelMove;
	                query = this.input.getQuery();
	                $candidate = this.menu.selectableRelativeToCursor(delta);
	                data = this.menu.getSelectableData($candidate);
	                payload = data ? data.obj : null;
	                cancelMove = this._minLengthMet() && this.menu.update(query);
	                if (!cancelMove && !this.eventBus.before("cursorchange", payload)) {
	                    this.menu.setCursor($candidate);
	                    if (data) {
	                        this.input.setInputValue(data.val);
	                    } else {
	                        this.input.resetInputValue();
	                        this._updateHint();
	                    }
	                    this.eventBus.trigger("cursorchange", payload);
	                    return true;
	                }
	                return false;
	            },
	            destroy: function destroy() {
	                this.input.destroy();
	                this.menu.destroy();
	            }
	        });
	        return Typeahead;
	        function c(ctx) {
	            var methods = [].slice.call(arguments, 1);
	            return function() {
	                var args = [].slice.call(arguments);
	                _.each(methods, function(method) {
	                    return ctx[method].apply(ctx, args);
	                });
	            };
	        }
	    }();
	    (function() {
	        "use strict";
	        var old, keys, methods;
	        old = $.fn.typeahead;
	        keys = {
	            www: "tt-www",
	            attrs: "tt-attrs",
	            typeahead: "tt-typeahead"
	        };
	        methods = {
	            initialize: function initialize(o, datasets) {
	                var www;
	                datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
	                o = o || {};
	                www = WWW(o.classNames);
	                return this.each(attach);
	                function attach() {
	                    var $input, $wrapper, $hint, $menu, defaultHint, defaultMenu, eventBus, input, menu, typeahead, MenuConstructor;
	                    _.each(datasets, function(d) {
	                        d.highlight = !!o.highlight;
	                    });
	                    $input = $(this);
	                    $wrapper = $(www.html.wrapper);
	                    $hint = $elOrNull(o.hint);
	                    $menu = $elOrNull(o.menu);
	                    defaultHint = o.hint !== false && !$hint;
	                    defaultMenu = o.menu !== false && !$menu;
	                    defaultHint && ($hint = buildHintFromInput($input, www));
	                    defaultMenu && ($menu = $(www.html.menu).css(www.css.menu));
	                    $hint && $hint.val("");
	                    $input = prepInput($input, www);
	                    if (defaultHint || defaultMenu) {
	                        $wrapper.css(www.css.wrapper);
	                        $input.css(defaultHint ? www.css.input : www.css.inputWithNoHint);
	                        $input.wrap($wrapper).parent().prepend(defaultHint ? $hint : null).append(defaultMenu ? $menu : null);
	                    }
	                    MenuConstructor = defaultMenu ? DefaultMenu : Menu;
	                    eventBus = new EventBus({
	                        el: $input
	                    });
	                    input = new Input({
	                        hint: $hint,
	                        input: $input
	                    }, www);
	                    menu = new MenuConstructor({
	                        node: $menu,
	                        datasets: datasets
	                    }, www);
	                    typeahead = new Typeahead({
	                        input: input,
	                        menu: menu,
	                        eventBus: eventBus,
	                        minLength: o.minLength
	                    }, www);
	                    $input.data(keys.www, www);
	                    $input.data(keys.typeahead, typeahead);
	                }
	            },
	            isEnabled: function isEnabled() {
	                var enabled;
	                ttEach(this.first(), function(t) {
	                    enabled = t.isEnabled();
	                });
	                return enabled;
	            },
	            enable: function enable() {
	                ttEach(this, function(t) {
	                    t.enable();
	                });
	                return this;
	            },
	            disable: function disable() {
	                ttEach(this, function(t) {
	                    t.disable();
	                });
	                return this;
	            },
	            isActive: function isActive() {
	                var active;
	                ttEach(this.first(), function(t) {
	                    active = t.isActive();
	                });
	                return active;
	            },
	            activate: function activate() {
	                ttEach(this, function(t) {
	                    t.activate();
	                });
	                return this;
	            },
	            deactivate: function deactivate() {
	                ttEach(this, function(t) {
	                    t.deactivate();
	                });
	                return this;
	            },
	            isOpen: function isOpen() {
	                var open;
	                ttEach(this.first(), function(t) {
	                    open = t.isOpen();
	                });
	                return open;
	            },
	            open: function open() {
	                ttEach(this, function(t) {
	                    t.open();
	                });
	                return this;
	            },
	            close: function close() {
	                ttEach(this, function(t) {
	                    t.close();
	                });
	                return this;
	            },
	            select: function select(el) {
	                var success = false, $el = $(el);
	                ttEach(this.first(), function(t) {
	                    success = t.select($el);
	                });
	                return success;
	            },
	            autocomplete: function autocomplete(el) {
	                var success = false, $el = $(el);
	                ttEach(this.first(), function(t) {
	                    success = t.autocomplete($el);
	                });
	                return success;
	            },
	            moveCursor: function moveCursoe(delta) {
	                var success = false;
	                ttEach(this.first(), function(t) {
	                    success = t.moveCursor(delta);
	                });
	                return success;
	            },
	            val: function val(newVal) {
	                var query;
	                if (!arguments.length) {
	                    ttEach(this.first(), function(t) {
	                        query = t.getVal();
	                    });
	                    return query;
	                } else {
	                    ttEach(this, function(t) {
	                        t.setVal(newVal);
	                    });
	                    return this;
	                }
	            },
	            destroy: function destroy() {
	                ttEach(this, function(typeahead, $input) {
	                    revert($input);
	                    typeahead.destroy();
	                });
	                return this;
	            }
	        };
	        $.fn.typeahead = function(method) {
	            if (methods[method]) {
	                return methods[method].apply(this, [].slice.call(arguments, 1));
	            } else {
	                return methods.initialize.apply(this, arguments);
	            }
	        };
	        $.fn.typeahead.noConflict = function noConflict() {
	            $.fn.typeahead = old;
	            return this;
	        };
	        function ttEach($els, fn) {
	            $els.each(function() {
	                var $input = $(this), typeahead;
	                (typeahead = $input.data(keys.typeahead)) && fn(typeahead, $input);
	            });
	        }
	        function buildHintFromInput($input, www) {
	            return $input.clone().addClass(www.classes.hint).removeData().css(www.css.hint).css(getBackgroundStyles($input)).prop("readonly", true).removeAttr("id name placeholder required").attr({
	                autocomplete: "off",
	                spellcheck: "false",
	                tabindex: -1
	            });
	        }
	        function prepInput($input, www) {
	            $input.data(keys.attrs, {
	                dir: $input.attr("dir"),
	                autocomplete: $input.attr("autocomplete"),
	                spellcheck: $input.attr("spellcheck"),
	                style: $input.attr("style")
	            });
	            $input.addClass(www.classes.input).attr({
	                autocomplete: "off",
	                spellcheck: false
	            });
	            try {
	                !$input.attr("dir") && $input.attr("dir", "auto");
	            } catch (e) {}
	            return $input;
	        }
	        function getBackgroundStyles($el) {
	            return {
	                backgroundAttachment: $el.css("background-attachment"),
	                backgroundClip: $el.css("background-clip"),
	                backgroundColor: $el.css("background-color"),
	                backgroundImage: $el.css("background-image"),
	                backgroundOrigin: $el.css("background-origin"),
	                backgroundPosition: $el.css("background-position"),
	                backgroundRepeat: $el.css("background-repeat"),
	                backgroundSize: $el.css("background-size")
	            };
	        }
	        function revert($input) {
	            var www, $wrapper;
	            www = $input.data(keys.www);
	            $wrapper = $input.parent().filter(www.selectors.wrapper);
	            _.each($input.data(keys.attrs), function(val, key) {
	                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
	            });
	            $input.removeData(keys.typeahead).removeData(keys.www).removeData(keys.attr).removeClass(www.classes.input);
	            if ($wrapper.length) {
	                $input.detach().insertAfter($wrapper);
	                $wrapper.remove();
	            }
	        }
	        function $elOrNull(obj) {
	            var isValid, $el;
	            isValid = _.isJQuery(obj) || _.isElement(obj);
	            $el = isValid ? $(obj).first() : [];
	            return $el.length ? $el : null;
	        }
	    })();
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).setImmediate))

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * typeahead.js 0.11.1
	 * https://github.com/twitter/typeahead.js
	 * Copyright 2013-2015 Twitter, Inc. and other contributors; Licensed MIT
	 */

	(function(root, factory) {
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(16) ], __WEBPACK_AMD_DEFINE_RESULT__ = function(a0) {
	            return root["Bloodhound"] = factory(a0);
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === "object") {
	        module.exports = factory(require("jquery"));
	    } else {
	        root["Bloodhound"] = factory(jQuery);
	    }
	})(this, function($) {
	    var _ = function() {
	        "use strict";
	        return {
	            isMsie: function() {
	                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
	            },
	            isBlankString: function(str) {
	                return !str || /^\s*$/.test(str);
	            },
	            escapeRegExChars: function(str) {
	                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	            },
	            isString: function(obj) {
	                return typeof obj === "string";
	            },
	            isNumber: function(obj) {
	                return typeof obj === "number";
	            },
	            isArray: $.isArray,
	            isFunction: $.isFunction,
	            isObject: $.isPlainObject,
	            isUndefined: function(obj) {
	                return typeof obj === "undefined";
	            },
	            isElement: function(obj) {
	                return !!(obj && obj.nodeType === 1);
	            },
	            isJQuery: function(obj) {
	                return obj instanceof $;
	            },
	            toStr: function toStr(s) {
	                return _.isUndefined(s) || s === null ? "" : s + "";
	            },
	            bind: $.proxy,
	            each: function(collection, cb) {
	                $.each(collection, reverseArgs);
	                function reverseArgs(index, value) {
	                    return cb(value, index);
	                }
	            },
	            map: $.map,
	            filter: $.grep,
	            every: function(obj, test) {
	                var result = true;
	                if (!obj) {
	                    return result;
	                }
	                $.each(obj, function(key, val) {
	                    if (!(result = test.call(null, val, key, obj))) {
	                        return false;
	                    }
	                });
	                return !!result;
	            },
	            some: function(obj, test) {
	                var result = false;
	                if (!obj) {
	                    return result;
	                }
	                $.each(obj, function(key, val) {
	                    if (result = test.call(null, val, key, obj)) {
	                        return false;
	                    }
	                });
	                return !!result;
	            },
	            mixin: $.extend,
	            identity: function(x) {
	                return x;
	            },
	            clone: function(obj) {
	                return $.extend(true, {}, obj);
	            },
	            getIdGenerator: function() {
	                var counter = 0;
	                return function() {
	                    return counter++;
	                };
	            },
	            templatify: function templatify(obj) {
	                return $.isFunction(obj) ? obj : template;
	                function template() {
	                    return String(obj);
	                }
	            },
	            defer: function(fn) {
	                setTimeout(fn, 0);
	            },
	            debounce: function(func, wait, immediate) {
	                var timeout, result;
	                return function() {
	                    var context = this, args = arguments, later, callNow;
	                    later = function() {
	                        timeout = null;
	                        if (!immediate) {
	                            result = func.apply(context, args);
	                        }
	                    };
	                    callNow = immediate && !timeout;
	                    clearTimeout(timeout);
	                    timeout = setTimeout(later, wait);
	                    if (callNow) {
	                        result = func.apply(context, args);
	                    }
	                    return result;
	                };
	            },
	            throttle: function(func, wait) {
	                var context, args, timeout, result, previous, later;
	                previous = 0;
	                later = function() {
	                    previous = new Date();
	                    timeout = null;
	                    result = func.apply(context, args);
	                };
	                return function() {
	                    var now = new Date(), remaining = wait - (now - previous);
	                    context = this;
	                    args = arguments;
	                    if (remaining <= 0) {
	                        clearTimeout(timeout);
	                        timeout = null;
	                        previous = now;
	                        result = func.apply(context, args);
	                    } else if (!timeout) {
	                        timeout = setTimeout(later, remaining);
	                    }
	                    return result;
	                };
	            },
	            stringify: function(val) {
	                return _.isString(val) ? val : JSON.stringify(val);
	            },
	            noop: function() {}
	        };
	    }();
	    var VERSION = "0.11.1";
	    var tokenizers = function() {
	        "use strict";
	        return {
	            nonword: nonword,
	            whitespace: whitespace,
	            obj: {
	                nonword: getObjTokenizer(nonword),
	                whitespace: getObjTokenizer(whitespace)
	            }
	        };
	        function whitespace(str) {
	            str = _.toStr(str);
	            return str ? str.split(/\s+/) : [];
	        }
	        function nonword(str) {
	            str = _.toStr(str);
	            return str ? str.split(/\W+/) : [];
	        }
	        function getObjTokenizer(tokenizer) {
	            return function setKey(keys) {
	                keys = _.isArray(keys) ? keys : [].slice.call(arguments, 0);
	                return function tokenize(o) {
	                    var tokens = [];
	                    _.each(keys, function(k) {
	                        tokens = tokens.concat(tokenizer(_.toStr(o[k])));
	                    });
	                    return tokens;
	                };
	            };
	        }
	    }();
	    var LruCache = function() {
	        "use strict";
	        function LruCache(maxSize) {
	            this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
	            this.reset();
	            if (this.maxSize <= 0) {
	                this.set = this.get = $.noop;
	            }
	        }
	        _.mixin(LruCache.prototype, {
	            set: function set(key, val) {
	                var tailItem = this.list.tail, node;
	                if (this.size >= this.maxSize) {
	                    this.list.remove(tailItem);
	                    delete this.hash[tailItem.key];
	                    this.size--;
	                }
	                if (node = this.hash[key]) {
	                    node.val = val;
	                    this.list.moveToFront(node);
	                } else {
	                    node = new Node(key, val);
	                    this.list.add(node);
	                    this.hash[key] = node;
	                    this.size++;
	                }
	            },
	            get: function get(key) {
	                var node = this.hash[key];
	                if (node) {
	                    this.list.moveToFront(node);
	                    return node.val;
	                }
	            },
	            reset: function reset() {
	                this.size = 0;
	                this.hash = {};
	                this.list = new List();
	            }
	        });
	        function List() {
	            this.head = this.tail = null;
	        }
	        _.mixin(List.prototype, {
	            add: function add(node) {
	                if (this.head) {
	                    node.next = this.head;
	                    this.head.prev = node;
	                }
	                this.head = node;
	                this.tail = this.tail || node;
	            },
	            remove: function remove(node) {
	                node.prev ? node.prev.next = node.next : this.head = node.next;
	                node.next ? node.next.prev = node.prev : this.tail = node.prev;
	            },
	            moveToFront: function(node) {
	                this.remove(node);
	                this.add(node);
	            }
	        });
	        function Node(key, val) {
	            this.key = key;
	            this.val = val;
	            this.prev = this.next = null;
	        }
	        return LruCache;
	    }();
	    var PersistentStorage = function() {
	        "use strict";
	        var LOCAL_STORAGE;
	        try {
	            LOCAL_STORAGE = window.localStorage;
	            LOCAL_STORAGE.setItem("~~~", "!");
	            LOCAL_STORAGE.removeItem("~~~");
	        } catch (err) {
	            LOCAL_STORAGE = null;
	        }
	        function PersistentStorage(namespace, override) {
	            this.prefix = [ "__", namespace, "__" ].join("");
	            this.ttlKey = "__ttl__";
	            this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
	            this.ls = override || LOCAL_STORAGE;
	            !this.ls && this._noop();
	        }
	        _.mixin(PersistentStorage.prototype, {
	            _prefix: function(key) {
	                return this.prefix + key;
	            },
	            _ttlKey: function(key) {
	                return this._prefix(key) + this.ttlKey;
	            },
	            _noop: function() {
	                this.get = this.set = this.remove = this.clear = this.isExpired = _.noop;
	            },
	            _safeSet: function(key, val) {
	                try {
	                    this.ls.setItem(key, val);
	                } catch (err) {
	                    if (err.name === "QuotaExceededError") {
	                        this.clear();
	                        this._noop();
	                    }
	                }
	            },
	            get: function(key) {
	                if (this.isExpired(key)) {
	                    this.remove(key);
	                }
	                return decode(this.ls.getItem(this._prefix(key)));
	            },
	            set: function(key, val, ttl) {
	                if (_.isNumber(ttl)) {
	                    this._safeSet(this._ttlKey(key), encode(now() + ttl));
	                } else {
	                    this.ls.removeItem(this._ttlKey(key));
	                }
	                return this._safeSet(this._prefix(key), encode(val));
	            },
	            remove: function(key) {
	                this.ls.removeItem(this._ttlKey(key));
	                this.ls.removeItem(this._prefix(key));
	                return this;
	            },
	            clear: function() {
	                var i, keys = gatherMatchingKeys(this.keyMatcher);
	                for (i = keys.length; i--; ) {
	                    this.remove(keys[i]);
	                }
	                return this;
	            },
	            isExpired: function(key) {
	                var ttl = decode(this.ls.getItem(this._ttlKey(key)));
	                return _.isNumber(ttl) && now() > ttl ? true : false;
	            }
	        });
	        return PersistentStorage;
	        function now() {
	            return new Date().getTime();
	        }
	        function encode(val) {
	            return JSON.stringify(_.isUndefined(val) ? null : val);
	        }
	        function decode(val) {
	            return $.parseJSON(val);
	        }
	        function gatherMatchingKeys(keyMatcher) {
	            var i, key, keys = [], len = LOCAL_STORAGE.length;
	            for (i = 0; i < len; i++) {
	                if ((key = LOCAL_STORAGE.key(i)).match(keyMatcher)) {
	                    keys.push(key.replace(keyMatcher, ""));
	                }
	            }
	            return keys;
	        }
	    }();
	    var Transport = function() {
	        "use strict";
	        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
	        function Transport(o) {
	            o = o || {};
	            this.cancelled = false;
	            this.lastReq = null;
	            this._send = o.transport;
	            this._get = o.limiter ? o.limiter(this._get) : this._get;
	            this._cache = o.cache === false ? new LruCache(0) : sharedCache;
	        }
	        Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
	            maxPendingRequests = num;
	        };
	        Transport.resetCache = function resetCache() {
	            sharedCache.reset();
	        };
	        _.mixin(Transport.prototype, {
	            _fingerprint: function fingerprint(o) {
	                o = o || {};
	                return o.url + o.type + $.param(o.data || {});
	            },
	            _get: function(o, cb) {
	                var that = this, fingerprint, jqXhr;
	                fingerprint = this._fingerprint(o);
	                if (this.cancelled || fingerprint !== this.lastReq) {
	                    return;
	                }
	                if (jqXhr = pendingRequests[fingerprint]) {
	                    jqXhr.done(done).fail(fail);
	                } else if (pendingRequestsCount < maxPendingRequests) {
	                    pendingRequestsCount++;
	                    pendingRequests[fingerprint] = this._send(o).done(done).fail(fail).always(always);
	                } else {
	                    this.onDeckRequestArgs = [].slice.call(arguments, 0);
	                }
	                function done(resp) {
	                    cb(null, resp);
	                    that._cache.set(fingerprint, resp);
	                }
	                function fail() {
	                    cb(true);
	                }
	                function always() {
	                    pendingRequestsCount--;
	                    delete pendingRequests[fingerprint];
	                    if (that.onDeckRequestArgs) {
	                        that._get.apply(that, that.onDeckRequestArgs);
	                        that.onDeckRequestArgs = null;
	                    }
	                }
	            },
	            get: function(o, cb) {
	                var resp, fingerprint;
	                cb = cb || $.noop;
	                o = _.isString(o) ? {
	                    url: o
	                } : o || {};
	                fingerprint = this._fingerprint(o);
	                this.cancelled = false;
	                this.lastReq = fingerprint;
	                if (resp = this._cache.get(fingerprint)) {
	                    cb(null, resp);
	                } else {
	                    this._get(o, cb);
	                }
	            },
	            cancel: function() {
	                this.cancelled = true;
	            }
	        });
	        return Transport;
	    }();
	    var SearchIndex = window.SearchIndex = function() {
	        "use strict";
	        var CHILDREN = "c", IDS = "i";
	        function SearchIndex(o) {
	            o = o || {};
	            if (!o.datumTokenizer || !o.queryTokenizer) {
	                $.error("datumTokenizer and queryTokenizer are both required");
	            }
	            this.identify = o.identify || _.stringify;
	            this.datumTokenizer = o.datumTokenizer;
	            this.queryTokenizer = o.queryTokenizer;
	            this.reset();
	        }
	        _.mixin(SearchIndex.prototype, {
	            bootstrap: function bootstrap(o) {
	                this.datums = o.datums;
	                this.trie = o.trie;
	            },
	            add: function(data) {
	                var that = this;
	                data = _.isArray(data) ? data : [ data ];
	                _.each(data, function(datum) {
	                    var id, tokens;
	                    that.datums[id = that.identify(datum)] = datum;
	                    tokens = normalizeTokens(that.datumTokenizer(datum));
	                    _.each(tokens, function(token) {
	                        var node, chars, ch;
	                        node = that.trie;
	                        chars = token.split("");
	                        while (ch = chars.shift()) {
	                            node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());
	                            node[IDS].push(id);
	                        }
	                    });
	                });
	            },
	            get: function get(ids) {
	                var that = this;
	                return _.map(ids, function(id) {
	                    return that.datums[id];
	                });
	            },
	            search: function search(query) {
	                var that = this, tokens, matches;
	                tokens = normalizeTokens(this.queryTokenizer(query));
	                _.each(tokens, function(token) {
	                    var node, chars, ch, ids;
	                    if (matches && matches.length === 0) {
	                        return false;
	                    }
	                    node = that.trie;
	                    chars = token.split("");
	                    while (node && (ch = chars.shift())) {
	                        node = node[CHILDREN][ch];
	                    }
	                    if (node && chars.length === 0) {
	                        ids = node[IDS].slice(0);
	                        matches = matches ? getIntersection(matches, ids) : ids;
	                    } else {
	                        matches = [];
	                        return false;
	                    }
	                });
	                return matches ? _.map(unique(matches), function(id) {
	                    return that.datums[id];
	                }) : [];
	            },
	            all: function all() {
	                var values = [];
	                for (var key in this.datums) {
	                    values.push(this.datums[key]);
	                }
	                return values;
	            },
	            reset: function reset() {
	                this.datums = {};
	                this.trie = newNode();
	            },
	            serialize: function serialize() {
	                return {
	                    datums: this.datums,
	                    trie: this.trie
	                };
	            }
	        });
	        return SearchIndex;
	        function normalizeTokens(tokens) {
	            tokens = _.filter(tokens, function(token) {
	                return !!token;
	            });
	            tokens = _.map(tokens, function(token) {
	                return token.toLowerCase();
	            });
	            return tokens;
	        }
	        function newNode() {
	            var node = {};
	            node[IDS] = [];
	            node[CHILDREN] = {};
	            return node;
	        }
	        function unique(array) {
	            var seen = {}, uniques = [];
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (!seen[array[i]]) {
	                    seen[array[i]] = true;
	                    uniques.push(array[i]);
	                }
	            }
	            return uniques;
	        }
	        function getIntersection(arrayA, arrayB) {
	            var ai = 0, bi = 0, intersection = [];
	            arrayA = arrayA.sort();
	            arrayB = arrayB.sort();
	            var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
	            while (ai < lenArrayA && bi < lenArrayB) {
	                if (arrayA[ai] < arrayB[bi]) {
	                    ai++;
	                } else if (arrayA[ai] > arrayB[bi]) {
	                    bi++;
	                } else {
	                    intersection.push(arrayA[ai]);
	                    ai++;
	                    bi++;
	                }
	            }
	            return intersection;
	        }
	    }();
	    var Prefetch = function() {
	        "use strict";
	        var keys;
	        keys = {
	            data: "data",
	            protocol: "protocol",
	            thumbprint: "thumbprint"
	        };
	        function Prefetch(o) {
	            this.url = o.url;
	            this.ttl = o.ttl;
	            this.cache = o.cache;
	            this.prepare = o.prepare;
	            this.transform = o.transform;
	            this.transport = o.transport;
	            this.thumbprint = o.thumbprint;
	            this.storage = new PersistentStorage(o.cacheKey);
	        }
	        _.mixin(Prefetch.prototype, {
	            _settings: function settings() {
	                return {
	                    url: this.url,
	                    type: "GET",
	                    dataType: "json"
	                };
	            },
	            store: function store(data) {
	                if (!this.cache) {
	                    return;
	                }
	                this.storage.set(keys.data, data, this.ttl);
	                this.storage.set(keys.protocol, location.protocol, this.ttl);
	                this.storage.set(keys.thumbprint, this.thumbprint, this.ttl);
	            },
	            fromCache: function fromCache() {
	                var stored = {}, isExpired;
	                if (!this.cache) {
	                    return null;
	                }
	                stored.data = this.storage.get(keys.data);
	                stored.protocol = this.storage.get(keys.protocol);
	                stored.thumbprint = this.storage.get(keys.thumbprint);
	                isExpired = stored.thumbprint !== this.thumbprint || stored.protocol !== location.protocol;
	                return stored.data && !isExpired ? stored.data : null;
	            },
	            fromNetwork: function(cb) {
	                var that = this, settings;
	                if (!cb) {
	                    return;
	                }
	                settings = this.prepare(this._settings());
	                this.transport(settings).fail(onError).done(onResponse);
	                function onError() {
	                    cb(true);
	                }
	                function onResponse(resp) {
	                    cb(null, that.transform(resp));
	                }
	            },
	            clear: function clear() {
	                this.storage.clear();
	                return this;
	            }
	        });
	        return Prefetch;
	    }();
	    var Remote = function() {
	        "use strict";
	        function Remote(o) {
	            this.url = o.url;
	            this.prepare = o.prepare;
	            this.transform = o.transform;
	            this.transport = new Transport({
	                cache: o.cache,
	                limiter: o.limiter,
	                transport: o.transport
	            });
	        }
	        _.mixin(Remote.prototype, {
	            _settings: function settings() {
	                return {
	                    url: this.url,
	                    type: "GET",
	                    dataType: "json"
	                };
	            },
	            get: function get(query, cb) {
	                var that = this, settings;
	                if (!cb) {
	                    return;
	                }
	                query = query || "";
	                settings = this.prepare(query, this._settings());
	                return this.transport.get(settings, onResponse);
	                function onResponse(err, resp) {
	                    err ? cb([]) : cb(that.transform(resp));
	                }
	            },
	            cancelLastRequest: function cancelLastRequest() {
	                this.transport.cancel();
	            }
	        });
	        return Remote;
	    }();
	    var oParser = function() {
	        "use strict";
	        return function parse(o) {
	            var defaults, sorter;
	            defaults = {
	                initialize: true,
	                identify: _.stringify,
	                datumTokenizer: null,
	                queryTokenizer: null,
	                sufficient: 5,
	                sorter: null,
	                local: [],
	                prefetch: null,
	                remote: null
	            };
	            o = _.mixin(defaults, o || {});
	            !o.datumTokenizer && $.error("datumTokenizer is required");
	            !o.queryTokenizer && $.error("queryTokenizer is required");
	            sorter = o.sorter;
	            o.sorter = sorter ? function(x) {
	                return x.sort(sorter);
	            } : _.identity;
	            o.local = _.isFunction(o.local) ? o.local() : o.local;
	            o.prefetch = parsePrefetch(o.prefetch);
	            o.remote = parseRemote(o.remote);
	            return o;
	        };
	        function parsePrefetch(o) {
	            var defaults;
	            if (!o) {
	                return null;
	            }
	            defaults = {
	                url: null,
	                ttl: 24 * 60 * 60 * 1e3,
	                cache: true,
	                cacheKey: null,
	                thumbprint: "",
	                prepare: _.identity,
	                transform: _.identity,
	                transport: null
	            };
	            o = _.isString(o) ? {
	                url: o
	            } : o;
	            o = _.mixin(defaults, o);
	            !o.url && $.error("prefetch requires url to be set");
	            o.transform = o.filter || o.transform;
	            o.cacheKey = o.cacheKey || o.url;
	            o.thumbprint = VERSION + o.thumbprint;
	            o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
	            return o;
	        }
	        function parseRemote(o) {
	            var defaults;
	            if (!o) {
	                return;
	            }
	            defaults = {
	                url: null,
	                cache: true,
	                prepare: null,
	                replace: null,
	                wildcard: null,
	                limiter: null,
	                rateLimitBy: "debounce",
	                rateLimitWait: 300,
	                transform: _.identity,
	                transport: null
	            };
	            o = _.isString(o) ? {
	                url: o
	            } : o;
	            o = _.mixin(defaults, o);
	            !o.url && $.error("remote requires url to be set");
	            o.transform = o.filter || o.transform;
	            o.prepare = toRemotePrepare(o);
	            o.limiter = toLimiter(o);
	            o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
	            delete o.replace;
	            delete o.wildcard;
	            delete o.rateLimitBy;
	            delete o.rateLimitWait;
	            return o;
	        }
	        function toRemotePrepare(o) {
	            var prepare, replace, wildcard;
	            prepare = o.prepare;
	            replace = o.replace;
	            wildcard = o.wildcard;
	            if (prepare) {
	                return prepare;
	            }
	            if (replace) {
	                prepare = prepareByReplace;
	            } else if (o.wildcard) {
	                prepare = prepareByWildcard;
	            } else {
	                prepare = idenityPrepare;
	            }
	            return prepare;
	            function prepareByReplace(query, settings) {
	                settings.url = replace(settings.url, query);
	                return settings;
	            }
	            function prepareByWildcard(query, settings) {
	                settings.url = settings.url.replace(wildcard, encodeURIComponent(query));
	                return settings;
	            }
	            function idenityPrepare(query, settings) {
	                return settings;
	            }
	        }
	        function toLimiter(o) {
	            var limiter, method, wait;
	            limiter = o.limiter;
	            method = o.rateLimitBy;
	            wait = o.rateLimitWait;
	            if (!limiter) {
	                limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);
	            }
	            return limiter;
	            function debounce(wait) {
	                return function debounce(fn) {
	                    return _.debounce(fn, wait);
	                };
	            }
	            function throttle(wait) {
	                return function throttle(fn) {
	                    return _.throttle(fn, wait);
	                };
	            }
	        }
	        function callbackToDeferred(fn) {
	            return function wrapper(o) {
	                var deferred = $.Deferred();
	                fn(o, onSuccess, onError);
	                return deferred;
	                function onSuccess(resp) {
	                    _.defer(function() {
	                        deferred.resolve(resp);
	                    });
	                }
	                function onError(err) {
	                    _.defer(function() {
	                        deferred.reject(err);
	                    });
	                }
	            };
	        }
	    }();
	    var Bloodhound = function() {
	        "use strict";
	        var old;
	        old = window && window.Bloodhound;
	        function Bloodhound(o) {
	            o = oParser(o);
	            this.sorter = o.sorter;
	            this.identify = o.identify;
	            this.sufficient = o.sufficient;
	            this.local = o.local;
	            this.remote = o.remote ? new Remote(o.remote) : null;
	            this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null;
	            this.index = new SearchIndex({
	                identify: this.identify,
	                datumTokenizer: o.datumTokenizer,
	                queryTokenizer: o.queryTokenizer
	            });
	            o.initialize !== false && this.initialize();
	        }
	        Bloodhound.noConflict = function noConflict() {
	            window && (window.Bloodhound = old);
	            return Bloodhound;
	        };
	        Bloodhound.tokenizers = tokenizers;
	        _.mixin(Bloodhound.prototype, {
	            __ttAdapter: function ttAdapter() {
	                var that = this;
	                return this.remote ? withAsync : withoutAsync;
	                function withAsync(query, sync, async) {
	                    return that.search(query, sync, async);
	                }
	                function withoutAsync(query, sync) {
	                    return that.search(query, sync);
	                }
	            },
	            _loadPrefetch: function loadPrefetch() {
	                var that = this, deferred, serialized;
	                deferred = $.Deferred();
	                if (!this.prefetch) {
	                    deferred.resolve();
	                } else if (serialized = this.prefetch.fromCache()) {
	                    this.index.bootstrap(serialized);
	                    deferred.resolve();
	                } else {
	                    this.prefetch.fromNetwork(done);
	                }
	                return deferred.promise();
	                function done(err, data) {
	                    if (err) {
	                        return deferred.reject();
	                    }
	                    that.add(data);
	                    that.prefetch.store(that.index.serialize());
	                    deferred.resolve();
	                }
	            },
	            _initialize: function initialize() {
	                var that = this, deferred;
	                this.clear();
	                (this.initPromise = this._loadPrefetch()).done(addLocalToIndex);
	                return this.initPromise;
	                function addLocalToIndex() {
	                    that.add(that.local);
	                }
	            },
	            initialize: function initialize(force) {
	                return !this.initPromise || force ? this._initialize() : this.initPromise;
	            },
	            add: function add(data) {
	                this.index.add(data);
	                return this;
	            },
	            get: function get(ids) {
	                ids = _.isArray(ids) ? ids : [].slice.call(arguments);
	                return this.index.get(ids);
	            },
	            search: function search(query, sync, async) {
	                var that = this, local;
	                local = this.sorter(this.index.search(query));
	                sync(this.remote ? local.slice() : local);
	                if (this.remote && local.length < this.sufficient) {
	                    this.remote.get(query, processRemote);
	                } else if (this.remote) {
	                    this.remote.cancelLastRequest();
	                }
	                return this;
	                function processRemote(remote) {
	                    var nonDuplicates = [];
	                    _.each(remote, function(r) {
	                        !_.some(local, function(l) {
	                            return that.identify(r) === that.identify(l);
	                        }) && nonDuplicates.push(r);
	                    });
	                    async && async(nonDuplicates);
	                }
	            },
	            all: function all() {
	                return this.index.all();
	            },
	            clear: function clear() {
	                this.index.reset();
	                return this;
	            },
	            clearPrefetchCache: function clearPrefetchCache() {
	                this.prefetch && this.prefetch.clear();
	                return this;
	            },
	            clearRemoteCache: function clearRemoteCache() {
	                Transport.resetCache();
	                return this;
	            },
	            ttAdapter: function ttAdapter() {
	                return this.__ttAdapter();
	            }
	        });
	        return Bloodhound;
	    }();
	    return Bloodhound;
	});

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Field = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
	                                                                                                                                                                                                                                                                               * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	                                                                                                                                                                                                                                                                               * Bespoke Link to Instruments and Small Satellites (BLISS)
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	                                                                                                                                                                                                                                                                               * RESERVED. United States Government Sponsorship acknowledged. Any
	                                                                                                                                                                                                                                                                               * commercial use must be negotiated with the Office of Technology Transfer
	                                                                                                                                                                                                                                                                               * at the California Institute of Technology.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * This software may be subject to U.S. export control laws. By accepting
	                                                                                                                                                                                                                                                                               * this software, the user agrees to comply with all applicable U.S. export
	                                                                                                                                                                                                                                                                               * laws and regulations. User has the responsibility to obtain export licenses,
	                                                                                                                                                                                                                                                                               * or other export authority as may be required before exporting such
	                                                                                                                                                                                                                                                                               * information to foreign countries or providing access to foreign persons.
	                                                                                                                                                                                                                                                                               */

	var _mithril = __webpack_require__(1);

	var _mithril2 = _interopRequireDefault(_mithril);

	var _sprintfJs = __webpack_require__(159);

	var _strftime = __webpack_require__(160);

	var strftime = _interopRequireWildcard(_strftime);

	var _cmd = __webpack_require__(9);

	var _evr = __webpack_require__(10);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Field = {
	    _limitOut: false,

	    /**
	     * Caches the current packet and raw value (for use by
	     * hasChanged()).
	     */
	    cache: function cache(packet) {
	        if (!packet) return;

	        this._cached.packet = packet;
	        this._cached.rawval = this.getValue(packet, true);
	    },


	    /**
	     * @returns the current packet displayed by this Field.
	     */
	    getPacket: function getPacket() {
	        var buffer = bliss.packets[this._pname];
	        return buffer && buffer.get(0);
	    },


	    /**
	     * @returns the value displayed by this Field, for the given
	     * packet.
	     *
	     * If the optional parameter raw is true, no conversions
	     * (e.g. DN-to-EU, Commands, EVRs, etc.) are performed when
	     * retrieving the packet value.
	     */
	    getValue: function getValue(packet) {
	        var raw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return packet && packet.__get__(this._fname, raw);
	    },


	    /**
	     * @returns true if the value displayed by this field has changed,
	     * false otherwise.
	     */
	    hasChanged: function hasChanged() {
	        var packet = this.getPacket();
	        return this._cached.packet !== packet && this._cached.rawval !== this.getValue(packet, true);
	    },


	    /**
	     * Check if a limit exists for the field.
	     */
	    hasLimitCheck: function hasLimitCheck() {
	        if (this._limits === null) {
	            if (typeof bliss.limits === 'undefined') return false;

	            var limitIndex = this._pname + '.' + this._fname;
	            if (limitIndex in bliss.limits.dict) {
	                this._limits = bliss.limits.dict[this._pname + '.' + this._fname];
	            } else {
	                this._limits = false;
	            }
	        }

	        return this._limits;
	    },


	    /**
	     * Check if a value is within the limit range(s) specified as an error
	     */
	    valueIsInErrorRange: function valueIsInErrorRange(value) {
	        var isError = false;
	        if ('value' in this._limits && 'error' in this._limits.value) {
	            if (typeof this._limits.value.error === 'string') {
	                isError = value === this._limits.value.error;
	            } else {
	                isError = this._limits.value.error.includes(value);
	            }
	        } else {
	            if ('upper' in this._limits && 'error' in this._limits.upper) {
	                isError = value > this._limits.upper.error;
	            }

	            if ('lower' in this._limits && 'error' in this._limits.lower) {
	                isError = value < this._limits.lower.error || isError;
	            }
	        }
	        return isError;
	    },


	    /**
	     * Check if a value is within the limit range(s) specified as a warning
	     */
	    valueIsInWarnRange: function valueIsInWarnRange(value) {
	        var isWarning = false;
	        if ('value' in this._limits && 'warn' in this._limits.value) {
	            if (typeof this._limits.value.warn === 'string') {
	                isWarning = value === this._limits.value.warn;
	            } else {
	                isWarning = this._limits.value.warn.includes(value);
	            }
	        } else {
	            if ('upper' in this._limits && 'warn' in this._limits.upper) {
	                isWarning = value > this._limits.upper.warn;
	            }

	            if ('lower' in this._limits && 'warn' in this._limits.lower) {
	                isWarning = value < this._limits.lower.warn || isWarning;
	            }
	        }
	        return isWarning;
	    },


	    // Mithril lifecycle method
	    oninit: function oninit(vnode) {
	        this._fname = vnode.attrs.name;
	        this._pname = vnode.attrs.packet;
	        this._raw = vnode.attrs.raw === true;
	        this._cached = { packet: null, rawval: null };
	        this._limits = null;
	    },
	    oncreate: function oncreate(vnode) {
	        var _this = this;

	        bliss.tlm.promise.then(function () {
	            var fieldDefn = null;

	            if (bliss.tlm.dict[_this._pname] && bliss.tlm.dict[_this._pname].fields[_this._fname]) {
	                fieldDefn = bliss.tlm.dict[_this._pname].fields[_this._fname];
	            }

	            if (fieldDefn && !('disable-tlm-popover' in vnode.attrs)) {
	                var desc = fieldDefn.desc ? fieldDefn.desc : "None";
	                var type = fieldDefn.type ? fieldDefn.type._name : "Unknown";
	                var bytes = _typeof(fieldDefn.bytes) === "object" ? fieldDefn.bytes[0] + " - " + fieldDefn.bytes[1] : fieldDefn.bytes;

	                var hex_padding = 2;
	                if (_typeof(fieldDefn.bytes) === "object") {
	                    hex_padding = (fieldDefn.bytes[1] - fieldDefn.bytes[0] + 1) * 2;
	                }

	                var mask = fieldDefn.mask ? '0x' + (0, _sprintfJs.sprintf)('%0' + hex_padding + 'X', fieldDefn.mask) : "None";

	                var popover_content = '\n                    <p><b>Description:</b> ' + desc + '</p>\n                    <p><b>Data Type:</b> ' + type + '</p>\n                    <p><b>Byte(s) in Packet:</b> ' + bytes + '</p>\n                    <p><b>Bit Mask:</b> ' + mask + '</p>\n                ';

	                if (fieldDefn.enum) {
	                    var enums = "";
	                    var _enum = fieldDefn.enum;
	                    for (var k in _enum) {
	                        enums += '<dt>' + k + '</dt><dd>' + _enum[k];
	                    }
	                    popover_content += '<b>Enumerated Values:</b><dl>' + enums + '</dl>';
	                }

	                if (fieldDefn.dntoeu) {
	                    var dntoeu = "";
	                    var _dntoeu = fieldDefn.dntoeu;
	                    for (var _k in _dntoeu) {
	                        dntoeu += '<dt>' + _k + '</dt><dd>' + _dntoeu[_k];
	                    }
	                    popover_content += '<b>DN-to-EU:</b><dl>' + dntoeu + '</dl>';
	                }

	                if (fieldDefn.aliases) {
	                    var aliases = "";
	                    var _aliases = fieldDefn.aliases;
	                    for (var _k2 in _aliases) {
	                        aliases += '<dt>' + _k2 + '</dt><dd>' + _aliases[_k2];
	                    }
	                    popover_content += '<b>Aliases:</b><dl>' + aliases + '</dl>';
	                }

	                var title = '<div>' + fieldDefn.name + '<span class="pull-right" style="cursor:pointer">' + '\xD7' + '</span></div>';

	                var popover_id = void 0;
	                var bodyClickClosePopoverHandler = function bodyClickClosePopoverHandler() {
	                    $(vnode.dom).popover('hide');
	                };

	                $(vnode.dom).popover({
	                    content: '<bliss-field-popover>' + popover_content + '</bliss-field-popover>',
	                    title: title,
	                    html: true,
	                    placement: 'auto right',
	                    container: 'body'
	                }).on('shown.bs.popover', function (e) {
	                    var popover_id = e.currentTarget.attributes['aria-describedby'].value;
	                    var popover_title = document.getElementById(popover_id).getElementsByClassName('popover-title')[0];
	                    var span = popover_title.getElementsByTagName('span')[0];

	                    // Add handler to the close icon span in the popover title
	                    // so it can be used to close the popover.
	                    span.addEventListener('click', function () {
	                        $(vnode.dom).popover('hide');
	                    });

	                    // Add handler to body so that clicks outside of the popover
	                    // cause it to close.
	                    document.body.addEventListener('click', bodyClickClosePopoverHandler);

	                    // Capture click events on the popover so they don't
	                    // propagate up to the body and close the popover.
	                    document.getElementById(popover_id).addEventListener('click', function (e) {
	                        e.stopPropagation();
	                    });
	                }).on('hide.bs.popover', function (e) {
	                    // Clean up our popover click handler from body when we're done.
	                    document.body.removeEventListener('click', bodyClickClosePopoverHandler);
	                }).on('hidden.bs.popover', function (e) {
	                    // Resets the popover click state that gets out of sync when
	                    // the popover is open/closed programmatically. Without this
	                    // the Field can end up in a state where you need to click
	                    // it twice to toggle the popover if the close icon or body
	                    // click handler caused it to close previously.
	                    $(e.target).data("bs.popover").inState.click = false;
	                });
	            }
	        });
	    },


	    // Mithril lifecycle method
	    onbeforeupdate: function onbeforeupdate(vnode, old) {
	        return this.hasChanged();
	    },


	    // Mithril view() method
	    view: function view(vnode) {
	        var packet = this.getPacket();
	        var value = this.getValue(packet, this._raw);

	        this.cache(packet);

	        if (value === undefined || value === null) {
	            value = 'N/A';
	        } else if (value instanceof _cmd.CommandDefinition) {
	            value = value.name ? value.name : value.opcode ? value.opcode : 'Unidentified Cmd';
	        } else if (value instanceof _evr.EVRDefinition) {
	            value = value.name ? value.name : value.code ? value.code : 'Unidentified EVR';
	        } else {
	            if (vnode.attrs.format) {
	                var defn = packet._defn.fields[this._fname];
	                var type = defn && defn.type;

	                value = type && type.isTime ? strftime.utc()(vnode.attrs.format, value) : (0, _sprintfJs.sprintf)(vnode.attrs.format, value);
	            } else {
	                // If the Field doesn't have a format specified and is
	                // displaying a float we default to 5 digits after the
	                // decimal point.
	                if (!isNaN(value) && !Number.isInteger(value)) {
	                    value = Number(value).toFixed(5);
	                }
	            }

	            if (this.hasLimitCheck()) {
	                // Limit checks should always be performed against a DN-to-EU
	                // converted value since limits are expected to be defined
	                // in EU values.
	                var limitChkVal = this._raw ? this.getValue(packet, false) : value;

	                if (!('class' in vnode.attrs)) {
	                    vnode.attrs.class = "";
	                }

	                if (this.valueIsInErrorRange(limitChkVal)) {
	                    this._limitOut = true;
	                    vnode.attrs.class += "alert-danger";
	                    bliss.events.emit('field:limitOut', {
	                        field: this._pname + '_' + this._fname,
	                        type: 'error'
	                    });
	                } else if (this.valueIsInWarnRange(limitChkVal)) {
	                    this._limitOut = true;
	                    vnode.attrs.class += "alert-warning";
	                    bliss.events.emit('field:limitOut', {
	                        field: this._pname + '_' + this._fname,
	                        type: 'warning'
	                    });
	                } else if (this._limitOut) {
	                    this._limitOut = false;
	                    bliss.events.emit('field:limitIn', this._pname + '_' + this._fname);
	                }
	            }
	        }

	        return (0, _mithril2.default)('bliss-field', vnode.attrs, value);
	    }
	};

	exports.default = Field;
	exports.Field = Field;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	(function(window) {
	    var re = {
	        not_string: /[^s]/,
	        number: /[diefg]/,
	        json: /[j]/,
	        not_json: /[^j]/,
	        text: /^[^\x25]+/,
	        modulo: /^\x25{2}/,
	        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/,
	        key: /^([a-z_][a-z_\d]*)/i,
	        key_access: /^\.([a-z_][a-z_\d]*)/i,
	        index_access: /^\[(\d+)\]/,
	        sign: /^[\+\-]/
	    }

	    function sprintf() {
	        var key = arguments[0], cache = sprintf.cache
	        if (!(cache[key] && cache.hasOwnProperty(key))) {
	            cache[key] = sprintf.parse(key)
	        }
	        return sprintf.format.call(null, cache[key], arguments)
	    }

	    sprintf.format = function(parse_tree, argv) {
	        var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ""
	        for (i = 0; i < tree_length; i++) {
	            node_type = get_type(parse_tree[i])
	            if (node_type === "string") {
	                output[output.length] = parse_tree[i]
	            }
	            else if (node_type === "array") {
	                match = parse_tree[i] // convenience purposes only
	                if (match[2]) { // keyword argument
	                    arg = argv[cursor]
	                    for (k = 0; k < match[2].length; k++) {
	                        if (!arg.hasOwnProperty(match[2][k])) {
	                            throw new Error(sprintf("[sprintf] property '%s' does not exist", match[2][k]))
	                        }
	                        arg = arg[match[2][k]]
	                    }
	                }
	                else if (match[1]) { // positional argument (explicit)
	                    arg = argv[match[1]]
	                }
	                else { // positional argument (implicit)
	                    arg = argv[cursor++]
	                }

	                if (get_type(arg) == "function") {
	                    arg = arg()
	                }

	                if (re.not_string.test(match[8]) && re.not_json.test(match[8]) && (get_type(arg) != "number" && isNaN(arg))) {
	                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
	                }

	                if (re.number.test(match[8])) {
	                    is_positive = arg >= 0
	                }

	                switch (match[8]) {
	                    case "b":
	                        arg = arg.toString(2)
	                    break
	                    case "c":
	                        arg = String.fromCharCode(arg)
	                    break
	                    case "d":
	                    case "i":
	                        arg = parseInt(arg, 10)
	                    break
	                    case "j":
	                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
	                    break
	                    case "e":
	                        arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential()
	                    break
	                    case "f":
	                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
	                    break
	                    case "g":
	                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
	                    break
	                    case "o":
	                        arg = arg.toString(8)
	                    break
	                    case "s":
	                        arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case "u":
	                        arg = arg >>> 0
	                    break
	                    case "x":
	                        arg = arg.toString(16)
	                    break
	                    case "X":
	                        arg = arg.toString(16).toUpperCase()
	                    break
	                }
	                if (re.json.test(match[8])) {
	                    output[output.length] = arg
	                }
	                else {
	                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
	                        sign = is_positive ? "+" : "-"
	                        arg = arg.toString().replace(re.sign, "")
	                    }
	                    else {
	                        sign = ""
	                    }
	                    pad_character = match[4] ? match[4] === "0" ? "0" : match[4].charAt(1) : " "
	                    pad_length = match[6] - (sign + arg).length
	                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : "") : ""
	                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === "0" ? sign + pad + arg : pad + sign + arg)
	                }
	            }
	        }
	        return output.join("")
	    }

	    sprintf.cache = {}

	    sprintf.parse = function(fmt) {
	        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
	        while (_fmt) {
	            if ((match = re.text.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = match[0]
	            }
	            else if ((match = re.modulo.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = "%"
	            }
	            else if ((match = re.placeholder.exec(_fmt)) !== null) {
	                if (match[2]) {
	                    arg_names |= 1
	                    var field_list = [], replacement_field = match[2], field_match = []
	                    if ((field_match = re.key.exec(replacement_field)) !== null) {
	                        field_list[field_list.length] = field_match[1]
	                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
	                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else {
	                                throw new SyntaxError("[sprintf] failed to parse named argument key")
	                            }
	                        }
	                    }
	                    else {
	                        throw new SyntaxError("[sprintf] failed to parse named argument key")
	                    }
	                    match[2] = field_list
	                }
	                else {
	                    arg_names |= 2
	                }
	                if (arg_names === 3) {
	                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
	                }
	                parse_tree[parse_tree.length] = match
	            }
	            else {
	                throw new SyntaxError("[sprintf] unexpected placeholder")
	            }
	            _fmt = _fmt.substring(match[0].length)
	        }
	        return parse_tree
	    }

	    var vsprintf = function(fmt, argv, _argv) {
	        _argv = (argv || []).slice(0)
	        _argv.splice(0, 0, fmt)
	        return sprintf.apply(null, _argv)
	    }

	    /**
	     * helpers
	     */
	    function get_type(variable) {
	        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
	    }

	    function str_repeat(input, multiplier) {
	        return Array(multiplier + 1).join(input)
	    }

	    /**
	     * export to either browser or node.js
	     */
	    if (true) {
	        exports.sprintf = sprintf
	        exports.vsprintf = vsprintf
	    }
	    else {
	        window.sprintf = sprintf
	        window.vsprintf = vsprintf

	        if (typeof define === "function" && define.amd) {
	            define(function() {
	                return {
	                    sprintf: sprintf,
	                    vsprintf: vsprintf
	                }
	            })
	        }
	    }
	})(typeof window === "undefined" ? this : window);


/***/ }),
/* 160 */
/***/ (function(module, exports) {

	//
	// strftime
	// github.com/samsonjs/strftime
	// @_sjs
	//
	// Copyright 2010 - 2016 Sami Samhuri <sami@samhuri.net>
	//
	// MIT License
	// http://sjs.mit-license.org
	//

	;(function() {

	    var Locales = {
	        de_DE: {
	            days: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
	            shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
	            months: ['Januar', 'Februar', 'Mrz', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
	            shortMonths: ['Jan', 'Feb', 'Mr', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d.%m.%Y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%T',
	                x: '%D'
	            }
	        },

	        en_CA: {
	            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],
	            shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	            ordinalSuffixes: [
	                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
	                'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
	                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
	                'st'
	            ],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d/%m/%y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%r',
	                x: '%D'
	            }
	        },

	        en_US: {
	            days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],
	            shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
	            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	            ordinalSuffixes: [
	                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
	                'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
	                'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
	                'st'
	            ],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%m/%d/%y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%r',
	                x: '%D'
	            }
	        },

	        es_MX: {
	            days: ['domingo', 'lunes', 'martes', 'mircoles', 'jueves', 'viernes', 'sbado'],
	            shortDays: ['dom', 'lun', 'mar', 'mi', 'jue', 'vie', 'sb'],
	            months: ['enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio', 'julio', 'agosto', 'septiembre', 'octubre', 'noviembre',' diciembre'],
	            shortMonths: ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d/%m/%Y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%T',
	                x: '%D'
	            }
	        },

	        fr_FR: {
	            days: ['dimanche', 'lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi'],
	            shortDays: ['dim.', 'lun.', 'mar.', 'mer.', 'jeu.', 'ven.', 'sam.'],
	            months: ['janvier', 'fvrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'aot', 'septembre', 'octobre', 'novembre', 'dcembre'],
	            shortMonths: ['janv.', 'fvr.', 'mars', 'avril', 'mai', 'juin', 'juil.', 'aot', 'sept.', 'oct.', 'nov.', 'dc.'],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d/%m/%Y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%T',
	                x: '%D'
	            }
	        },

	        it_IT: {
	            days: ['domenica', 'luned', 'marted', 'mercoled', 'gioved', 'venerd', 'sabato'],
	            shortDays: ['dom', 'lun', 'mar', 'mer', 'gio', 'ven', 'sab'],
	            months: ['gennaio', 'febbraio', 'marzo', 'aprile', 'maggio', 'giugno', 'luglio', 'agosto', 'settembre', 'ottobre', 'novembre', 'dicembre'],
	            shortMonths: ['pr', 'mag', 'giu', 'lug', 'ago', 'set', 'ott', 'nov', 'dic'],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d/%m/%Y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%T',
	                x: '%D'
	            }
	        },

	        nl_NL: {
	            days: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
	            shortDays: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za'],
	            months: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
	            shortMonths: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d-%m-%y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%T',
	                x: '%D'
	            }
	        },

	        pt_BR: {
	            days: ['domingo', 'segunda', 'tera', 'quarta', 'quinta', 'sexta', 'sbado'],
	            shortDays: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sb'],
	            months: ['janeiro', 'fevereiro', 'maro', 'abril', 'maio', 'junho', 'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'],
	            shortMonths: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d-%m-%Y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%T',
	                x: '%D'
	            }
	        },

	        ru_RU: {
	            days: ['', '', '', '', '', '', ''],
	            shortDays: ['', '', '', '', '', '', ''],
	            months: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            shortMonths: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            AM: 'AM',
	            PM: 'PM',
	            am: 'am',
	            pm: 'pm',
	            formats: {
	                c: '%a %d %b %Y %X',
	                D: '%d.%m.%y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%T',
	                x: '%D'
	            }
	        },

	        tr_TR: {
	            days: ['Pazar', 'Pazartesi', 'Sal','aramba', 'Perembe', 'Cuma', 'Cumartesi'],
	            shortDays: ['Paz', 'Pzt', 'Sal', 'r', 'Pr', 'Cum', 'Cts'],
	            months: ['Ocak', 'ubat', 'Mart', 'Nisan', 'Mays', 'Haziran', 'Temmuz', 'Austos', 'Eyll', 'Ekim', 'Kasm', 'Aralk'],
	            shortMonths: ['Oca', 'ub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Au', 'Eyl', 'Eki', 'Kas', 'Ara'],
	            AM: '',
	            PM: 'S',
	            am: '',
	            pm: 'S',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d-%m-%Y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%T',
	                x: '%D'
	            }
	        },

	        // By michaeljayt<michaeljayt@gmail.com>
	        // https://github.com/michaeljayt/strftime/commit/bcb4c12743811d51e568175aa7bff3fd2a77cef3
	        zh_CN: {
	            days: ['', '', '', '', '', '', ''],
	            shortDays: ['', '', '', '', '', '', ''],
	            months: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            shortMonths: ['', '', '', '', '', '', '', '', '', '', '', ''],
	            AM: '',
	            PM: '',
	            am: '',
	            pm: '',
	            formats: {
	                c: '%a %d %b %Y %X %Z',
	                D: '%d/%m/%y',
	                F: '%Y-%m-%d',
	                R: '%H:%M',
	                r: '%I:%M:%S %p',
	                T: '%H:%M:%S',
	                v: '%e-%b-%Y',
	                X: '%r',
	                x: '%D'
	            }
	        }
	    };

	    var DefaultLocale = Locales['en_US'],
	        defaultStrftime = new Strftime(DefaultLocale, 0, false),
	        isCommonJS = typeof module !== 'undefined',
	        namespace;

	    // CommonJS / Node module
	    if (isCommonJS) {
	        namespace = module.exports = defaultStrftime;
	    }
	    // Browsers and other environments
	    else {
	        // Get the global object. Works in ES3, ES5, and ES5 strict mode.
	        namespace = (function() { return this || (1,eval)('this'); }());
	        namespace.strftime = defaultStrftime;
	    }

	    // Polyfill Date.now for old browsers.
	    if (typeof Date.now !== 'function') {
	        Date.now = function() {
	          return +new Date();
	        };
	    }

	    function Strftime(locale, customTimezoneOffset, useUtcTimezone) {
	        var _locale = locale || DefaultLocale,
	            _customTimezoneOffset = customTimezoneOffset || 0,
	            _useUtcBasedDate = useUtcTimezone || false,

	            // we store unix timestamp value here to not create new Date() each iteration (each millisecond)
	            // Date.now() is 2 times faster than new Date()
	            // while millisecond precise is enough here
	            // this could be very helpful when strftime triggered a lot of times one by one
	            _cachedDateTimestamp = 0,
	            _cachedDate;

	        function _strftime(format, date) {
	            var timestamp;

	            if (!date) {
	                var currentTimestamp = Date.now();
	                if (currentTimestamp > _cachedDateTimestamp) {
	                    _cachedDateTimestamp = currentTimestamp;
	                    _cachedDate = new Date(_cachedDateTimestamp);

	                    timestamp = _cachedDateTimestamp;

	                    if (_useUtcBasedDate) {
	                        // how to avoid duplication of date instantiation for utc here?
	                        // we tied to getTimezoneOffset of the current date
	                        _cachedDate = new Date(_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate) + _customTimezoneOffset);
	                    }
	                }
	                else {
	                  timestamp = _cachedDateTimestamp;
	                }
	                date = _cachedDate;
	            }
	            else {
	                timestamp = date.getTime();

	                if (_useUtcBasedDate) {
	                    var utcOffset = getTimestampToUtcOffsetFor(date);
	                    date = new Date(timestamp + utcOffset + _customTimezoneOffset);
	                    // If we've crossed a DST boundary with this calculation we need to
	                    // adjust the new date accordingly or it will be off by an hour in UTC.
	                    if (getTimestampToUtcOffsetFor(date) !== utcOffset) {
	                        var newUTCOffset = getTimestampToUtcOffsetFor(date);
	                        date = new Date(timestamp + newUTCOffset + _customTimezoneOffset);
	                    }
	                }
	            }

	            return _processFormat(format, date, _locale, timestamp);
	        }

	        function _processFormat(format, date, locale, timestamp) {
	            var resultString = '',
	                padding = null,
	                isInScope = false,
	                length = format.length,
	                extendedTZ = false;

	            for (var i = 0; i < length; i++) {

	                var currentCharCode = format.charCodeAt(i);

	                if (isInScope === true) {
	                    // '-'
	                    if (currentCharCode === 45) {
	                        padding = '';
	                        continue;
	                    }
	                    // '_'
	                    else if (currentCharCode === 95) {
	                        padding = ' ';
	                        continue;
	                    }
	                    // '0'
	                    else if (currentCharCode === 48) {
	                        padding = '0';
	                        continue;
	                    }
	                    // ':'
	                    else if (currentCharCode === 58) {
	                      if (extendedTZ) {
	                          warn("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
	                      }
	                      extendedTZ = true;
	                      continue;
	                    }

	                    switch (currentCharCode) {

	                        // Examples for new Date(0) in GMT

	                        // '%'
	                        // case '%':
	                        case 37:
	                            resultString += '%';
	                            break;

	                        // 'Thursday'
	                        // case 'A':
	                        case 65:
	                            resultString += locale.days[date.getDay()];
	                            break;

	                        // 'January'
	                        // case 'B':
	                        case 66:
	                            resultString += locale.months[date.getMonth()];
	                            break;

	                        // '19'
	                        // case 'C':
	                        case 67:
	                            resultString += padTill2(Math.floor(date.getFullYear() / 100), padding);
	                            break;

	                        // '01/01/70'
	                        // case 'D':
	                        case 68:
	                            resultString += _processFormat(locale.formats.D, date, locale, timestamp);
	                            break;

	                        // '1970-01-01'
	                        // case 'F':
	                        case 70:
	                            resultString += _processFormat(locale.formats.F, date, locale, timestamp);
	                            break;

	                        // '00'
	                        // case 'H':
	                        case 72:
	                            resultString += padTill2(date.getHours(), padding);
	                            break;

	                        // '12'
	                        // case 'I':
	                        case 73:
	                            resultString += padTill2(hours12(date.getHours()), padding);
	                            break;

	                        // '000'
	                        // case 'L':
	                        case 76:
	                            resultString += padTill3(Math.floor(timestamp % 1000));
	                            break;

	                        // '00'
	                        // case 'M':
	                        case 77:
	                            resultString += padTill2(date.getMinutes(), padding);
	                            break;

	                        // 'am'
	                        // case 'P':
	                        case 80:
	                            resultString += date.getHours() < 12 ? locale.am : locale.pm;
	                            break;

	                        // '00:00'
	                        // case 'R':
	                        case 82:
	                            resultString += _processFormat(locale.formats.R, date, locale, timestamp);
	                            break;

	                        // '00'
	                        // case 'S':
	                        case 83:
	                            resultString += padTill2(date.getSeconds(), padding);
	                            break;

	                        // '00:00:00'
	                        // case 'T':
	                        case 84:
	                            resultString += _processFormat(locale.formats.T, date, locale, timestamp);
	                            break;

	                        // '00'
	                        // case 'U':
	                        case 85:
	                            resultString += padTill2(weekNumber(date, 'sunday'), padding);
	                            break;

	                        // '00'
	                        // case 'W':
	                        case 87:
	                            resultString += padTill2(weekNumber(date, 'monday'), padding);
	                            break;

	                        // '16:00:00'
	                        // case 'X':
	                        case 88:
	                            resultString += _processFormat(locale.formats.X, date, locale, timestamp);
	                            break;

	                        // '1970'
	                        // case 'Y':
	                        case 89:
	                            resultString += date.getFullYear();
	                            break;

	                        // 'GMT'
	                        // case 'Z':
	                        case 90:
	                            if (_useUtcBasedDate && _customTimezoneOffset === 0) {
	                                resultString += "GMT";
	                            }
	                            else {
	                                // fixme optimize
	                                var tzString = date.toString().match(/\(([\w\s]+)\)/);
	                                resultString += tzString && tzString[1] || '';
	                            }
	                            break;

	                        // 'Thu'
	                        // case 'a':
	                        case 97:
	                            resultString += locale.shortDays[date.getDay()];
	                            break;

	                        // 'Jan'
	                        // case 'b':
	                        case 98:
	                            resultString += locale.shortMonths[date.getMonth()];
	                            break;

	                        // ''
	                        // case 'c':
	                        case 99:
	                            resultString += _processFormat(locale.formats.c, date, locale, timestamp);
	                            break;

	                        // '01'
	                        // case 'd':
	                        case 100:
	                            resultString += padTill2(date.getDate(), padding);
	                            break;

	                        // ' 1'
	                        // case 'e':
	                        case 101:
	                            resultString += padTill2(date.getDate(), padding == null ? ' ' : padding);
	                            break;

	                        // 'Jan'
	                        // case 'h':
	                        case 104:
	                            resultString += locale.shortMonths[date.getMonth()];
	                            break;

	                        // '000'
	                        // case 'j':
	                        case 106:
	                            var y = new Date(date.getFullYear(), 0, 1);
	                            var day = Math.ceil((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
	                            resultString += padTill3(day);
	                            break;

	                        // ' 0'
	                        // case 'k':
	                        case 107:
	                            resultString += padTill2(date.getHours(), padding == null ? ' ' : padding);
	                            break;

	                        // '12'
	                        // case 'l':
	                        case 108:
	                            resultString += padTill2(hours12(date.getHours()), padding == null ? ' ' : padding);
	                            break;

	                        // '01'
	                        // case 'm':
	                        case 109:
	                            resultString += padTill2(date.getMonth() + 1, padding);
	                            break;

	                        // '\n'
	                        // case 'n':
	                        case 110:
	                            resultString += '\n';
	                            break;

	                        // '1st'
	                        // case 'o':
	                        case 111:
	                            // Try to use an ordinal suffix from the locale, but fall back to using the old
	                            // function for compatibility with old locales that lack them.
	                            var day = date.getDate();
	                            if (locale.ordinalSuffixes) {
	                                resultString += String(day) + (locale.ordinalSuffixes[day - 1] || ordinal(day));
	                            }
	                            else {
	                                resultString += String(day) + ordinal(day);
	                            }
	                            break;

	                        // 'AM'
	                        // case 'p':
	                        case 112:
	                            resultString += date.getHours() < 12 ? locale.AM : locale.PM;
	                            break;

	                        // '12:00:00 AM'
	                        // case 'r':
	                        case 114:
	                            resultString += _processFormat(locale.formats.r, date, locale, timestamp);
	                            break;

	                        // '0'
	                        // case 's':
	                        case 115:
	                            resultString += Math.floor(timestamp / 1000);
	                            break;

	                        // '\t'
	                        // case 't':
	                        case 116:
	                            resultString += '\t';
	                            break;

	                        // '4'
	                        // case 'u':
	                        case 117:
	                            var day = date.getDay();
	                            resultString += day === 0 ? 7 : day;
	                            break; // 1 - 7, Monday is first day of the week

	                        // ' 1-Jan-1970'
	                        // case 'v':
	                        case 118:
	                            resultString += _processFormat(locale.formats.v, date, locale, timestamp);
	                            break;

	                        // '4'
	                        // case 'w':
	                        case 119:
	                            resultString += date.getDay();
	                            break; // 0 - 6, Sunday is first day of the week

	                        // '12/31/69'
	                        // case 'x':
	                        case 120:
	                            resultString += _processFormat(locale.formats.x, date, locale, timestamp);
	                            break;

	                        // '70'
	                        // case 'y':
	                        case 121:
	                            resultString += ('' + date.getFullYear()).slice(2);
	                            break;

	                        // '+0000'
	                        // case 'z':
	                        case 122:
	                            if (_useUtcBasedDate && _customTimezoneOffset === 0) {
	                                resultString += extendedTZ ? "+00:00" : "+0000";
	                            }
	                            else {
	                                var off;
	                                if (_customTimezoneOffset !== 0) {
	                                    off = _customTimezoneOffset / (60 * 1000);
	                                }
	                                else {
	                                    off = -date.getTimezoneOffset();
	                                }
	                                var sign = off < 0 ? '-' : '+';
	                                var sep = extendedTZ ? ':' : '';
	                                var hours = Math.floor(Math.abs(off / 60));
	                                var mins = Math.abs(off % 60);
	                                resultString += sign + padTill2(hours) + sep + padTill2(mins);
	                            }
	                            break;

	                        default:
	                            if (isInScope) {
	                                resultString += '%';
	                            }
	                            resultString += format[i];
	                            break;
	                    }

	                    padding = null;
	                    isInScope = false;
	                    continue;
	                }

	                // '%'
	                if (currentCharCode === 37) {
	                    isInScope = true;
	                    continue;
	                }

	                resultString += format[i];
	            }

	            return resultString;
	        }

	        var strftime = _strftime;

	        strftime.localize = function(locale) {
	            return new Strftime(locale || _locale, _customTimezoneOffset, _useUtcBasedDate);
	        };

	        strftime.localizeByIdentifier = function(localeIdentifier) {
	            var locale = Locales[localeIdentifier];
	            if (!locale) {
	                warn('[WARNING] No locale found with identifier "' + localeIdentifier + '".');
	                return strftime;
	            }
	            return strftime.localize(locale);
	        };

	        strftime.timezone = function(timezone) {
	            var customTimezoneOffset = _customTimezoneOffset;
	            var useUtcBasedDate = _useUtcBasedDate;

	            var timezoneType = typeof timezone;
	            if (timezoneType === 'number' || timezoneType === 'string') {
	                useUtcBasedDate = true;

	                // ISO 8601 format timezone string, [-+]HHMM
	                if (timezoneType === 'string') {
	                    var sign = timezone[0] === '-' ? -1 : 1,
	                        hours = parseInt(timezone.slice(1, 3), 10),
	                        minutes = parseInt(timezone.slice(3, 5), 10);

	                    customTimezoneOffset = sign * ((60 * hours) + minutes) * 60 * 1000;
	                    // in minutes: 420
	                }
	                else if (timezoneType === 'number') {
	                    customTimezoneOffset = timezone * 60 * 1000;
	                }
	            }

	            return new Strftime(_locale, customTimezoneOffset, useUtcBasedDate);
	        };

	        strftime.utc = function() {
	            return new Strftime(_locale, _customTimezoneOffset, true);
	        };

	        return strftime;
	    }

	    function padTill2(numberToPad, paddingChar) {
	        if (paddingChar === '' || numberToPad > 9) {
	            return numberToPad;
	        }
	        if (paddingChar == null) {
	            paddingChar = '0';
	        }
	        return paddingChar + numberToPad;
	    }

	    function padTill3(numberToPad) {
	        if (numberToPad > 99) {
	            return numberToPad;
	        }
	        if (numberToPad > 9) {
	            return '0' + numberToPad;
	        }
	        return '00' + numberToPad;
	    }

	    function hours12(hour) {
	        if (hour === 0) {
	            return 12;
	        }
	        else if (hour > 12) {
	            return hour - 12;
	        }
	        return hour;
	    }

	    // firstWeekday: 'sunday' or 'monday', default is 'sunday'
	    //
	    // Pilfered & ported from Ruby's strftime implementation.
	    function weekNumber(date, firstWeekday) {
	        firstWeekday = firstWeekday || 'sunday';

	        // This works by shifting the weekday back by one day if we
	        // are treating Monday as the first day of the week.
	        var weekday = date.getDay();
	        if (firstWeekday === 'monday') {
	            if (weekday === 0) // Sunday
	                weekday = 6;
	            else
	                weekday--;
	        }

	        var firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1),
	            dateUtc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
	            yday = Math.floor((dateUtc - firstDayOfYearUtc) / 86400000),
	            weekNum = (yday + 7 - weekday) / 7;

	        return Math.floor(weekNum);
	    }

	    // Get the ordinal suffix for a number: st, nd, rd, or th
	    function ordinal(number) {
	        var i = number % 10;
	        var ii = number % 100;

	        if ((ii >= 11 && ii <= 13) || i === 0 || i >= 4) {
	            return 'th';
	        }
	        switch (i) {
	            case 1: return 'st';
	            case 2: return 'nd';
	            case 3: return 'rd';
	        }
	    }

	    function getTimestampToUtcOffsetFor(date) {
	        return (date.getTimezoneOffset() || 0) * 60000;
	    }

	    function warn(message) {
	        if (typeof console !== 'undefined' && typeof console.warn == 'function') {
	            console.warn(message)
	        }
	    }

	}());


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Messages = undefined;

	var _mithril = __webpack_require__(1);

	var _mithril2 = _interopRequireDefault(_mithril);

	var _format = __webpack_require__(11);

	var format = _interopRequireWildcard(_format);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	var Messages = {
	    _messages: [],
	    _source: null,
	    _scrollTop: 0,
	    _updateScroll: true,

	    add: function add(msg) {
	        this._messages.push(this.normalizeMessage(msg));
	        _mithril2.default.redraw();
	    },
	    normalizeMessage: function normalizeMessage(msg) {
	        return {
	            timestamp: Date.parse(msg.timestamp),
	            severity: msg.msgid,
	            message: msg.msg
	        };
	    },
	    oninit: function oninit(vode) {
	        var _this = this;

	        this._source = new EventSource('/messages');
	        this._source.onmessage = function (event) {
	            _this.add(JSON.parse(event.data));
	        };
	    },
	    onupdate: function onupdate(vnode) {
	        var msgs = vnode.dom.getElementsByClassName('entry_container')[0];
	        if (this._updateScroll) {
	            this._scrollTop = msgs.scrollHeight;
	        }

	        msgs.scrollTop = this._scrollTop;
	    },
	    view: function view(vnode) {
	        var _this2 = this;

	        var rows = this._messages.map(function (msg) {
	            return (0, _mithril2.default)('div', { class: 'entry entry--' + msg.severity.toLowerCase() }, [(0, _mithril2.default)('div', { class: 'timestamp' }, format.datetime(msg.timestamp)), (0, _mithril2.default)('div', { class: 'severity' }, msg.severity), (0, _mithril2.default)('div', { class: 'message' }, msg.message)]);
	        });

	        var header = (0, _mithril2.default)('div', { class: 'entry entry--header' }, [(0, _mithril2.default)('div', { class: 'timestamp' }, 'Timestamp'), (0, _mithril2.default)('div', { class: 'severity' }, 'Severity'), (0, _mithril2.default)('div', { class: 'message' }, 'Message')]);

	        return (0, _mithril2.default)('bliss-messages', [header, (0, _mithril2.default)('div', {
	            class: 'entry_container',
	            onscroll: function onscroll(e) {
	                var msgs = vnode.dom.getElementsByClassName('entry_container')[0];
	                if (msgs.scrollTop == msgs.scrollHeight - msgs.clientHeight) {
	                    _this2._updateScroll = true;
	                } else {
	                    _this2._updateScroll = false;
	                    _this2._scrollTop = msgs.scrollTop;
	                }
	            }
	        }, rows)]);
	    }
	};

	exports.default = Messages;
	exports.Messages = Messages;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Plot = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Bespoke Link to Instruments and Small Satellites (BLISS)
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * RESERVED. United States Government Sponsorship acknowledged. Any
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * commercial use must be negotiated with the Office of Technology Transfer
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * at the California Institute of Technology.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This software may be subject to U.S. export control laws. By accepting
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * this software, the user agrees to comply with all applicable U.S. export
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * laws and regulations. User has the responsibility to obtain export licenses,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * or other export authority as may be required before exporting such
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * information to foreign countries or providing access to foreign persons.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	var _mithril = __webpack_require__(1);

	var _mithril2 = _interopRequireDefault(_mithril);

	var _dygraphs = __webpack_require__(163);

	var _dygraphs2 = _interopRequireDefault(_dygraphs);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*
	 * FIXME: The two Backend classes (Dygraphs and Highcharts) are not cleanly
	 * separated from the Plot class and need to be refactored.  There's far
	 * too much coupling.  This is because all functionality used to exist in
	 * Plot, but was *quickly* refactored to support multiple plot backends.
	 */

	var DygraphsBackend = function () {
	    function DygraphsBackend(plot) {
	        _classCallCheck(this, DygraphsBackend);

	        this._plot = plot;
	        this._plot_id = Math.random().toString();
	        this._user_specified_label = false;
	    }

	    _createClass(DygraphsBackend, [{
	        key: 'addSeries',
	        value: function addSeries(id, attrs) {
	            this._plot._options.labels.push(attrs.caption || attrs.name);
	        }
	    }, {
	        key: 'createChart',
	        value: function createChart(vnode, options) {
	            var startarray = [];
	            this._plot._options.labels.forEach(function (name) {
	                startarray.push(0);
	            });

	            // Dygraphs is being initialized off of a nested div within the
	            // bliss-plot tag so that displaying the legend in an external
	            // div works as expected. If the external div is nested within the
	            // same tag that Dygraph is initialized on then functionality breaks.
	            return new _dygraphs2.default(vnode.dom.children[0], [startarray], options);
	        }
	    }, {
	        key: 'createOptions',
	        value: function createOptions(attrs) {
	            // set window range
	            this._plotrange = attrs['plot-range'] || 600;

	            return {
	                drawPoints: true,
	                xlabel: 'Time (UTC)',
	                labels: ['Time'],
	                height: 500,
	                width: 800,
	                legend: 'always',
	                labelsSeparateLines: false,
	                labelsDiv: this._plot_id,
	                showRangeSelector: true
	            };
	        }
	    }, {
	        key: 'handleOptionsOverride',
	        value: function handleOptionsOverride(options, overrides) {
	            Object.assign(options, overrides);

	            if ('labelsDiv' in overrides) {
	                this._plot_id = overrides['labelsDiv'];
	                this._user_specified_label = true;
	            }
	        }
	    }, {
	        key: 'plot',
	        value: function plot(packet) {
	            var pname = packet._defn.name;
	            var names = this._plot._packets[pname];

	            if (!names) return;

	            var row = [this._plot._time.get(packet)];

	            names.forEach(function (name) {
	                row.push(packet.__get__(name));
	            });

	            this._plot._data.push(row);

	            // If we get too many records, start to pop off the array
	            // This is only way I can see to set a moving window
	            if (this._plot._data.length > this._plotrange) {
	                this._plot._data.shift();
	            }

	            this._plot._chart.updateOptions({ 'file': this._plot._data });
	        }
	    }]);

	    return DygraphsBackend;
	}();

	var HighchartsBackend = function () {
	    function HighchartsBackend(plot) {
	        _classCallCheck(this, HighchartsBackend);

	        this._plot = plot;
	    }

	    _createClass(HighchartsBackend, [{
	        key: 'addSeries',
	        value: function addSeries(id, attrs) {
	            this._plot._options.series.push({
	                id: id,
	                name: attrs.caption || id,
	                color: attrs.color,
	                data: [],
	                tooltip: { valueDecimals: 2 },
	                type: attrs.type,
	                showInNavigator: true,
	                boostThreshold: 1,

	                // When the series contains less points than the crop threshold,
	                // all points are drawn, even if the points fall outside the
	                // visible plot area at the current zoom.
	                cropThreshold: 1,

	                // When a series contains a data array that is longer than this,
	                // only one dimensional arrays of numbers, or two dimensional
	                // arrays with x and y values are allowed. Also, only the first
	                // point is tested, and the rest are assumed to be the same format.
	                turboThreshold: 1
	            });
	        }
	    }, {
	        key: 'createChart',
	        value: function createChart(vnode, options) {
	            return new Highcharts.StockChart(vnode.dom, options);
	        }
	    }, {
	        key: 'createOptions',
	        value: function createOptions(attrs) {
	            return {
	                credits: {
	                    enabled: false
	                },

	                legend: {
	                    enabled: true
	                },

	                boost: {
	                    seriesThreshold: 1
	                },

	                /*
	                 * "Maximum Performance" series plot options that removes all
	                 * extra functionality to squeeze out a bit of performance.
	                 */
	                //plotOptions: {
	                //    series: { animation: false, enableMouseTracking: false, stickyTracking: true, shadow: false, dataLabels: { style: { textShadow: false } } },
	                //},

	                rangeSelector: {
	                    buttons: [{ count: 1, text: '1m', type: 'minute' }, { count: 10, text: '10m', type: 'minute' }, { count: 30, text: '30m', type: 'minute' }, { count: 1, text: '1h', type: 'hour' }, { count: 6, text: '6h', type: 'hour' }, { count: 12, text: '12h', type: 'hour' }, { count: 1, text: '1d', type: 'day' }],
	                    inputEnabled: false
	                },

	                series: [],

	                title: {
	                    text: attrs.title
	                },

	                xAxis: {
	                    title: { text: 'Time (UTC)' }
	                },

	                yAxis: {
	                    title: { text: attrs['y-title'] }
	                }
	            };
	        }
	    }, {
	        key: 'handleOptionsOverride',
	        value: function handleOptionsOverride(options, overrides) {
	            Object.assign(options, overrides);
	        }
	    }, {
	        key: 'plot',
	        value: function plot(packet) {
	            var _this = this;

	            var pname = packet._defn.name;
	            var names = this._plot._packets[pname];
	            if (!names) return;

	            names.forEach(function (name) {
	                var series = _this._plot._chart.get(pname + '.' + name);

	                if (series) {
	                    var x = _this._plot._time.get(packet).getTime();
	                    var y = packet.__get__(name);

	                    series.addPoint([x, y], false);

	                    // Zoom axis once after data spans 60 seconds
	                    if (_this._plot._initZoom === false) {
	                        var extremes = _this._plot._chart.axes[0].getExtremes();
	                        var duration = (extremes.max - extremes.min) / 1e3;

	                        if (duration >= 60) {
	                            _this._plot._chart.rangeSelector.clickButton(0, true);
	                            _this._plot._initZoom = true;
	                        }
	                    }
	                }
	            });
	            this._plot._chart.redraw();
	        }
	    }]);

	    return HighchartsBackend;
	}();

	var Plot = {
	    /**
	     * Plots data from the given packet.
	     */
	    plot: function plot(packet) {
	        this._backend.plot(packet);
	    },


	    /**
	     * Processes a `<bliss-plot-xxx>` tag by dispatching to the
	     * appropriate `processTagXXX()` method.
	     */
	    processTag: function processTag(vnode) {
	        if (vnode.tag === 'bliss-plotconfig') {
	            this._backend.handleOptionsOverride(this._options, JSON.parse(vnode.text));
	        } else if (vnode.tag === 'bliss-plotseries') {
	            this.processTagSeries(vnode);
	        } else if (vnode.tag === 'bliss-plottime') {
	            this.processTagTime(vnode);
	        }
	    },


	    /**
	     * Process tag: `<bliss-plot-series type="..." caption="..." ...>`.
	     */
	    processTagSeries: function processTagSeries(vnode) {
	        var name = vnode.attrs.name;
	        var packet = vnode.attrs.packet;
	        var type = vnode.attrs.type;
	        var id = packet + '.' + name;

	        this._backend.addSeries(id, vnode.attrs);

	        // For each packet, maintain a list of fields to plot
	        this._packets[packet] = this._packets[packet] || [];
	        this._packets[packet].push(name);
	    },


	    /**
	     * Process tag: `<bliss-plot-time packet="..." name="...">`.
	     */
	    processTagTime: function processTagTime(vnode) {
	        this._time = new PlotTimeField(vnode.attrs.packet, vnode.attrs.name);
	    },


	    // Mithril lifecycle method
	    oninit: function oninit(vnode) {
	        var _this2 = this;

	        this._backend = window.Highcharts ? new HighchartsBackend(this) : new DygraphsBackend(this);

	        this._data = [];
	        this._options = this._backend.createOptions(vnode.attrs);
	        this._packets = {};
	        this._time = null;
	        this._initZoom = false;

	        vnode.children.forEach(function (child) {
	            return _this2.processTag(child);
	        });

	        if (this._time === null) {
	            this._time = new PlotTimeField();
	        }

	        bliss.events.on('bliss:tlm:packet', function (p) {
	            return _this2.plot(p);
	        });
	    },


	    // Mithril lifecycle method
	    oncreate: function oncreate(vnode) {
	        this._chart = this._backend.createChart(vnode, this._options);
	    },


	    // Mithril lifecycle method
	    view: function view(vnode) {
	        if (window.Highcharts) {
	            return (0, _mithril2.default)('bliss-plot', vnode.attrs);
	        } else {
	            var plot_contents = [(0, _mithril2.default)('div')];

	            if (!this._backend._user_specified_label) {
	                plot_contents.push((0, _mithril2.default)('div', {
	                    id: this._backend._plot_id,
	                    class: 'dygraph-legend',
	                    style: 'width: ' + this._options['width'] + 'px;'
	                }));
	            }

	            return (0, _mithril2.default)('bliss-plot', vnode.attrs, plot_contents);
	        }
	    }
	};

	/**
	 * PlotTimeField
	 *
	 * A :class:`PlotTimeField` identifies a packet and constituent field
	 * (by name) to use for the the time axis in BLISS plots.  If the
	 * packet name, field name, or resulting field value are invalid
	 * (e.g. not a number or Javascript :class:`Date`), the current time
	 * will be used.
	 *
	 * An empty :class:`PlotTimeField` will always return `Date()`, i.e.:
	 *
	 * .. code-block:: javascript
	 *
	 *     new PlotTimeField().get(packet) === new Date()
	 */

	var PlotTimeField = function () {
	    /**
	     * Creates a new :class:`PlotTimeField` with the given packet name
	     * and field name.
	     */
	    function PlotTimeField() {
	        var pname = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	        var fname = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	        _classCallCheck(this, PlotTimeField);

	        this._pname = pname;
	        this._fname = fname;
	    }

	    /**
	     * @returns the plot time for the current BLISS packet or new Date().
	     */


	    _createClass(PlotTimeField, [{
	        key: 'get',
	        value: function get(packet) {
	            var time = this.hasTime(packet) ? packet.__get__(this._fname) : null;

	            if (!(time instanceof Date)) {
	                if (typeof time !== 'number') {
	                    time = new Date();
	                } else {
	                    time = new Date(time);
	                }
	            }

	            return time;
	        }

	        /**
	         * @returns ``true`` or ``false`` to indicate whether or not the
	         * given packet has the field referenced by this
	         * :class:`PlotTimeField`.
	         */

	    }, {
	        key: 'hasTime',
	        value: function hasTime(packet) {
	            var defn = packet && packet._defn;
	            return defn && this._pname === defn.name && this._fname in defn.fields;
	        }
	    }]);

	    return PlotTimeField;
	}();

	exports.default = Plot;
	exports.Plot = Plot;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(164);



/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * @license
	 * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview Creates an interactive, zoomable graph based on a CSV file or
	 * string. Dygraph can handle multiple series with or without error bars. The
	 * date/value ranges will be automatically set. Dygraph uses the
	 * &lt;canvas&gt; tag, so it only works in FF1.5+.
	 * @author danvdk@gmail.com (Dan Vanderkam)

	  Usage:
	   <div id="graphdiv" style="width:800px; height:500px;"></div>
	   <script type="text/javascript">
	     new Dygraph(document.getElementById("graphdiv"),
	                 "datafile.csv",  // CSV file with headers
	                 { }); // options
	   </script>

	 The CSV file is of the form

	   Date,SeriesA,SeriesB,SeriesC
	   YYYYMMDD,A1,B1,C1
	   YYYYMMDD,A2,B2,C2

	 If the 'errorBars' option is set in the constructor, the input should be of
	 the form
	   Date,SeriesA,SeriesB,...
	   YYYYMMDD,A1,sigmaA1,B1,sigmaB1,...
	   YYYYMMDD,A2,sigmaA2,B2,sigmaB2,...

	 If the 'fractions' option is set, the input should be of the form:

	   Date,SeriesA,SeriesB,...
	   YYYYMMDD,A1/B1,A2/B2,...
	   YYYYMMDD,A1/B1,A2/B2,...

	 And error bars will be calculated automatically using a binomial distribution.

	 For further documentation and examples, see http://dygraphs.com/
	 */

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _dygraphLayout = __webpack_require__(165);

	var _dygraphLayout2 = _interopRequireDefault(_dygraphLayout);

	var _dygraphCanvas = __webpack_require__(168);

	var _dygraphCanvas2 = _interopRequireDefault(_dygraphCanvas);

	var _dygraphOptions = __webpack_require__(169);

	var _dygraphOptions2 = _interopRequireDefault(_dygraphOptions);

	var _dygraphInteractionModel = __webpack_require__(171);

	var _dygraphInteractionModel2 = _interopRequireDefault(_dygraphInteractionModel);

	var _dygraphTickers = __webpack_require__(167);

	var DygraphTickers = _interopRequireWildcard(_dygraphTickers);

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	var _dygraphDefaultAttrs = __webpack_require__(170);

	var _dygraphDefaultAttrs2 = _interopRequireDefault(_dygraphDefaultAttrs);

	var _dygraphOptionsReference = __webpack_require__(172);

	var _dygraphOptionsReference2 = _interopRequireDefault(_dygraphOptionsReference);

	var _iframeTarp = __webpack_require__(173);

	var _iframeTarp2 = _interopRequireDefault(_iframeTarp);

	var _datahandlerDefault = __webpack_require__(174);

	var _datahandlerDefault2 = _interopRequireDefault(_datahandlerDefault);

	var _datahandlerBarsError = __webpack_require__(176);

	var _datahandlerBarsError2 = _interopRequireDefault(_datahandlerBarsError);

	var _datahandlerBarsCustom = __webpack_require__(178);

	var _datahandlerBarsCustom2 = _interopRequireDefault(_datahandlerBarsCustom);

	var _datahandlerDefaultFractions = __webpack_require__(179);

	var _datahandlerDefaultFractions2 = _interopRequireDefault(_datahandlerDefaultFractions);

	var _datahandlerBarsFractions = __webpack_require__(180);

	var _datahandlerBarsFractions2 = _interopRequireDefault(_datahandlerBarsFractions);

	var _datahandlerBars = __webpack_require__(177);

	var _datahandlerBars2 = _interopRequireDefault(_datahandlerBars);

	var _pluginsAnnotations = __webpack_require__(181);

	var _pluginsAnnotations2 = _interopRequireDefault(_pluginsAnnotations);

	var _pluginsAxes = __webpack_require__(182);

	var _pluginsAxes2 = _interopRequireDefault(_pluginsAxes);

	var _pluginsChartLabels = __webpack_require__(183);

	var _pluginsChartLabels2 = _interopRequireDefault(_pluginsChartLabels);

	var _pluginsGrid = __webpack_require__(184);

	var _pluginsGrid2 = _interopRequireDefault(_pluginsGrid);

	var _pluginsLegend = __webpack_require__(185);

	var _pluginsLegend2 = _interopRequireDefault(_pluginsLegend);

	var _pluginsRangeSelector = __webpack_require__(186);

	var _pluginsRangeSelector2 = _interopRequireDefault(_pluginsRangeSelector);

	var _dygraphGviz = __webpack_require__(187);

	var _dygraphGviz2 = _interopRequireDefault(_dygraphGviz);

	"use strict";

	/**
	 * Creates an interactive, zoomable chart.
	 *
	 * @constructor
	 * @param {div | String} div A div or the id of a div into which to construct
	 * the chart.
	 * @param {String | Function} file A file containing CSV data or a function
	 * that returns this data. The most basic expected format for each line is
	 * "YYYY/MM/DD,val1,val2,...". For more information, see
	 * http://dygraphs.com/data.html.
	 * @param {Object} attrs Various other attributes, e.g. errorBars determines
	 * whether the input data contains error ranges. For a complete list of
	 * options, see http://dygraphs.com/options.html.
	 */
	var Dygraph = function Dygraph(div, data, opts) {
	  this.__init__(div, data, opts);
	};

	Dygraph.NAME = "Dygraph";
	Dygraph.VERSION = "2.0.0";

	// Various default values
	Dygraph.DEFAULT_ROLL_PERIOD = 1;
	Dygraph.DEFAULT_WIDTH = 480;
	Dygraph.DEFAULT_HEIGHT = 320;

	// For max 60 Hz. animation:
	Dygraph.ANIMATION_STEPS = 12;
	Dygraph.ANIMATION_DURATION = 200;

	/**
	 * Standard plotters. These may be used by clients.
	 * Available plotters are:
	 * - Dygraph.Plotters.linePlotter: draws central lines (most common)
	 * - Dygraph.Plotters.errorPlotter: draws error bars
	 * - Dygraph.Plotters.fillPlotter: draws fills under lines (used with fillGraph)
	 *
	 * By default, the plotter is [fillPlotter, errorPlotter, linePlotter].
	 * This causes all the lines to be drawn over all the fills/error bars.
	 */
	Dygraph.Plotters = _dygraphCanvas2['default']._Plotters;

	// Used for initializing annotation CSS rules only once.
	Dygraph.addedAnnotationCSS = false;

	/**
	 * Initializes the Dygraph. This creates a new DIV and constructs the PlotKit
	 * and context &lt;canvas&gt; inside of it. See the constructor for details.
	 * on the parameters.
	 * @param {Element} div the Element to render the graph into.
	 * @param {string | Function} file Source data
	 * @param {Object} attrs Miscellaneous other options
	 * @private
	 */
	Dygraph.prototype.__init__ = function (div, file, attrs) {
	  this.is_initial_draw_ = true;
	  this.readyFns_ = [];

	  // Support two-argument constructor
	  if (attrs === null || attrs === undefined) {
	    attrs = {};
	  }

	  attrs = Dygraph.copyUserAttrs_(attrs);

	  if (typeof div == 'string') {
	    div = document.getElementById(div);
	  }

	  if (!div) {
	    throw new Error('Constructing dygraph with a non-existent div!');
	  }

	  // Copy the important bits into the object
	  // TODO(danvk): most of these should just stay in the attrs_ dictionary.
	  this.maindiv_ = div;
	  this.file_ = file;
	  this.rollPeriod_ = attrs.rollPeriod || Dygraph.DEFAULT_ROLL_PERIOD;
	  this.previousVerticalX_ = -1;
	  this.fractions_ = attrs.fractions || false;
	  this.dateWindow_ = attrs.dateWindow || null;

	  this.annotations_ = [];

	  // Clear the div. This ensure that, if multiple dygraphs are passed the same
	  // div, then only one will be drawn.
	  div.innerHTML = "";

	  // For historical reasons, the 'width' and 'height' options trump all CSS
	  // rules _except_ for an explicit 'width' or 'height' on the div.
	  // As an added convenience, if the div has zero height (like <div></div> does
	  // without any styles), then we use a default height/width.
	  if (div.style.width === '' && attrs.width) {
	    div.style.width = attrs.width + "px";
	  }
	  if (div.style.height === '' && attrs.height) {
	    div.style.height = attrs.height + "px";
	  }
	  if (div.style.height === '' && div.clientHeight === 0) {
	    div.style.height = Dygraph.DEFAULT_HEIGHT + "px";
	    if (div.style.width === '') {
	      div.style.width = Dygraph.DEFAULT_WIDTH + "px";
	    }
	  }
	  // These will be zero if the dygraph's div is hidden. In that case,
	  // use the user-specified attributes if present. If not, use zero
	  // and assume the user will call resize to fix things later.
	  this.width_ = div.clientWidth || attrs.width || 0;
	  this.height_ = div.clientHeight || attrs.height || 0;

	  // TODO(danvk): set fillGraph to be part of attrs_ here, not user_attrs_.
	  if (attrs.stackedGraph) {
	    attrs.fillGraph = true;
	    // TODO(nikhilk): Add any other stackedGraph checks here.
	  }

	  // DEPRECATION WARNING: All option processing should be moved from
	  // attrs_ and user_attrs_ to options_, which holds all this information.
	  //
	  // Dygraphs has many options, some of which interact with one another.
	  // To keep track of everything, we maintain two sets of options:
	  //
	  //  this.user_attrs_   only options explicitly set by the user.
	  //  this.attrs_        defaults, options derived from user_attrs_, data.
	  //
	  // Options are then accessed this.attr_('attr'), which first looks at
	  // user_attrs_ and then computed attrs_. This way Dygraphs can set intelligent
	  // defaults without overriding behavior that the user specifically asks for.
	  this.user_attrs_ = {};
	  utils.update(this.user_attrs_, attrs);

	  // This sequence ensures that Dygraph.DEFAULT_ATTRS is never modified.
	  this.attrs_ = {};
	  utils.updateDeep(this.attrs_, _dygraphDefaultAttrs2['default']);

	  this.boundaryIds_ = [];
	  this.setIndexByName_ = {};
	  this.datasetIndex_ = [];

	  this.registeredEvents_ = [];
	  this.eventListeners_ = {};

	  this.attributes_ = new _dygraphOptions2['default'](this);

	  // Create the containing DIV and other interactive elements
	  this.createInterface_();

	  // Activate plugins.
	  this.plugins_ = [];
	  var plugins = Dygraph.PLUGINS.concat(this.getOption('plugins'));
	  for (var i = 0; i < plugins.length; i++) {
	    // the plugins option may contain either plugin classes or instances.
	    // Plugin instances contain an activate method.
	    var Plugin = plugins[i]; // either a constructor or an instance.
	    var pluginInstance;
	    if (typeof Plugin.activate !== 'undefined') {
	      pluginInstance = Plugin;
	    } else {
	      pluginInstance = new Plugin();
	    }

	    var pluginDict = {
	      plugin: pluginInstance,
	      events: {},
	      options: {},
	      pluginOptions: {}
	    };

	    var handlers = pluginInstance.activate(this);
	    for (var eventName in handlers) {
	      if (!handlers.hasOwnProperty(eventName)) continue;
	      // TODO(danvk): validate eventName.
	      pluginDict.events[eventName] = handlers[eventName];
	    }

	    this.plugins_.push(pluginDict);
	  }

	  // At this point, plugins can no longer register event handlers.
	  // Construct a map from event -> ordered list of [callback, plugin].
	  for (var i = 0; i < this.plugins_.length; i++) {
	    var plugin_dict = this.plugins_[i];
	    for (var eventName in plugin_dict.events) {
	      if (!plugin_dict.events.hasOwnProperty(eventName)) continue;
	      var callback = plugin_dict.events[eventName];

	      var pair = [plugin_dict.plugin, callback];
	      if (!(eventName in this.eventListeners_)) {
	        this.eventListeners_[eventName] = [pair];
	      } else {
	        this.eventListeners_[eventName].push(pair);
	      }
	    }
	  }

	  this.createDragInterface_();

	  this.start_();
	};

	/**
	 * Triggers a cascade of events to the various plugins which are interested in them.
	 * Returns true if the "default behavior" should be prevented, i.e. if one
	 * of the event listeners called event.preventDefault().
	 * @private
	 */
	Dygraph.prototype.cascadeEvents_ = function (name, extra_props) {
	  if (!(name in this.eventListeners_)) return false;

	  // QUESTION: can we use objects & prototypes to speed this up?
	  var e = {
	    dygraph: this,
	    cancelable: false,
	    defaultPrevented: false,
	    preventDefault: function preventDefault() {
	      if (!e.cancelable) throw "Cannot call preventDefault on non-cancelable event.";
	      e.defaultPrevented = true;
	    },
	    propagationStopped: false,
	    stopPropagation: function stopPropagation() {
	      e.propagationStopped = true;
	    }
	  };
	  utils.update(e, extra_props);

	  var callback_plugin_pairs = this.eventListeners_[name];
	  if (callback_plugin_pairs) {
	    for (var i = callback_plugin_pairs.length - 1; i >= 0; i--) {
	      var plugin = callback_plugin_pairs[i][0];
	      var callback = callback_plugin_pairs[i][1];
	      callback.call(plugin, e);
	      if (e.propagationStopped) break;
	    }
	  }
	  return e.defaultPrevented;
	};

	/**
	 * Fetch a plugin instance of a particular class. Only for testing.
	 * @private
	 * @param {!Class} type The type of the plugin.
	 * @return {Object} Instance of the plugin, or null if there is none.
	 */
	Dygraph.prototype.getPluginInstance_ = function (type) {
	  for (var i = 0; i < this.plugins_.length; i++) {
	    var p = this.plugins_[i];
	    if (p.plugin instanceof type) {
	      return p.plugin;
	    }
	  }
	  return null;
	};

	/**
	 * Returns the zoomed status of the chart for one or both axes.
	 *
	 * Axis is an optional parameter. Can be set to 'x' or 'y'.
	 *
	 * The zoomed status for an axis is set whenever a user zooms using the mouse
	 * or when the dateWindow or valueRange are updated. Double-clicking or calling
	 * resetZoom() resets the zoom status for the chart.
	 */
	Dygraph.prototype.isZoomed = function (axis) {
	  var isZoomedX = !!this.dateWindow_;
	  if (axis === 'x') return isZoomedX;

	  var isZoomedY = this.axes_.map(function (axis) {
	    return !!axis.valueRange;
	  }).indexOf(true) >= 0;
	  if (axis === null || axis === undefined) {
	    return isZoomedX || isZoomedY;
	  }
	  if (axis === 'y') return isZoomedY;

	  throw new Error('axis parameter is [' + axis + '] must be null, \'x\' or \'y\'.');
	};

	/**
	 * Returns information about the Dygraph object, including its containing ID.
	 */
	Dygraph.prototype.toString = function () {
	  var maindiv = this.maindiv_;
	  var id = maindiv && maindiv.id ? maindiv.id : maindiv;
	  return "[Dygraph " + id + "]";
	};

	/**
	 * @private
	 * Returns the value of an option. This may be set by the user (either in the
	 * constructor or by calling updateOptions) or by dygraphs, and may be set to a
	 * per-series value.
	 * @param {string} name The name of the option, e.g. 'rollPeriod'.
	 * @param {string} [seriesName] The name of the series to which the option
	 * will be applied. If no per-series value of this option is available, then
	 * the global value is returned. This is optional.
	 * @return { ... } The value of the option.
	 */
	Dygraph.prototype.attr_ = function (name, seriesName) {
	  // For "production" code, this gets removed by uglifyjs.
	  if (typeof process !== 'undefined') {
	    if (process.env.NODE_ENV != 'production') {
	      if (typeof _dygraphOptionsReference2['default'] === 'undefined') {
	        console.error('Must include options reference JS for testing');
	      } else if (!_dygraphOptionsReference2['default'].hasOwnProperty(name)) {
	        console.error('Dygraphs is using property ' + name + ', which has no ' + 'entry in the Dygraphs.OPTIONS_REFERENCE listing.');
	        // Only log this error once.
	        _dygraphOptionsReference2['default'][name] = true;
	      }
	    }
	  }
	  return seriesName ? this.attributes_.getForSeries(name, seriesName) : this.attributes_.get(name);
	};

	/**
	 * Returns the current value for an option, as set in the constructor or via
	 * updateOptions. You may pass in an (optional) series name to get per-series
	 * values for the option.
	 *
	 * All values returned by this method should be considered immutable. If you
	 * modify them, there is no guarantee that the changes will be honored or that
	 * dygraphs will remain in a consistent state. If you want to modify an option,
	 * use updateOptions() instead.
	 *
	 * @param {string} name The name of the option (e.g. 'strokeWidth')
	 * @param {string=} opt_seriesName Series name to get per-series values.
	 * @return {*} The value of the option.
	 */
	Dygraph.prototype.getOption = function (name, opt_seriesName) {
	  return this.attr_(name, opt_seriesName);
	};

	/**
	 * Like getOption(), but specifically returns a number.
	 * This is a convenience function for working with the Closure Compiler.
	 * @param {string} name The name of the option (e.g. 'strokeWidth')
	 * @param {string=} opt_seriesName Series name to get per-series values.
	 * @return {number} The value of the option.
	 * @private
	 */
	Dygraph.prototype.getNumericOption = function (name, opt_seriesName) {
	  return (/** @type{number} */this.getOption(name, opt_seriesName)
	  );
	};

	/**
	 * Like getOption(), but specifically returns a string.
	 * This is a convenience function for working with the Closure Compiler.
	 * @param {string} name The name of the option (e.g. 'strokeWidth')
	 * @param {string=} opt_seriesName Series name to get per-series values.
	 * @return {string} The value of the option.
	 * @private
	 */
	Dygraph.prototype.getStringOption = function (name, opt_seriesName) {
	  return (/** @type{string} */this.getOption(name, opt_seriesName)
	  );
	};

	/**
	 * Like getOption(), but specifically returns a boolean.
	 * This is a convenience function for working with the Closure Compiler.
	 * @param {string} name The name of the option (e.g. 'strokeWidth')
	 * @param {string=} opt_seriesName Series name to get per-series values.
	 * @return {boolean} The value of the option.
	 * @private
	 */
	Dygraph.prototype.getBooleanOption = function (name, opt_seriesName) {
	  return (/** @type{boolean} */this.getOption(name, opt_seriesName)
	  );
	};

	/**
	 * Like getOption(), but specifically returns a function.
	 * This is a convenience function for working with the Closure Compiler.
	 * @param {string} name The name of the option (e.g. 'strokeWidth')
	 * @param {string=} opt_seriesName Series name to get per-series values.
	 * @return {function(...)} The value of the option.
	 * @private
	 */
	Dygraph.prototype.getFunctionOption = function (name, opt_seriesName) {
	  return (/** @type{function(...)} */this.getOption(name, opt_seriesName)
	  );
	};

	Dygraph.prototype.getOptionForAxis = function (name, axis) {
	  return this.attributes_.getForAxis(name, axis);
	};

	/**
	 * @private
	 * @param {string} axis The name of the axis (i.e. 'x', 'y' or 'y2')
	 * @return { ... } A function mapping string -> option value
	 */
	Dygraph.prototype.optionsViewForAxis_ = function (axis) {
	  var self = this;
	  return function (opt) {
	    var axis_opts = self.user_attrs_.axes;
	    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {
	      return axis_opts[axis][opt];
	    }

	    // I don't like that this is in a second spot.
	    if (axis === 'x' && opt === 'logscale') {
	      // return the default value.
	      // TODO(konigsberg): pull the default from a global default.
	      return false;
	    }

	    // user-specified attributes always trump defaults, even if they're less
	    // specific.
	    if (typeof self.user_attrs_[opt] != 'undefined') {
	      return self.user_attrs_[opt];
	    }

	    axis_opts = self.attrs_.axes;
	    if (axis_opts && axis_opts[axis] && axis_opts[axis].hasOwnProperty(opt)) {
	      return axis_opts[axis][opt];
	    }
	    // check old-style axis options
	    // TODO(danvk): add a deprecation warning if either of these match.
	    if (axis == 'y' && self.axes_[0].hasOwnProperty(opt)) {
	      return self.axes_[0][opt];
	    } else if (axis == 'y2' && self.axes_[1].hasOwnProperty(opt)) {
	      return self.axes_[1][opt];
	    }
	    return self.attr_(opt);
	  };
	};

	/**
	 * Returns the current rolling period, as set by the user or an option.
	 * @return {number} The number of points in the rolling window
	 */
	Dygraph.prototype.rollPeriod = function () {
	  return this.rollPeriod_;
	};

	/**
	 * Returns the currently-visible x-range. This can be affected by zooming,
	 * panning or a call to updateOptions.
	 * Returns a two-element array: [left, right].
	 * If the Dygraph has dates on the x-axis, these will be millis since epoch.
	 */
	Dygraph.prototype.xAxisRange = function () {
	  return this.dateWindow_ ? this.dateWindow_ : this.xAxisExtremes();
	};

	/**
	 * Returns the lower- and upper-bound x-axis values of the data set.
	 */
	Dygraph.prototype.xAxisExtremes = function () {
	  var pad = this.getNumericOption('xRangePad') / this.plotter_.area.w;
	  if (this.numRows() === 0) {
	    return [0 - pad, 1 + pad];
	  }
	  var left = this.rawData_[0][0];
	  var right = this.rawData_[this.rawData_.length - 1][0];
	  if (pad) {
	    // Must keep this in sync with dygraph-layout _evaluateLimits()
	    var range = right - left;
	    left -= range * pad;
	    right += range * pad;
	  }
	  return [left, right];
	};

	/**
	 * Returns the lower- and upper-bound y-axis values for each axis. These are
	 * the ranges you'll get if you double-click to zoom out or call resetZoom().
	 * The return value is an array of [low, high] tuples, one for each y-axis.
	 */
	Dygraph.prototype.yAxisExtremes = function () {
	  // TODO(danvk): this is pretty inefficient
	  var packed = this.gatherDatasets_(this.rolledSeries_, null);
	  var extremes = packed.extremes;

	  var saveAxes = this.axes_;
	  this.computeYAxisRanges_(extremes);
	  var newAxes = this.axes_;
	  this.axes_ = saveAxes;
	  return newAxes.map(function (axis) {
	    return axis.extremeRange;
	  });
	};

	/**
	 * Returns the currently-visible y-range for an axis. This can be affected by
	 * zooming, panning or a call to updateOptions. Axis indices are zero-based. If
	 * called with no arguments, returns the range of the first axis.
	 * Returns a two-element array: [bottom, top].
	 */
	Dygraph.prototype.yAxisRange = function (idx) {
	  if (typeof idx == "undefined") idx = 0;
	  if (idx < 0 || idx >= this.axes_.length) {
	    return null;
	  }
	  var axis = this.axes_[idx];
	  return [axis.computedValueRange[0], axis.computedValueRange[1]];
	};

	/**
	 * Returns the currently-visible y-ranges for each axis. This can be affected by
	 * zooming, panning, calls to updateOptions, etc.
	 * Returns an array of [bottom, top] pairs, one for each y-axis.
	 */
	Dygraph.prototype.yAxisRanges = function () {
	  var ret = [];
	  for (var i = 0; i < this.axes_.length; i++) {
	    ret.push(this.yAxisRange(i));
	  }
	  return ret;
	};

	// TODO(danvk): use these functions throughout dygraphs.
	/**
	 * Convert from data coordinates to canvas/div X/Y coordinates.
	 * If specified, do this conversion for the coordinate system of a particular
	 * axis. Uses the first axis by default.
	 * Returns a two-element array: [X, Y]
	 *
	 * Note: use toDomXCoord instead of toDomCoords(x, null) and use toDomYCoord
	 * instead of toDomCoords(null, y, axis).
	 */
	Dygraph.prototype.toDomCoords = function (x, y, axis) {
	  return [this.toDomXCoord(x), this.toDomYCoord(y, axis)];
	};

	/**
	 * Convert from data x coordinates to canvas/div X coordinate.
	 * If specified, do this conversion for the coordinate system of a particular
	 * axis.
	 * Returns a single value or null if x is null.
	 */
	Dygraph.prototype.toDomXCoord = function (x) {
	  if (x === null) {
	    return null;
	  }

	  var area = this.plotter_.area;
	  var xRange = this.xAxisRange();
	  return area.x + (x - xRange[0]) / (xRange[1] - xRange[0]) * area.w;
	};

	/**
	 * Convert from data x coordinates to canvas/div Y coordinate and optional
	 * axis. Uses the first axis by default.
	 *
	 * returns a single value or null if y is null.
	 */
	Dygraph.prototype.toDomYCoord = function (y, axis) {
	  var pct = this.toPercentYCoord(y, axis);

	  if (pct === null) {
	    return null;
	  }
	  var area = this.plotter_.area;
	  return area.y + pct * area.h;
	};

	/**
	 * Convert from canvas/div coords to data coordinates.
	 * If specified, do this conversion for the coordinate system of a particular
	 * axis. Uses the first axis by default.
	 * Returns a two-element array: [X, Y].
	 *
	 * Note: use toDataXCoord instead of toDataCoords(x, null) and use toDataYCoord
	 * instead of toDataCoords(null, y, axis).
	 */
	Dygraph.prototype.toDataCoords = function (x, y, axis) {
	  return [this.toDataXCoord(x), this.toDataYCoord(y, axis)];
	};

	/**
	 * Convert from canvas/div x coordinate to data coordinate.
	 *
	 * If x is null, this returns null.
	 */
	Dygraph.prototype.toDataXCoord = function (x) {
	  if (x === null) {
	    return null;
	  }

	  var area = this.plotter_.area;
	  var xRange = this.xAxisRange();

	  if (!this.attributes_.getForAxis("logscale", 'x')) {
	    return xRange[0] + (x - area.x) / area.w * (xRange[1] - xRange[0]);
	  } else {
	    var pct = (x - area.x) / area.w;
	    return utils.logRangeFraction(xRange[0], xRange[1], pct);
	  }
	};

	/**
	 * Convert from canvas/div y coord to value.
	 *
	 * If y is null, this returns null.
	 * if axis is null, this uses the first axis.
	 */
	Dygraph.prototype.toDataYCoord = function (y, axis) {
	  if (y === null) {
	    return null;
	  }

	  var area = this.plotter_.area;
	  var yRange = this.yAxisRange(axis);

	  if (typeof axis == "undefined") axis = 0;
	  if (!this.attributes_.getForAxis("logscale", axis)) {
	    return yRange[0] + (area.y + area.h - y) / area.h * (yRange[1] - yRange[0]);
	  } else {
	    // Computing the inverse of toDomCoord.
	    var pct = (y - area.y) / area.h;
	    // Note reversed yRange, y1 is on top with pct==0.
	    return utils.logRangeFraction(yRange[1], yRange[0], pct);
	  }
	};

	/**
	 * Converts a y for an axis to a percentage from the top to the
	 * bottom of the drawing area.
	 *
	 * If the coordinate represents a value visible on the canvas, then
	 * the value will be between 0 and 1, where 0 is the top of the canvas.
	 * However, this method will return values outside the range, as
	 * values can fall outside the canvas.
	 *
	 * If y is null, this returns null.
	 * if axis is null, this uses the first axis.
	 *
	 * @param {number} y The data y-coordinate.
	 * @param {number} [axis] The axis number on which the data coordinate lives.
	 * @return {number} A fraction in [0, 1] where 0 = the top edge.
	 */
	Dygraph.prototype.toPercentYCoord = function (y, axis) {
	  if (y === null) {
	    return null;
	  }
	  if (typeof axis == "undefined") axis = 0;

	  var yRange = this.yAxisRange(axis);

	  var pct;
	  var logscale = this.attributes_.getForAxis("logscale", axis);
	  if (logscale) {
	    var logr0 = utils.log10(yRange[0]);
	    var logr1 = utils.log10(yRange[1]);
	    pct = (logr1 - utils.log10(y)) / (logr1 - logr0);
	  } else {
	    // yRange[1] - y is unit distance from the bottom.
	    // yRange[1] - yRange[0] is the scale of the range.
	    // (yRange[1] - y) / (yRange[1] - yRange[0]) is the % from the bottom.
	    pct = (yRange[1] - y) / (yRange[1] - yRange[0]);
	  }
	  return pct;
	};

	/**
	 * Converts an x value to a percentage from the left to the right of
	 * the drawing area.
	 *
	 * If the coordinate represents a value visible on the canvas, then
	 * the value will be between 0 and 1, where 0 is the left of the canvas.
	 * However, this method will return values outside the range, as
	 * values can fall outside the canvas.
	 *
	 * If x is null, this returns null.
	 * @param {number} x The data x-coordinate.
	 * @return {number} A fraction in [0, 1] where 0 = the left edge.
	 */
	Dygraph.prototype.toPercentXCoord = function (x) {
	  if (x === null) {
	    return null;
	  }

	  var xRange = this.xAxisRange();
	  var pct;
	  var logscale = this.attributes_.getForAxis("logscale", 'x');
	  if (logscale === true) {
	    // logscale can be null so we test for true explicitly.
	    var logr0 = utils.log10(xRange[0]);
	    var logr1 = utils.log10(xRange[1]);
	    pct = (utils.log10(x) - logr0) / (logr1 - logr0);
	  } else {
	    // x - xRange[0] is unit distance from the left.
	    // xRange[1] - xRange[0] is the scale of the range.
	    // The full expression below is the % from the left.
	    pct = (x - xRange[0]) / (xRange[1] - xRange[0]);
	  }
	  return pct;
	};

	/**
	 * Returns the number of columns (including the independent variable).
	 * @return {number} The number of columns.
	 */
	Dygraph.prototype.numColumns = function () {
	  if (!this.rawData_) return 0;
	  return this.rawData_[0] ? this.rawData_[0].length : this.attr_("labels").length;
	};

	/**
	 * Returns the number of rows (excluding any header/label row).
	 * @return {number} The number of rows, less any header.
	 */
	Dygraph.prototype.numRows = function () {
	  if (!this.rawData_) return 0;
	  return this.rawData_.length;
	};

	/**
	 * Returns the value in the given row and column. If the row and column exceed
	 * the bounds on the data, returns null. Also returns null if the value is
	 * missing.
	 * @param {number} row The row number of the data (0-based). Row 0 is the
	 *     first row of data, not a header row.
	 * @param {number} col The column number of the data (0-based)
	 * @return {number} The value in the specified cell or null if the row/col
	 *     were out of range.
	 */
	Dygraph.prototype.getValue = function (row, col) {
	  if (row < 0 || row > this.rawData_.length) return null;
	  if (col < 0 || col > this.rawData_[row].length) return null;

	  return this.rawData_[row][col];
	};

	/**
	 * Generates interface elements for the Dygraph: a containing div, a div to
	 * display the current point, and a textbox to adjust the rolling average
	 * period. Also creates the Renderer/Layout elements.
	 * @private
	 */
	Dygraph.prototype.createInterface_ = function () {
	  // Create the all-enclosing graph div
	  var enclosing = this.maindiv_;

	  this.graphDiv = document.createElement("div");

	  // TODO(danvk): any other styles that are useful to set here?
	  this.graphDiv.style.textAlign = 'left'; // This is a CSS "reset"
	  this.graphDiv.style.position = 'relative';
	  enclosing.appendChild(this.graphDiv);

	  // Create the canvas for interactive parts of the chart.
	  this.canvas_ = utils.createCanvas();
	  this.canvas_.style.position = "absolute";

	  // ... and for static parts of the chart.
	  this.hidden_ = this.createPlotKitCanvas_(this.canvas_);

	  this.canvas_ctx_ = utils.getContext(this.canvas_);
	  this.hidden_ctx_ = utils.getContext(this.hidden_);

	  this.resizeElements_();

	  // The interactive parts of the graph are drawn on top of the chart.
	  this.graphDiv.appendChild(this.hidden_);
	  this.graphDiv.appendChild(this.canvas_);
	  this.mouseEventElement_ = this.createMouseEventElement_();

	  // Create the grapher
	  this.layout_ = new _dygraphLayout2['default'](this);

	  var dygraph = this;

	  this.mouseMoveHandler_ = function (e) {
	    dygraph.mouseMove_(e);
	  };

	  this.mouseOutHandler_ = function (e) {
	    // The mouse has left the chart if:
	    // 1. e.target is inside the chart
	    // 2. e.relatedTarget is outside the chart
	    var target = e.target || e.fromElement;
	    var relatedTarget = e.relatedTarget || e.toElement;
	    if (utils.isNodeContainedBy(target, dygraph.graphDiv) && !utils.isNodeContainedBy(relatedTarget, dygraph.graphDiv)) {
	      dygraph.mouseOut_(e);
	    }
	  };

	  this.addAndTrackEvent(window, 'mouseout', this.mouseOutHandler_);
	  this.addAndTrackEvent(this.mouseEventElement_, 'mousemove', this.mouseMoveHandler_);

	  // Don't recreate and register the resize handler on subsequent calls.
	  // This happens when the graph is resized.
	  if (!this.resizeHandler_) {
	    this.resizeHandler_ = function (e) {
	      dygraph.resize();
	    };

	    // Update when the window is resized.
	    // TODO(danvk): drop frames depending on complexity of the chart.
	    this.addAndTrackEvent(window, 'resize', this.resizeHandler_);
	  }
	};

	Dygraph.prototype.resizeElements_ = function () {
	  this.graphDiv.style.width = this.width_ + "px";
	  this.graphDiv.style.height = this.height_ + "px";

	  var canvasScale = utils.getContextPixelRatio(this.canvas_ctx_);
	  this.canvas_.width = this.width_ * canvasScale;
	  this.canvas_.height = this.height_ * canvasScale;
	  this.canvas_.style.width = this.width_ + "px"; // for IE
	  this.canvas_.style.height = this.height_ + "px"; // for IE
	  if (canvasScale !== 1) {
	    this.canvas_ctx_.scale(canvasScale, canvasScale);
	  }

	  var hiddenScale = utils.getContextPixelRatio(this.hidden_ctx_);
	  this.hidden_.width = this.width_ * hiddenScale;
	  this.hidden_.height = this.height_ * hiddenScale;
	  this.hidden_.style.width = this.width_ + "px"; // for IE
	  this.hidden_.style.height = this.height_ + "px"; // for IE
	  if (hiddenScale !== 1) {
	    this.hidden_ctx_.scale(hiddenScale, hiddenScale);
	  }
	};

	/**
	 * Detach DOM elements in the dygraph and null out all data references.
	 * Calling this when you're done with a dygraph can dramatically reduce memory
	 * usage. See, e.g., the tests/perf.html example.
	 */
	Dygraph.prototype.destroy = function () {
	  this.canvas_ctx_.restore();
	  this.hidden_ctx_.restore();

	  // Destroy any plugins, in the reverse order that they were registered.
	  for (var i = this.plugins_.length - 1; i >= 0; i--) {
	    var p = this.plugins_.pop();
	    if (p.plugin.destroy) p.plugin.destroy();
	  }

	  var removeRecursive = function removeRecursive(node) {
	    while (node.hasChildNodes()) {
	      removeRecursive(node.firstChild);
	      node.removeChild(node.firstChild);
	    }
	  };

	  this.removeTrackedEvents_();

	  // remove mouse event handlers (This may not be necessary anymore)
	  utils.removeEvent(window, 'mouseout', this.mouseOutHandler_);
	  utils.removeEvent(this.mouseEventElement_, 'mousemove', this.mouseMoveHandler_);

	  // remove window handlers
	  utils.removeEvent(window, 'resize', this.resizeHandler_);
	  this.resizeHandler_ = null;

	  removeRecursive(this.maindiv_);

	  var nullOut = function nullOut(obj) {
	    for (var n in obj) {
	      if (typeof obj[n] === 'object') {
	        obj[n] = null;
	      }
	    }
	  };
	  // These may not all be necessary, but it can't hurt...
	  nullOut(this.layout_);
	  nullOut(this.plotter_);
	  nullOut(this);
	};

	/**
	 * Creates the canvas on which the chart will be drawn. Only the Renderer ever
	 * draws on this particular canvas. All Dygraph work (i.e. drawing hover dots
	 * or the zoom rectangles) is done on this.canvas_.
	 * @param {Object} canvas The Dygraph canvas over which to overlay the plot
	 * @return {Object} The newly-created canvas
	 * @private
	 */
	Dygraph.prototype.createPlotKitCanvas_ = function (canvas) {
	  var h = utils.createCanvas();
	  h.style.position = "absolute";
	  // TODO(danvk): h should be offset from canvas. canvas needs to include
	  // some extra area to make it easier to zoom in on the far left and far
	  // right. h needs to be precisely the plot area, so that clipping occurs.
	  h.style.top = canvas.style.top;
	  h.style.left = canvas.style.left;
	  h.width = this.width_;
	  h.height = this.height_;
	  h.style.width = this.width_ + "px"; // for IE
	  h.style.height = this.height_ + "px"; // for IE
	  return h;
	};

	/**
	 * Creates an overlay element used to handle mouse events.
	 * @return {Object} The mouse event element.
	 * @private
	 */
	Dygraph.prototype.createMouseEventElement_ = function () {
	  return this.canvas_;
	};

	/**
	 * Generate a set of distinct colors for the data series. This is done with a
	 * color wheel. Saturation/Value are customizable, and the hue is
	 * equally-spaced around the color wheel. If a custom set of colors is
	 * specified, that is used instead.
	 * @private
	 */
	Dygraph.prototype.setColors_ = function () {
	  var labels = this.getLabels();
	  var num = labels.length - 1;
	  this.colors_ = [];
	  this.colorsMap_ = {};

	  // These are used for when no custom colors are specified.
	  var sat = this.getNumericOption('colorSaturation') || 1.0;
	  var val = this.getNumericOption('colorValue') || 0.5;
	  var half = Math.ceil(num / 2);

	  var colors = this.getOption('colors');
	  var visibility = this.visibility();
	  for (var i = 0; i < num; i++) {
	    if (!visibility[i]) {
	      continue;
	    }
	    var label = labels[i + 1];
	    var colorStr = this.attributes_.getForSeries('color', label);
	    if (!colorStr) {
	      if (colors) {
	        colorStr = colors[i % colors.length];
	      } else {
	        // alternate colors for high contrast.
	        var idx = i % 2 ? half + (i + 1) / 2 : Math.ceil((i + 1) / 2);
	        var hue = 1.0 * idx / (1 + num);
	        colorStr = utils.hsvToRGB(hue, sat, val);
	      }
	    }
	    this.colors_.push(colorStr);
	    this.colorsMap_[label] = colorStr;
	  }
	};

	/**
	 * Return the list of colors. This is either the list of colors passed in the
	 * attributes or the autogenerated list of rgb(r,g,b) strings.
	 * This does not return colors for invisible series.
	 * @return {Array.<string>} The list of colors.
	 */
	Dygraph.prototype.getColors = function () {
	  return this.colors_;
	};

	/**
	 * Returns a few attributes of a series, i.e. its color, its visibility, which
	 * axis it's assigned to, and its column in the original data.
	 * Returns null if the series does not exist.
	 * Otherwise, returns an object with column, visibility, color and axis properties.
	 * The "axis" property will be set to 1 for y1 and 2 for y2.
	 * The "column" property can be fed back into getValue(row, column) to get
	 * values for this series.
	 */
	Dygraph.prototype.getPropertiesForSeries = function (series_name) {
	  var idx = -1;
	  var labels = this.getLabels();
	  for (var i = 1; i < labels.length; i++) {
	    if (labels[i] == series_name) {
	      idx = i;
	      break;
	    }
	  }
	  if (idx == -1) return null;

	  return {
	    name: series_name,
	    column: idx,
	    visible: this.visibility()[idx - 1],
	    color: this.colorsMap_[series_name],
	    axis: 1 + this.attributes_.axisForSeries(series_name)
	  };
	};

	/**
	 * Create the text box to adjust the averaging period
	 * @private
	 */
	Dygraph.prototype.createRollInterface_ = function () {
	  var _this = this;

	  // Create a roller if one doesn't exist already.
	  var roller = this.roller_;
	  if (!roller) {
	    this.roller_ = roller = document.createElement("input");
	    roller.type = "text";
	    roller.style.display = "none";
	    roller.className = 'dygraph-roller';
	    this.graphDiv.appendChild(roller);
	  }

	  var display = this.getBooleanOption('showRoller') ? 'block' : 'none';

	  var area = this.getArea();
	  var textAttr = {
	    "top": area.y + area.h - 25 + "px",
	    "left": area.x + 1 + "px",
	    "display": display
	  };
	  roller.size = "2";
	  roller.value = this.rollPeriod_;
	  utils.update(roller.style, textAttr);

	  roller.onchange = function () {
	    return _this.adjustRoll(roller.value);
	  };
	};

	/**
	 * Set up all the mouse handlers needed to capture dragging behavior for zoom
	 * events.
	 * @private
	 */
	Dygraph.prototype.createDragInterface_ = function () {
	  var context = {
	    // Tracks whether the mouse is down right now
	    isZooming: false,
	    isPanning: false, // is this drag part of a pan?
	    is2DPan: false, // if so, is that pan 1- or 2-dimensional?
	    dragStartX: null, // pixel coordinates
	    dragStartY: null, // pixel coordinates
	    dragEndX: null, // pixel coordinates
	    dragEndY: null, // pixel coordinates
	    dragDirection: null,
	    prevEndX: null, // pixel coordinates
	    prevEndY: null, // pixel coordinates
	    prevDragDirection: null,
	    cancelNextDblclick: false, // see comment in dygraph-interaction-model.js

	    // The value on the left side of the graph when a pan operation starts.
	    initialLeftmostDate: null,

	    // The number of units each pixel spans. (This won't be valid for log
	    // scales)
	    xUnitsPerPixel: null,

	    // TODO(danvk): update this comment
	    // The range in second/value units that the viewport encompasses during a
	    // panning operation.
	    dateRange: null,

	    // Top-left corner of the canvas, in DOM coords
	    // TODO(konigsberg): Rename topLeftCanvasX, topLeftCanvasY.
	    px: 0,
	    py: 0,

	    // Values for use with panEdgeFraction, which limit how far outside the
	    // graph's data boundaries it can be panned.
	    boundedDates: null, // [minDate, maxDate]
	    boundedValues: null, // [[minValue, maxValue] ...]

	    // We cover iframes during mouse interactions. See comments in
	    // dygraph-utils.js for more info on why this is a good idea.
	    tarp: new _iframeTarp2['default'](),

	    // contextB is the same thing as this context object but renamed.
	    initializeMouseDown: function initializeMouseDown(event, g, contextB) {
	      // prevents mouse drags from selecting page text.
	      if (event.preventDefault) {
	        event.preventDefault(); // Firefox, Chrome, etc.
	      } else {
	          event.returnValue = false; // IE
	          event.cancelBubble = true;
	        }

	      var canvasPos = utils.findPos(g.canvas_);
	      contextB.px = canvasPos.x;
	      contextB.py = canvasPos.y;
	      contextB.dragStartX = utils.dragGetX_(event, contextB);
	      contextB.dragStartY = utils.dragGetY_(event, contextB);
	      contextB.cancelNextDblclick = false;
	      contextB.tarp.cover();
	    },
	    destroy: function destroy() {
	      var context = this;
	      if (context.isZooming || context.isPanning) {
	        context.isZooming = false;
	        context.dragStartX = null;
	        context.dragStartY = null;
	      }

	      if (context.isPanning) {
	        context.isPanning = false;
	        context.draggingDate = null;
	        context.dateRange = null;
	        for (var i = 0; i < self.axes_.length; i++) {
	          delete self.axes_[i].draggingValue;
	          delete self.axes_[i].dragValueRange;
	        }
	      }

	      context.tarp.uncover();
	    }
	  };

	  var interactionModel = this.getOption("interactionModel");

	  // Self is the graph.
	  var self = this;

	  // Function that binds the graph and context to the handler.
	  var bindHandler = function bindHandler(handler) {
	    return function (event) {
	      handler(event, self, context);
	    };
	  };

	  for (var eventName in interactionModel) {
	    if (!interactionModel.hasOwnProperty(eventName)) continue;
	    this.addAndTrackEvent(this.mouseEventElement_, eventName, bindHandler(interactionModel[eventName]));
	  }

	  // If the user releases the mouse button during a drag, but not over the
	  // canvas, then it doesn't count as a zooming action.
	  if (!interactionModel.willDestroyContextMyself) {
	    var mouseUpHandler = function mouseUpHandler(event) {
	      context.destroy();
	    };

	    this.addAndTrackEvent(document, 'mouseup', mouseUpHandler);
	  }
	};

	/**
	 * Draw a gray zoom rectangle over the desired area of the canvas. Also clears
	 * up any previous zoom rectangles that were drawn. This could be optimized to
	 * avoid extra redrawing, but it's tricky to avoid interactions with the status
	 * dots.
	 *
	 * @param {number} direction the direction of the zoom rectangle. Acceptable
	 *     values are utils.HORIZONTAL and utils.VERTICAL.
	 * @param {number} startX The X position where the drag started, in canvas
	 *     coordinates.
	 * @param {number} endX The current X position of the drag, in canvas coords.
	 * @param {number} startY The Y position where the drag started, in canvas
	 *     coordinates.
	 * @param {number} endY The current Y position of the drag, in canvas coords.
	 * @param {number} prevDirection the value of direction on the previous call to
	 *     this function. Used to avoid excess redrawing
	 * @param {number} prevEndX The value of endX on the previous call to this
	 *     function. Used to avoid excess redrawing
	 * @param {number} prevEndY The value of endY on the previous call to this
	 *     function. Used to avoid excess redrawing
	 * @private
	 */
	Dygraph.prototype.drawZoomRect_ = function (direction, startX, endX, startY, endY, prevDirection, prevEndX, prevEndY) {
	  var ctx = this.canvas_ctx_;

	  // Clean up from the previous rect if necessary
	  if (prevDirection == utils.HORIZONTAL) {
	    ctx.clearRect(Math.min(startX, prevEndX), this.layout_.getPlotArea().y, Math.abs(startX - prevEndX), this.layout_.getPlotArea().h);
	  } else if (prevDirection == utils.VERTICAL) {
	    ctx.clearRect(this.layout_.getPlotArea().x, Math.min(startY, prevEndY), this.layout_.getPlotArea().w, Math.abs(startY - prevEndY));
	  }

	  // Draw a light-grey rectangle to show the new viewing area
	  if (direction == utils.HORIZONTAL) {
	    if (endX && startX) {
	      ctx.fillStyle = "rgba(128,128,128,0.33)";
	      ctx.fillRect(Math.min(startX, endX), this.layout_.getPlotArea().y, Math.abs(endX - startX), this.layout_.getPlotArea().h);
	    }
	  } else if (direction == utils.VERTICAL) {
	    if (endY && startY) {
	      ctx.fillStyle = "rgba(128,128,128,0.33)";
	      ctx.fillRect(this.layout_.getPlotArea().x, Math.min(startY, endY), this.layout_.getPlotArea().w, Math.abs(endY - startY));
	    }
	  }
	};

	/**
	 * Clear the zoom rectangle (and perform no zoom).
	 * @private
	 */
	Dygraph.prototype.clearZoomRect_ = function () {
	  this.currentZoomRectArgs_ = null;
	  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);
	};

	/**
	 * Zoom to something containing [lowX, highX]. These are pixel coordinates in
	 * the canvas. The exact zoom window may be slightly larger if there are no data
	 * points near lowX or highX. Don't confuse this function with doZoomXDates,
	 * which accepts dates that match the raw data. This function redraws the graph.
	 *
	 * @param {number} lowX The leftmost pixel value that should be visible.
	 * @param {number} highX The rightmost pixel value that should be visible.
	 * @private
	 */
	Dygraph.prototype.doZoomX_ = function (lowX, highX) {
	  this.currentZoomRectArgs_ = null;
	  // Find the earliest and latest dates contained in this canvasx range.
	  // Convert the call to date ranges of the raw data.
	  var minDate = this.toDataXCoord(lowX);
	  var maxDate = this.toDataXCoord(highX);
	  this.doZoomXDates_(minDate, maxDate);
	};

	/**
	 * Zoom to something containing [minDate, maxDate] values. Don't confuse this
	 * method with doZoomX which accepts pixel coordinates. This function redraws
	 * the graph.
	 *
	 * @param {number} minDate The minimum date that should be visible.
	 * @param {number} maxDate The maximum date that should be visible.
	 * @private
	 */
	Dygraph.prototype.doZoomXDates_ = function (minDate, maxDate) {
	  var _this2 = this;

	  // TODO(danvk): when xAxisRange is null (i.e. "fit to data", the animation
	  // can produce strange effects. Rather than the x-axis transitioning slowly
	  // between values, it can jerk around.)
	  var old_window = this.xAxisRange();
	  var new_window = [minDate, maxDate];
	  var zoomCallback = this.getFunctionOption('zoomCallback');
	  this.doAnimatedZoom(old_window, new_window, null, null, function () {
	    if (zoomCallback) {
	      zoomCallback.call(_this2, minDate, maxDate, _this2.yAxisRanges());
	    }
	  });
	};

	/**
	 * Zoom to something containing [lowY, highY]. These are pixel coordinates in
	 * the canvas. This function redraws the graph.
	 *
	 * @param {number} lowY The topmost pixel value that should be visible.
	 * @param {number} highY The lowest pixel value that should be visible.
	 * @private
	 */
	Dygraph.prototype.doZoomY_ = function (lowY, highY) {
	  var _this3 = this;

	  this.currentZoomRectArgs_ = null;
	  // Find the highest and lowest values in pixel range for each axis.
	  // Note that lowY (in pixels) corresponds to the max Value (in data coords).
	  // This is because pixels increase as you go down on the screen, whereas data
	  // coordinates increase as you go up the screen.
	  var oldValueRanges = this.yAxisRanges();
	  var newValueRanges = [];
	  for (var i = 0; i < this.axes_.length; i++) {
	    var hi = this.toDataYCoord(lowY, i);
	    var low = this.toDataYCoord(highY, i);
	    newValueRanges.push([low, hi]);
	  }

	  var zoomCallback = this.getFunctionOption('zoomCallback');
	  this.doAnimatedZoom(null, null, oldValueRanges, newValueRanges, function () {
	    if (zoomCallback) {
	      var _xAxisRange = _this3.xAxisRange();

	      var _xAxisRange2 = _slicedToArray(_xAxisRange, 2);

	      var minX = _xAxisRange2[0];
	      var maxX = _xAxisRange2[1];

	      zoomCallback.call(_this3, minX, maxX, _this3.yAxisRanges());
	    }
	  });
	};

	/**
	 * Transition function to use in animations. Returns values between 0.0
	 * (totally old values) and 1.0 (totally new values) for each frame.
	 * @private
	 */
	Dygraph.zoomAnimationFunction = function (frame, numFrames) {
	  var k = 1.5;
	  return (1.0 - Math.pow(k, -frame)) / (1.0 - Math.pow(k, -numFrames));
	};

	/**
	 * Reset the zoom to the original view coordinates. This is the same as
	 * double-clicking on the graph.
	 */
	Dygraph.prototype.resetZoom = function () {
	  var _this4 = this;

	  var dirtyX = this.isZoomed('x');
	  var dirtyY = this.isZoomed('y');
	  var dirty = dirtyX || dirtyY;

	  // Clear any selection, since it's likely to be drawn in the wrong place.
	  this.clearSelection();

	  if (!dirty) return;

	  // Calculate extremes to avoid lack of padding on reset.

	  var _xAxisExtremes = this.xAxisExtremes();

	  var _xAxisExtremes2 = _slicedToArray(_xAxisExtremes, 2);

	  var minDate = _xAxisExtremes2[0];
	  var maxDate = _xAxisExtremes2[1];

	  var animatedZooms = this.getBooleanOption('animatedZooms');
	  var zoomCallback = this.getFunctionOption('zoomCallback');

	  // TODO(danvk): merge this block w/ the code below.
	  if (!animatedZooms) {
	    this.dateWindow_ = null;
	    this.axes_.forEach(function (axis) {
	      if (axis.valueRange) delete axis.valueRange;
	    });

	    this.drawGraph_();
	    if (zoomCallback) {
	      zoomCallback.call(this, minDate, maxDate, this.yAxisRanges());
	    }
	    return;
	  }

	  var oldWindow = null,
	      newWindow = null,
	      oldValueRanges = null,
	      newValueRanges = null;
	  if (dirtyX) {
	    oldWindow = this.xAxisRange();
	    newWindow = [minDate, maxDate];
	  }

	  if (dirtyY) {
	    oldValueRanges = this.yAxisRanges();
	    newValueRanges = this.yAxisExtremes();
	  }

	  this.doAnimatedZoom(oldWindow, newWindow, oldValueRanges, newValueRanges, function () {
	    _this4.dateWindow_ = null;
	    _this4.axes_.forEach(function (axis) {
	      if (axis.valueRange) delete axis.valueRange;
	    });
	    if (zoomCallback) {
	      zoomCallback.call(_this4, minDate, maxDate, _this4.yAxisRanges());
	    }
	  });
	};

	/**
	 * Combined animation logic for all zoom functions.
	 * either the x parameters or y parameters may be null.
	 * @private
	 */
	Dygraph.prototype.doAnimatedZoom = function (oldXRange, newXRange, oldYRanges, newYRanges, callback) {
	  var _this5 = this;

	  var steps = this.getBooleanOption("animatedZooms") ? Dygraph.ANIMATION_STEPS : 1;

	  var windows = [];
	  var valueRanges = [];
	  var step, frac;

	  if (oldXRange !== null && newXRange !== null) {
	    for (step = 1; step <= steps; step++) {
	      frac = Dygraph.zoomAnimationFunction(step, steps);
	      windows[step - 1] = [oldXRange[0] * (1 - frac) + frac * newXRange[0], oldXRange[1] * (1 - frac) + frac * newXRange[1]];
	    }
	  }

	  if (oldYRanges !== null && newYRanges !== null) {
	    for (step = 1; step <= steps; step++) {
	      frac = Dygraph.zoomAnimationFunction(step, steps);
	      var thisRange = [];
	      for (var j = 0; j < this.axes_.length; j++) {
	        thisRange.push([oldYRanges[j][0] * (1 - frac) + frac * newYRanges[j][0], oldYRanges[j][1] * (1 - frac) + frac * newYRanges[j][1]]);
	      }
	      valueRanges[step - 1] = thisRange;
	    }
	  }

	  utils.repeatAndCleanup(function (step) {
	    if (valueRanges.length) {
	      for (var i = 0; i < _this5.axes_.length; i++) {
	        var w = valueRanges[step][i];
	        _this5.axes_[i].valueRange = [w[0], w[1]];
	      }
	    }
	    if (windows.length) {
	      _this5.dateWindow_ = windows[step];
	    }
	    _this5.drawGraph_();
	  }, steps, Dygraph.ANIMATION_DURATION / steps, callback);
	};

	/**
	 * Get the current graph's area object.
	 *
	 * Returns: {x, y, w, h}
	 */
	Dygraph.prototype.getArea = function () {
	  return this.plotter_.area;
	};

	/**
	 * Convert a mouse event to DOM coordinates relative to the graph origin.
	 *
	 * Returns a two-element array: [X, Y].
	 */
	Dygraph.prototype.eventToDomCoords = function (event) {
	  if (event.offsetX && event.offsetY) {
	    return [event.offsetX, event.offsetY];
	  } else {
	    var eventElementPos = utils.findPos(this.mouseEventElement_);
	    var canvasx = utils.pageX(event) - eventElementPos.x;
	    var canvasy = utils.pageY(event) - eventElementPos.y;
	    return [canvasx, canvasy];
	  }
	};

	/**
	 * Given a canvas X coordinate, find the closest row.
	 * @param {number} domX graph-relative DOM X coordinate
	 * Returns {number} row number.
	 * @private
	 */
	Dygraph.prototype.findClosestRow = function (domX) {
	  var minDistX = Infinity;
	  var closestRow = -1;
	  var sets = this.layout_.points;
	  for (var i = 0; i < sets.length; i++) {
	    var points = sets[i];
	    var len = points.length;
	    for (var j = 0; j < len; j++) {
	      var point = points[j];
	      if (!utils.isValidPoint(point, true)) continue;
	      var dist = Math.abs(point.canvasx - domX);
	      if (dist < minDistX) {
	        minDistX = dist;
	        closestRow = point.idx;
	      }
	    }
	  }

	  return closestRow;
	};

	/**
	 * Given canvas X,Y coordinates, find the closest point.
	 *
	 * This finds the individual data point across all visible series
	 * that's closest to the supplied DOM coordinates using the standard
	 * Euclidean X,Y distance.
	 *
	 * @param {number} domX graph-relative DOM X coordinate
	 * @param {number} domY graph-relative DOM Y coordinate
	 * Returns: {row, seriesName, point}
	 * @private
	 */
	Dygraph.prototype.findClosestPoint = function (domX, domY) {
	  var minDist = Infinity;
	  var dist, dx, dy, point, closestPoint, closestSeries, closestRow;
	  for (var setIdx = this.layout_.points.length - 1; setIdx >= 0; --setIdx) {
	    var points = this.layout_.points[setIdx];
	    for (var i = 0; i < points.length; ++i) {
	      point = points[i];
	      if (!utils.isValidPoint(point)) continue;
	      dx = point.canvasx - domX;
	      dy = point.canvasy - domY;
	      dist = dx * dx + dy * dy;
	      if (dist < minDist) {
	        minDist = dist;
	        closestPoint = point;
	        closestSeries = setIdx;
	        closestRow = point.idx;
	      }
	    }
	  }
	  var name = this.layout_.setNames[closestSeries];
	  return {
	    row: closestRow,
	    seriesName: name,
	    point: closestPoint
	  };
	};

	/**
	 * Given canvas X,Y coordinates, find the touched area in a stacked graph.
	 *
	 * This first finds the X data point closest to the supplied DOM X coordinate,
	 * then finds the series which puts the Y coordinate on top of its filled area,
	 * using linear interpolation between adjacent point pairs.
	 *
	 * @param {number} domX graph-relative DOM X coordinate
	 * @param {number} domY graph-relative DOM Y coordinate
	 * Returns: {row, seriesName, point}
	 * @private
	 */
	Dygraph.prototype.findStackedPoint = function (domX, domY) {
	  var row = this.findClosestRow(domX);
	  var closestPoint, closestSeries;
	  for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {
	    var boundary = this.getLeftBoundary_(setIdx);
	    var rowIdx = row - boundary;
	    var points = this.layout_.points[setIdx];
	    if (rowIdx >= points.length) continue;
	    var p1 = points[rowIdx];
	    if (!utils.isValidPoint(p1)) continue;
	    var py = p1.canvasy;
	    if (domX > p1.canvasx && rowIdx + 1 < points.length) {
	      // interpolate series Y value using next point
	      var p2 = points[rowIdx + 1];
	      if (utils.isValidPoint(p2)) {
	        var dx = p2.canvasx - p1.canvasx;
	        if (dx > 0) {
	          var r = (domX - p1.canvasx) / dx;
	          py += r * (p2.canvasy - p1.canvasy);
	        }
	      }
	    } else if (domX < p1.canvasx && rowIdx > 0) {
	      // interpolate series Y value using previous point
	      var p0 = points[rowIdx - 1];
	      if (utils.isValidPoint(p0)) {
	        var dx = p1.canvasx - p0.canvasx;
	        if (dx > 0) {
	          var r = (p1.canvasx - domX) / dx;
	          py += r * (p0.canvasy - p1.canvasy);
	        }
	      }
	    }
	    // Stop if the point (domX, py) is above this series' upper edge
	    if (setIdx === 0 || py < domY) {
	      closestPoint = p1;
	      closestSeries = setIdx;
	    }
	  }
	  var name = this.layout_.setNames[closestSeries];
	  return {
	    row: row,
	    seriesName: name,
	    point: closestPoint
	  };
	};

	/**
	 * When the mouse moves in the canvas, display information about a nearby data
	 * point and draw dots over those points in the data series. This function
	 * takes care of cleanup of previously-drawn dots.
	 * @param {Object} event The mousemove event from the browser.
	 * @private
	 */
	Dygraph.prototype.mouseMove_ = function (event) {
	  // This prevents JS errors when mousing over the canvas before data loads.
	  var points = this.layout_.points;
	  if (points === undefined || points === null) return;

	  var canvasCoords = this.eventToDomCoords(event);
	  var canvasx = canvasCoords[0];
	  var canvasy = canvasCoords[1];

	  var highlightSeriesOpts = this.getOption("highlightSeriesOpts");
	  var selectionChanged = false;
	  if (highlightSeriesOpts && !this.isSeriesLocked()) {
	    var closest;
	    if (this.getBooleanOption("stackedGraph")) {
	      closest = this.findStackedPoint(canvasx, canvasy);
	    } else {
	      closest = this.findClosestPoint(canvasx, canvasy);
	    }
	    selectionChanged = this.setSelection(closest.row, closest.seriesName);
	  } else {
	    var idx = this.findClosestRow(canvasx);
	    selectionChanged = this.setSelection(idx);
	  }

	  var callback = this.getFunctionOption("highlightCallback");
	  if (callback && selectionChanged) {
	    callback.call(this, event, this.lastx_, this.selPoints_, this.lastRow_, this.highlightSet_);
	  }
	};

	/**
	 * Fetch left offset from the specified set index or if not passed, the
	 * first defined boundaryIds record (see bug #236).
	 * @private
	 */
	Dygraph.prototype.getLeftBoundary_ = function (setIdx) {
	  if (this.boundaryIds_[setIdx]) {
	    return this.boundaryIds_[setIdx][0];
	  } else {
	    for (var i = 0; i < this.boundaryIds_.length; i++) {
	      if (this.boundaryIds_[i] !== undefined) {
	        return this.boundaryIds_[i][0];
	      }
	    }
	    return 0;
	  }
	};

	Dygraph.prototype.animateSelection_ = function (direction) {
	  var totalSteps = 10;
	  var millis = 30;
	  if (this.fadeLevel === undefined) this.fadeLevel = 0;
	  if (this.animateId === undefined) this.animateId = 0;
	  var start = this.fadeLevel;
	  var steps = direction < 0 ? start : totalSteps - start;
	  if (steps <= 0) {
	    if (this.fadeLevel) {
	      this.updateSelection_(1.0);
	    }
	    return;
	  }

	  var thisId = ++this.animateId;
	  var that = this;
	  var cleanupIfClearing = function cleanupIfClearing() {
	    // if we haven't reached fadeLevel 0 in the max frame time,
	    // ensure that the clear happens and just go to 0
	    if (that.fadeLevel !== 0 && direction < 0) {
	      that.fadeLevel = 0;
	      that.clearSelection();
	    }
	  };
	  utils.repeatAndCleanup(function (n) {
	    // ignore simultaneous animations
	    if (that.animateId != thisId) return;

	    that.fadeLevel += direction;
	    if (that.fadeLevel === 0) {
	      that.clearSelection();
	    } else {
	      that.updateSelection_(that.fadeLevel / totalSteps);
	    }
	  }, steps, millis, cleanupIfClearing);
	};

	/**
	 * Draw dots over the selectied points in the data series. This function
	 * takes care of cleanup of previously-drawn dots.
	 * @private
	 */
	Dygraph.prototype.updateSelection_ = function (opt_animFraction) {
	  /*var defaultPrevented = */
	  this.cascadeEvents_('select', {
	    selectedRow: this.lastRow_ === -1 ? undefined : this.lastRow_,
	    selectedX: this.lastx_ === -1 ? undefined : this.lastx_,
	    selectedPoints: this.selPoints_
	  });
	  // TODO(danvk): use defaultPrevented here?

	  // Clear the previously drawn vertical, if there is one
	  var i;
	  var ctx = this.canvas_ctx_;
	  if (this.getOption('highlightSeriesOpts')) {
	    ctx.clearRect(0, 0, this.width_, this.height_);
	    var alpha = 1.0 - this.getNumericOption('highlightSeriesBackgroundAlpha');
	    var backgroundColor = utils.toRGB_(this.getOption('highlightSeriesBackgroundColor'));

	    if (alpha) {
	      // Activating background fade includes an animation effect for a gradual
	      // fade. TODO(klausw): make this independently configurable if it causes
	      // issues? Use a shared preference to control animations?
	      var animateBackgroundFade = true;
	      if (animateBackgroundFade) {
	        if (opt_animFraction === undefined) {
	          // start a new animation
	          this.animateSelection_(1);
	          return;
	        }
	        alpha *= opt_animFraction;
	      }
	      ctx.fillStyle = 'rgba(' + backgroundColor.r + ',' + backgroundColor.g + ',' + backgroundColor.b + ',' + alpha + ')';
	      ctx.fillRect(0, 0, this.width_, this.height_);
	    }

	    // Redraw only the highlighted series in the interactive canvas (not the
	    // static plot canvas, which is where series are usually drawn).
	    this.plotter_._renderLineChart(this.highlightSet_, ctx);
	  } else if (this.previousVerticalX_ >= 0) {
	    // Determine the maximum highlight circle size.
	    var maxCircleSize = 0;
	    var labels = this.attr_('labels');
	    for (i = 1; i < labels.length; i++) {
	      var r = this.getNumericOption('highlightCircleSize', labels[i]);
	      if (r > maxCircleSize) maxCircleSize = r;
	    }
	    var px = this.previousVerticalX_;
	    ctx.clearRect(px - maxCircleSize - 1, 0, 2 * maxCircleSize + 2, this.height_);
	  }

	  if (this.selPoints_.length > 0) {
	    // Draw colored circles over the center of each selected point
	    var canvasx = this.selPoints_[0].canvasx;
	    ctx.save();
	    for (i = 0; i < this.selPoints_.length; i++) {
	      var pt = this.selPoints_[i];
	      if (isNaN(pt.canvasy)) continue;

	      var circleSize = this.getNumericOption('highlightCircleSize', pt.name);
	      var callback = this.getFunctionOption("drawHighlightPointCallback", pt.name);
	      var color = this.plotter_.colors[pt.name];
	      if (!callback) {
	        callback = utils.Circles.DEFAULT;
	      }
	      ctx.lineWidth = this.getNumericOption('strokeWidth', pt.name);
	      ctx.strokeStyle = color;
	      ctx.fillStyle = color;
	      callback.call(this, this, pt.name, ctx, canvasx, pt.canvasy, color, circleSize, pt.idx);
	    }
	    ctx.restore();

	    this.previousVerticalX_ = canvasx;
	  }
	};

	/**
	 * Manually set the selected points and display information about them in the
	 * legend. The selection can be cleared using clearSelection() and queried
	 * using getSelection().
	 *
	 * To set a selected series but not a selected point, call setSelection with
	 * row=false and the selected series name.
	 *
	 * @param {number} row Row number that should be highlighted (i.e. appear with
	 * hover dots on the chart).
	 * @param {seriesName} optional series name to highlight that series with the
	 * the highlightSeriesOpts setting.
	 * @param { locked } optional If true, keep seriesName selected when mousing
	 * over the graph, disabling closest-series highlighting. Call clearSelection()
	 * to unlock it.
	 */
	Dygraph.prototype.setSelection = function (row, opt_seriesName, opt_locked) {
	  // Extract the points we've selected
	  this.selPoints_ = [];

	  var changed = false;
	  if (row !== false && row >= 0) {
	    if (row != this.lastRow_) changed = true;
	    this.lastRow_ = row;
	    for (var setIdx = 0; setIdx < this.layout_.points.length; ++setIdx) {
	      var points = this.layout_.points[setIdx];
	      // Check if the point at the appropriate index is the point we're looking
	      // for.  If it is, just use it, otherwise search the array for a point
	      // in the proper place.
	      var setRow = row - this.getLeftBoundary_(setIdx);
	      if (setRow >= 0 && setRow < points.length && points[setRow].idx == row) {
	        var point = points[setRow];
	        if (point.yval !== null) this.selPoints_.push(point);
	      } else {
	        for (var pointIdx = 0; pointIdx < points.length; ++pointIdx) {
	          var point = points[pointIdx];
	          if (point.idx == row) {
	            if (point.yval !== null) {
	              this.selPoints_.push(point);
	            }
	            break;
	          }
	        }
	      }
	    }
	  } else {
	    if (this.lastRow_ >= 0) changed = true;
	    this.lastRow_ = -1;
	  }

	  if (this.selPoints_.length) {
	    this.lastx_ = this.selPoints_[0].xval;
	  } else {
	    this.lastx_ = -1;
	  }

	  if (opt_seriesName !== undefined) {
	    if (this.highlightSet_ !== opt_seriesName) changed = true;
	    this.highlightSet_ = opt_seriesName;
	  }

	  if (opt_locked !== undefined) {
	    this.lockedSet_ = opt_locked;
	  }

	  if (changed) {
	    this.updateSelection_(undefined);
	  }
	  return changed;
	};

	/**
	 * The mouse has left the canvas. Clear out whatever artifacts remain
	 * @param {Object} event the mouseout event from the browser.
	 * @private
	 */
	Dygraph.prototype.mouseOut_ = function (event) {
	  if (this.getFunctionOption("unhighlightCallback")) {
	    this.getFunctionOption("unhighlightCallback").call(this, event);
	  }

	  if (this.getBooleanOption("hideOverlayOnMouseOut") && !this.lockedSet_) {
	    this.clearSelection();
	  }
	};

	/**
	 * Clears the current selection (i.e. points that were highlighted by moving
	 * the mouse over the chart).
	 */
	Dygraph.prototype.clearSelection = function () {
	  this.cascadeEvents_('deselect', {});

	  this.lockedSet_ = false;
	  // Get rid of the overlay data
	  if (this.fadeLevel) {
	    this.animateSelection_(-1);
	    return;
	  }
	  this.canvas_ctx_.clearRect(0, 0, this.width_, this.height_);
	  this.fadeLevel = 0;
	  this.selPoints_ = [];
	  this.lastx_ = -1;
	  this.lastRow_ = -1;
	  this.highlightSet_ = null;
	};

	/**
	 * Returns the number of the currently selected row. To get data for this row,
	 * you can use the getValue method.
	 * @return {number} row number, or -1 if nothing is selected
	 */
	Dygraph.prototype.getSelection = function () {
	  if (!this.selPoints_ || this.selPoints_.length < 1) {
	    return -1;
	  }

	  for (var setIdx = 0; setIdx < this.layout_.points.length; setIdx++) {
	    var points = this.layout_.points[setIdx];
	    for (var row = 0; row < points.length; row++) {
	      if (points[row].x == this.selPoints_[0].x) {
	        return points[row].idx;
	      }
	    }
	  }
	  return -1;
	};

	/**
	 * Returns the name of the currently-highlighted series.
	 * Only available when the highlightSeriesOpts option is in use.
	 */
	Dygraph.prototype.getHighlightSeries = function () {
	  return this.highlightSet_;
	};

	/**
	 * Returns true if the currently-highlighted series was locked
	 * via setSelection(..., seriesName, true).
	 */
	Dygraph.prototype.isSeriesLocked = function () {
	  return this.lockedSet_;
	};

	/**
	 * Fires when there's data available to be graphed.
	 * @param {string} data Raw CSV data to be plotted
	 * @private
	 */
	Dygraph.prototype.loadedEvent_ = function (data) {
	  this.rawData_ = this.parseCSV_(data);
	  this.cascadeDataDidUpdateEvent_();
	  this.predraw_();
	};

	/**
	 * Add ticks on the x-axis representing years, months, quarters, weeks, or days
	 * @private
	 */
	Dygraph.prototype.addXTicks_ = function () {
	  // Determine the correct ticks scale on the x-axis: quarterly, monthly, ...
	  var range;
	  if (this.dateWindow_) {
	    range = [this.dateWindow_[0], this.dateWindow_[1]];
	  } else {
	    range = this.xAxisExtremes();
	  }

	  var xAxisOptionsView = this.optionsViewForAxis_('x');
	  var xTicks = xAxisOptionsView('ticker')(range[0], range[1], this.plotter_.area.w, // TODO(danvk): should be area.width
	  xAxisOptionsView, this);
	  // var msg = 'ticker(' + range[0] + ', ' + range[1] + ', ' + this.width_ + ', ' + this.attr_('pixelsPerXLabel') + ') -> ' + JSON.stringify(xTicks);
	  // console.log(msg);
	  this.layout_.setXTicks(xTicks);
	};

	/**
	 * Returns the correct handler class for the currently set options.
	 * @private
	 */
	Dygraph.prototype.getHandlerClass_ = function () {
	  var handlerClass;
	  if (this.attr_('dataHandler')) {
	    handlerClass = this.attr_('dataHandler');
	  } else if (this.fractions_) {
	    if (this.getBooleanOption('errorBars')) {
	      handlerClass = _datahandlerBarsFractions2['default'];
	    } else {
	      handlerClass = _datahandlerDefaultFractions2['default'];
	    }
	  } else if (this.getBooleanOption('customBars')) {
	    handlerClass = _datahandlerBarsCustom2['default'];
	  } else if (this.getBooleanOption('errorBars')) {
	    handlerClass = _datahandlerBarsError2['default'];
	  } else {
	    handlerClass = _datahandlerDefault2['default'];
	  }
	  return handlerClass;
	};

	/**
	 * @private
	 * This function is called once when the chart's data is changed or the options
	 * dictionary is updated. It is _not_ called when the user pans or zooms. The
	 * idea is that values derived from the chart's data can be computed here,
	 * rather than every time the chart is drawn. This includes things like the
	 * number of axes, rolling averages, etc.
	 */
	Dygraph.prototype.predraw_ = function () {
	  var start = new Date();

	  // Create the correct dataHandler
	  this.dataHandler_ = new (this.getHandlerClass_())();

	  this.layout_.computePlotArea();

	  // TODO(danvk): move more computations out of drawGraph_ and into here.
	  this.computeYAxes_();

	  if (!this.is_initial_draw_) {
	    this.canvas_ctx_.restore();
	    this.hidden_ctx_.restore();
	  }

	  this.canvas_ctx_.save();
	  this.hidden_ctx_.save();

	  // Create a new plotter.
	  this.plotter_ = new _dygraphCanvas2['default'](this, this.hidden_, this.hidden_ctx_, this.layout_);

	  // The roller sits in the bottom left corner of the chart. We don't know where
	  // this will be until the options are available, so it's positioned here.
	  this.createRollInterface_();

	  this.cascadeEvents_('predraw');

	  // Convert the raw data (a 2D array) into the internal format and compute
	  // rolling averages.
	  this.rolledSeries_ = [null]; // x-axis is the first series and it's special
	  for (var i = 1; i < this.numColumns(); i++) {
	    // var logScale = this.attr_('logscale', i); // TODO(klausw): this looks wrong // konigsberg thinks so too.
	    var series = this.dataHandler_.extractSeries(this.rawData_, i, this.attributes_);
	    if (this.rollPeriod_ > 1) {
	      series = this.dataHandler_.rollingAverage(series, this.rollPeriod_, this.attributes_);
	    }

	    this.rolledSeries_.push(series);
	  }

	  // If the data or options have changed, then we'd better redraw.
	  this.drawGraph_();

	  // This is used to determine whether to do various animations.
	  var end = new Date();
	  this.drawingTimeMs_ = end - start;
	};

	/**
	 * Point structure.
	 *
	 * xval_* and yval_* are the original unscaled data values,
	 * while x_* and y_* are scaled to the range (0.0-1.0) for plotting.
	 * yval_stacked is the cumulative Y value used for stacking graphs,
	 * and bottom/top/minus/plus are used for error bar graphs.
	 *
	 * @typedef {{
	 *     idx: number,
	 *     name: string,
	 *     x: ?number,
	 *     xval: ?number,
	 *     y_bottom: ?number,
	 *     y: ?number,
	 *     y_stacked: ?number,
	 *     y_top: ?number,
	 *     yval_minus: ?number,
	 *     yval: ?number,
	 *     yval_plus: ?number,
	 *     yval_stacked
	 * }}
	 */
	Dygraph.PointType = undefined;

	/**
	 * Calculates point stacking for stackedGraph=true.
	 *
	 * For stacking purposes, interpolate or extend neighboring data across
	 * NaN values based on stackedGraphNaNFill settings. This is for display
	 * only, the underlying data value as shown in the legend remains NaN.
	 *
	 * @param {Array.<Dygraph.PointType>} points Point array for a single series.
	 *     Updates each Point's yval_stacked property.
	 * @param {Array.<number>} cumulativeYval Accumulated top-of-graph stacked Y
	 *     values for the series seen so far. Index is the row number. Updated
	 *     based on the current series's values.
	 * @param {Array.<number>} seriesExtremes Min and max values, updated
	 *     to reflect the stacked values.
	 * @param {string} fillMethod Interpolation method, one of 'all', 'inside', or
	 *     'none'.
	 * @private
	 */
	Dygraph.stackPoints_ = function (points, cumulativeYval, seriesExtremes, fillMethod) {
	  var lastXval = null;
	  var prevPoint = null;
	  var nextPoint = null;
	  var nextPointIdx = -1;

	  // Find the next stackable point starting from the given index.
	  var updateNextPoint = function updateNextPoint(idx) {
	    // If we've previously found a non-NaN point and haven't gone past it yet,
	    // just use that.
	    if (nextPointIdx >= idx) return;

	    // We haven't found a non-NaN point yet or have moved past it,
	    // look towards the right to find a non-NaN point.
	    for (var j = idx; j < points.length; ++j) {
	      // Clear out a previously-found point (if any) since it's no longer
	      // valid, we shouldn't use it for interpolation anymore.
	      nextPoint = null;
	      if (!isNaN(points[j].yval) && points[j].yval !== null) {
	        nextPointIdx = j;
	        nextPoint = points[j];
	        break;
	      }
	    }
	  };

	  for (var i = 0; i < points.length; ++i) {
	    var point = points[i];
	    var xval = point.xval;
	    if (cumulativeYval[xval] === undefined) {
	      cumulativeYval[xval] = 0;
	    }

	    var actualYval = point.yval;
	    if (isNaN(actualYval) || actualYval === null) {
	      if (fillMethod == 'none') {
	        actualYval = 0;
	      } else {
	        // Interpolate/extend for stacking purposes if possible.
	        updateNextPoint(i);
	        if (prevPoint && nextPoint && fillMethod != 'none') {
	          // Use linear interpolation between prevPoint and nextPoint.
	          actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) * ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));
	        } else if (prevPoint && fillMethod == 'all') {
	          actualYval = prevPoint.yval;
	        } else if (nextPoint && fillMethod == 'all') {
	          actualYval = nextPoint.yval;
	        } else {
	          actualYval = 0;
	        }
	      }
	    } else {
	      prevPoint = point;
	    }

	    var stackedYval = cumulativeYval[xval];
	    if (lastXval != xval) {
	      // If an x-value is repeated, we ignore the duplicates.
	      stackedYval += actualYval;
	      cumulativeYval[xval] = stackedYval;
	    }
	    lastXval = xval;

	    point.yval_stacked = stackedYval;

	    if (stackedYval > seriesExtremes[1]) {
	      seriesExtremes[1] = stackedYval;
	    }
	    if (stackedYval < seriesExtremes[0]) {
	      seriesExtremes[0] = stackedYval;
	    }
	  }
	};

	/**
	 * Loop over all fields and create datasets, calculating extreme y-values for
	 * each series and extreme x-indices as we go.
	 *
	 * dateWindow is passed in as an explicit parameter so that we can compute
	 * extreme values "speculatively", i.e. without actually setting state on the
	 * dygraph.
	 *
	 * @param {Array.<Array.<Array.<(number|Array<number>)>>} rolledSeries, where
	 *     rolledSeries[seriesIndex][row] = raw point, where
	 *     seriesIndex is the column number starting with 1, and
	 *     rawPoint is [x,y] or [x, [y, err]] or [x, [y, yminus, yplus]].
	 * @param {?Array.<number>} dateWindow [xmin, xmax] pair, or null.
	 * @return {{
	 *     points: Array.<Array.<Dygraph.PointType>>,
	 *     seriesExtremes: Array.<Array.<number>>,
	 *     boundaryIds: Array.<number>}}
	 * @private
	 */
	Dygraph.prototype.gatherDatasets_ = function (rolledSeries, dateWindow) {
	  var boundaryIds = [];
	  var points = [];
	  var cumulativeYval = []; // For stacked series.
	  var extremes = {}; // series name -> [low, high]
	  var seriesIdx, sampleIdx;
	  var firstIdx, lastIdx;
	  var axisIdx;

	  // Loop over the fields (series).  Go from the last to the first,
	  // because if they're stacked that's how we accumulate the values.
	  var num_series = rolledSeries.length - 1;
	  var series;
	  for (seriesIdx = num_series; seriesIdx >= 1; seriesIdx--) {
	    if (!this.visibility()[seriesIdx - 1]) continue;

	    // Prune down to the desired range, if necessary (for zooming)
	    // Because there can be lines going to points outside of the visible area,
	    // we actually prune to visible points, plus one on either side.
	    if (dateWindow) {
	      series = rolledSeries[seriesIdx];
	      var low = dateWindow[0];
	      var high = dateWindow[1];

	      // TODO(danvk): do binary search instead of linear search.
	      // TODO(danvk): pass firstIdx and lastIdx directly to the renderer.
	      firstIdx = null;
	      lastIdx = null;
	      for (sampleIdx = 0; sampleIdx < series.length; sampleIdx++) {
	        if (series[sampleIdx][0] >= low && firstIdx === null) {
	          firstIdx = sampleIdx;
	        }
	        if (series[sampleIdx][0] <= high) {
	          lastIdx = sampleIdx;
	        }
	      }

	      if (firstIdx === null) firstIdx = 0;
	      var correctedFirstIdx = firstIdx;
	      var isInvalidValue = true;
	      while (isInvalidValue && correctedFirstIdx > 0) {
	        correctedFirstIdx--;
	        // check if the y value is null.
	        isInvalidValue = series[correctedFirstIdx][1] === null;
	      }

	      if (lastIdx === null) lastIdx = series.length - 1;
	      var correctedLastIdx = lastIdx;
	      isInvalidValue = true;
	      while (isInvalidValue && correctedLastIdx < series.length - 1) {
	        correctedLastIdx++;
	        isInvalidValue = series[correctedLastIdx][1] === null;
	      }

	      if (correctedFirstIdx !== firstIdx) {
	        firstIdx = correctedFirstIdx;
	      }
	      if (correctedLastIdx !== lastIdx) {
	        lastIdx = correctedLastIdx;
	      }

	      boundaryIds[seriesIdx - 1] = [firstIdx, lastIdx];

	      // .slice's end is exclusive, we want to include lastIdx.
	      series = series.slice(firstIdx, lastIdx + 1);
	    } else {
	      series = rolledSeries[seriesIdx];
	      boundaryIds[seriesIdx - 1] = [0, series.length - 1];
	    }

	    var seriesName = this.attr_("labels")[seriesIdx];
	    var seriesExtremes = this.dataHandler_.getExtremeYValues(series, dateWindow, this.getBooleanOption("stepPlot", seriesName));

	    var seriesPoints = this.dataHandler_.seriesToPoints(series, seriesName, boundaryIds[seriesIdx - 1][0]);

	    if (this.getBooleanOption("stackedGraph")) {
	      axisIdx = this.attributes_.axisForSeries(seriesName);
	      if (cumulativeYval[axisIdx] === undefined) {
	        cumulativeYval[axisIdx] = [];
	      }
	      Dygraph.stackPoints_(seriesPoints, cumulativeYval[axisIdx], seriesExtremes, this.getBooleanOption("stackedGraphNaNFill"));
	    }

	    extremes[seriesName] = seriesExtremes;
	    points[seriesIdx] = seriesPoints;
	  }

	  return { points: points, extremes: extremes, boundaryIds: boundaryIds };
	};

	/**
	 * Update the graph with new data. This method is called when the viewing area
	 * has changed. If the underlying data or options have changed, predraw_ will
	 * be called before drawGraph_ is called.
	 *
	 * @private
	 */
	Dygraph.prototype.drawGraph_ = function () {
	  var start = new Date();

	  // This is used to set the second parameter to drawCallback, below.
	  var is_initial_draw = this.is_initial_draw_;
	  this.is_initial_draw_ = false;

	  this.layout_.removeAllDatasets();
	  this.setColors_();
	  this.attrs_.pointSize = 0.5 * this.getNumericOption('highlightCircleSize');

	  var packed = this.gatherDatasets_(this.rolledSeries_, this.dateWindow_);
	  var points = packed.points;
	  var extremes = packed.extremes;
	  this.boundaryIds_ = packed.boundaryIds;

	  this.setIndexByName_ = {};
	  var labels = this.attr_("labels");
	  var dataIdx = 0;
	  for (var i = 1; i < points.length; i++) {
	    if (!this.visibility()[i - 1]) continue;
	    this.layout_.addDataset(labels[i], points[i]);
	    this.datasetIndex_[i] = dataIdx++;
	  }
	  for (var i = 0; i < labels.length; i++) {
	    this.setIndexByName_[labels[i]] = i;
	  }

	  this.computeYAxisRanges_(extremes);
	  this.layout_.setYAxes(this.axes_);

	  this.addXTicks_();

	  // Tell PlotKit to use this new data and render itself
	  this.layout_.evaluate();
	  this.renderGraph_(is_initial_draw);

	  if (this.getStringOption("timingName")) {
	    var end = new Date();
	    console.log(this.getStringOption("timingName") + " - drawGraph: " + (end - start) + "ms");
	  }
	};

	/**
	 * This does the work of drawing the chart. It assumes that the layout and axis
	 * scales have already been set (e.g. by predraw_).
	 *
	 * @private
	 */
	Dygraph.prototype.renderGraph_ = function (is_initial_draw) {
	  this.cascadeEvents_('clearChart');
	  this.plotter_.clear();

	  var underlayCallback = this.getFunctionOption('underlayCallback');
	  if (underlayCallback) {
	    // NOTE: we pass the dygraph object to this callback twice to avoid breaking
	    // users who expect a deprecated form of this callback.
	    underlayCallback.call(this, this.hidden_ctx_, this.layout_.getPlotArea(), this, this);
	  }

	  var e = {
	    canvas: this.hidden_,
	    drawingContext: this.hidden_ctx_
	  };
	  this.cascadeEvents_('willDrawChart', e);
	  this.plotter_.render();
	  this.cascadeEvents_('didDrawChart', e);
	  this.lastRow_ = -1; // because plugins/legend.js clears the legend

	  // TODO(danvk): is this a performance bottleneck when panning?
	  // The interaction canvas should already be empty in that situation.
	  this.canvas_.getContext('2d').clearRect(0, 0, this.width_, this.height_);

	  var drawCallback = this.getFunctionOption("drawCallback");
	  if (drawCallback !== null) {
	    drawCallback.call(this, this, is_initial_draw);
	  }
	  if (is_initial_draw) {
	    this.readyFired_ = true;
	    while (this.readyFns_.length > 0) {
	      var fn = this.readyFns_.pop();
	      fn(this);
	    }
	  }
	};

	/**
	 * @private
	 * Determine properties of the y-axes which are independent of the data
	 * currently being displayed. This includes things like the number of axes and
	 * the style of the axes. It does not include the range of each axis and its
	 * tick marks.
	 * This fills in this.axes_.
	 * axes_ = [ { options } ]
	 *   indices are into the axes_ array.
	 */
	Dygraph.prototype.computeYAxes_ = function () {
	  var axis, index, opts, v;

	  // this.axes_ doesn't match this.attributes_.axes_.options. It's used for
	  // data computation as well as options storage.
	  // Go through once and add all the axes.
	  this.axes_ = [];

	  for (axis = 0; axis < this.attributes_.numAxes(); axis++) {
	    // Add a new axis, making a copy of its per-axis options.
	    opts = { g: this };
	    utils.update(opts, this.attributes_.axisOptions(axis));
	    this.axes_[axis] = opts;
	  }

	  for (axis = 0; axis < this.axes_.length; axis++) {
	    if (axis === 0) {
	      opts = this.optionsViewForAxis_('y' + (axis ? '2' : ''));
	      v = opts("valueRange");
	      if (v) this.axes_[axis].valueRange = v;
	    } else {
	      // To keep old behavior
	      var axes = this.user_attrs_.axes;
	      if (axes && axes.y2) {
	        v = axes.y2.valueRange;
	        if (v) this.axes_[axis].valueRange = v;
	      }
	    }
	  }
	};

	/**
	 * Returns the number of y-axes on the chart.
	 * @return {number} the number of axes.
	 */
	Dygraph.prototype.numAxes = function () {
	  return this.attributes_.numAxes();
	};

	/**
	 * @private
	 * Returns axis properties for the given series.
	 * @param {string} setName The name of the series for which to get axis
	 * properties, e.g. 'Y1'.
	 * @return {Object} The axis properties.
	 */
	Dygraph.prototype.axisPropertiesForSeries = function (series) {
	  // TODO(danvk): handle errors.
	  return this.axes_[this.attributes_.axisForSeries(series)];
	};

	/**
	 * @private
	 * Determine the value range and tick marks for each axis.
	 * @param {Object} extremes A mapping from seriesName -> [low, high]
	 * This fills in the valueRange and ticks fields in each entry of this.axes_.
	 */
	Dygraph.prototype.computeYAxisRanges_ = function (extremes) {
	  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(num) {
	    return isNaN(parseFloat(num));
	  };
	  var numAxes = this.attributes_.numAxes();
	  var ypadCompat, span, series, ypad;

	  var p_axis;

	  // Compute extreme values, a span and tick marks for each axis.
	  for (var i = 0; i < numAxes; i++) {
	    var axis = this.axes_[i];
	    var logscale = this.attributes_.getForAxis("logscale", i);
	    var includeZero = this.attributes_.getForAxis("includeZero", i);
	    var independentTicks = this.attributes_.getForAxis("independentTicks", i);
	    series = this.attributes_.seriesForAxis(i);

	    // Add some padding. This supports two Y padding operation modes:
	    //
	    // - backwards compatible (yRangePad not set):
	    //   10% padding for automatic Y ranges, but not for user-supplied
	    //   ranges, and move a close-to-zero edge to zero, since drawing at the edge
	    //   results in invisible lines. Unfortunately lines drawn at the edge of a
	    //   user-supplied range will still be invisible. If logscale is
	    //   set, add a variable amount of padding at the top but
	    //   none at the bottom.
	    //
	    // - new-style (yRangePad set by the user):
	    //   always add the specified Y padding.
	    //
	    ypadCompat = true;
	    ypad = 0.1; // add 10%
	    var yRangePad = this.getNumericOption('yRangePad');
	    if (yRangePad !== null) {
	      ypadCompat = false;
	      // Convert pixel padding to ratio
	      ypad = yRangePad / this.plotter_.area.h;
	    }

	    if (series.length === 0) {
	      // If no series are defined or visible then use a reasonable default
	      axis.extremeRange = [0, 1];
	    } else {
	      // Calculate the extremes of extremes.
	      var minY = Infinity; // extremes[series[0]][0];
	      var maxY = -Infinity; // extremes[series[0]][1];
	      var extremeMinY, extremeMaxY;

	      for (var j = 0; j < series.length; j++) {
	        // this skips invisible series
	        if (!extremes.hasOwnProperty(series[j])) continue;

	        // Only use valid extremes to stop null data series' from corrupting the scale.
	        extremeMinY = extremes[series[j]][0];
	        if (extremeMinY !== null) {
	          minY = Math.min(extremeMinY, minY);
	        }
	        extremeMaxY = extremes[series[j]][1];
	        if (extremeMaxY !== null) {
	          maxY = Math.max(extremeMaxY, maxY);
	        }
	      }

	      // Include zero if requested by the user.
	      if (includeZero && !logscale) {
	        if (minY > 0) minY = 0;
	        if (maxY < 0) maxY = 0;
	      }

	      // Ensure we have a valid scale, otherwise default to [0, 1] for safety.
	      if (minY == Infinity) minY = 0;
	      if (maxY == -Infinity) maxY = 1;

	      span = maxY - minY;
	      // special case: if we have no sense of scale, center on the sole value.
	      if (span === 0) {
	        if (maxY !== 0) {
	          span = Math.abs(maxY);
	        } else {
	          // ... and if the sole value is zero, use range 0-1.
	          maxY = 1;
	          span = 1;
	        }
	      }

	      var maxAxisY = maxY,
	          minAxisY = minY;
	      if (ypadCompat) {
	        if (logscale) {
	          maxAxisY = maxY + ypad * span;
	          minAxisY = minY;
	        } else {
	          maxAxisY = maxY + ypad * span;
	          minAxisY = minY - ypad * span;

	          // Backwards-compatible behavior: Move the span to start or end at zero if it's
	          // close to zero.
	          if (minAxisY < 0 && minY >= 0) minAxisY = 0;
	          if (maxAxisY > 0 && maxY <= 0) maxAxisY = 0;
	        }
	      }
	      axis.extremeRange = [minAxisY, maxAxisY];
	    }
	    if (axis.valueRange) {
	      // This is a user-set value range for this axis.
	      var y0 = isNullUndefinedOrNaN(axis.valueRange[0]) ? axis.extremeRange[0] : axis.valueRange[0];
	      var y1 = isNullUndefinedOrNaN(axis.valueRange[1]) ? axis.extremeRange[1] : axis.valueRange[1];
	      axis.computedValueRange = [y0, y1];
	    } else {
	      axis.computedValueRange = axis.extremeRange;
	    }
	    if (!ypadCompat) {
	      // When using yRangePad, adjust the upper/lower bounds to add
	      // padding unless the user has zoomed/panned the Y axis range.
	      if (logscale) {
	        y0 = axis.computedValueRange[0];
	        y1 = axis.computedValueRange[1];
	        var y0pct = ypad / (2 * ypad - 1);
	        var y1pct = (ypad - 1) / (2 * ypad - 1);
	        axis.computedValueRange[0] = utils.logRangeFraction(y0, y1, y0pct);
	        axis.computedValueRange[1] = utils.logRangeFraction(y0, y1, y1pct);
	      } else {
	        y0 = axis.computedValueRange[0];
	        y1 = axis.computedValueRange[1];
	        span = y1 - y0;
	        axis.computedValueRange[0] = y0 - span * ypad;
	        axis.computedValueRange[1] = y1 + span * ypad;
	      }
	    }

	    if (independentTicks) {
	      axis.independentTicks = independentTicks;
	      var opts = this.optionsViewForAxis_('y' + (i ? '2' : ''));
	      var ticker = opts('ticker');
	      axis.ticks = ticker(axis.computedValueRange[0], axis.computedValueRange[1], this.plotter_.area.h, opts, this);
	      // Define the first independent axis as primary axis.
	      if (!p_axis) p_axis = axis;
	    }
	  }
	  if (p_axis === undefined) {
	    throw "Configuration Error: At least one axis has to have the \"independentTicks\" option activated.";
	  }
	  // Add ticks. By default, all axes inherit the tick positions of the
	  // primary axis. However, if an axis is specifically marked as having
	  // independent ticks, then that is permissible as well.
	  for (var i = 0; i < numAxes; i++) {
	    var axis = this.axes_[i];

	    if (!axis.independentTicks) {
	      var opts = this.optionsViewForAxis_('y' + (i ? '2' : ''));
	      var ticker = opts('ticker');
	      var p_ticks = p_axis.ticks;
	      var p_scale = p_axis.computedValueRange[1] - p_axis.computedValueRange[0];
	      var scale = axis.computedValueRange[1] - axis.computedValueRange[0];
	      var tick_values = [];
	      for (var k = 0; k < p_ticks.length; k++) {
	        var y_frac = (p_ticks[k].v - p_axis.computedValueRange[0]) / p_scale;
	        var y_val = axis.computedValueRange[0] + y_frac * scale;
	        tick_values.push(y_val);
	      }

	      axis.ticks = ticker(axis.computedValueRange[0], axis.computedValueRange[1], this.plotter_.area.h, opts, this, tick_values);
	    }
	  }
	};

	/**
	 * Detects the type of the str (date or numeric) and sets the various
	 * formatting attributes in this.attrs_ based on this type.
	 * @param {string} str An x value.
	 * @private
	 */
	Dygraph.prototype.detectTypeFromString_ = function (str) {
	  var isDate = false;
	  var dashPos = str.indexOf('-'); // could be 2006-01-01 _or_ 1.0e-2
	  if (dashPos > 0 && str[dashPos - 1] != 'e' && str[dashPos - 1] != 'E' || str.indexOf('/') >= 0 || isNaN(parseFloat(str))) {
	    isDate = true;
	  } else if (str.length == 8 && str > '19700101' && str < '20371231') {
	    // TODO(danvk): remove support for this format.
	    isDate = true;
	  }

	  this.setXAxisOptions_(isDate);
	};

	Dygraph.prototype.setXAxisOptions_ = function (isDate) {
	  if (isDate) {
	    this.attrs_.xValueParser = utils.dateParser;
	    this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;
	    this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;
	    this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;
	  } else {
	    /** @private (shut up, jsdoc!) */
	    this.attrs_.xValueParser = function (x) {
	      return parseFloat(x);
	    };
	    // TODO(danvk): use Dygraph.numberValueFormatter here?
	    /** @private (shut up, jsdoc!) */
	    this.attrs_.axes.x.valueFormatter = function (x) {
	      return x;
	    };
	    this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;
	    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;
	  }
	};

	/**
	 * @private
	 * Parses a string in a special csv format.  We expect a csv file where each
	 * line is a date point, and the first field in each line is the date string.
	 * We also expect that all remaining fields represent series.
	 * if the errorBars attribute is set, then interpret the fields as:
	 * date, series1, stddev1, series2, stddev2, ...
	 * @param {[Object]} data See above.
	 *
	 * @return [Object] An array with one entry for each row. These entries
	 * are an array of cells in that row. The first entry is the parsed x-value for
	 * the row. The second, third, etc. are the y-values. These can take on one of
	 * three forms, depending on the CSV and constructor parameters:
	 * 1. numeric value
	 * 2. [ value, stddev ]
	 * 3. [ low value, center value, high value ]
	 */
	Dygraph.prototype.parseCSV_ = function (data) {
	  var ret = [];
	  var line_delimiter = utils.detectLineDelimiter(data);
	  var lines = data.split(line_delimiter || "\n");
	  var vals, j;

	  // Use the default delimiter or fall back to a tab if that makes sense.
	  var delim = this.getStringOption('delimiter');
	  if (lines[0].indexOf(delim) == -1 && lines[0].indexOf('\t') >= 0) {
	    delim = '\t';
	  }

	  var start = 0;
	  if (!('labels' in this.user_attrs_)) {
	    // User hasn't explicitly set labels, so they're (presumably) in the CSV.
	    start = 1;
	    this.attrs_.labels = lines[0].split(delim); // NOTE: _not_ user_attrs_.
	    this.attributes_.reparseSeries();
	  }
	  var line_no = 0;

	  var xParser;
	  var defaultParserSet = false; // attempt to auto-detect x value type
	  var expectedCols = this.attr_("labels").length;
	  var outOfOrder = false;
	  for (var i = start; i < lines.length; i++) {
	    var line = lines[i];
	    line_no = i;
	    if (line.length === 0) continue; // skip blank lines
	    if (line[0] == '#') continue; // skip comment lines
	    var inFields = line.split(delim);
	    if (inFields.length < 2) continue;

	    var fields = [];
	    if (!defaultParserSet) {
	      this.detectTypeFromString_(inFields[0]);
	      xParser = this.getFunctionOption("xValueParser");
	      defaultParserSet = true;
	    }
	    fields[0] = xParser(inFields[0], this);

	    // If fractions are expected, parse the numbers as "A/B"
	    if (this.fractions_) {
	      for (j = 1; j < inFields.length; j++) {
	        // TODO(danvk): figure out an appropriate way to flag parse errors.
	        vals = inFields[j].split("/");
	        if (vals.length != 2) {
	          console.error('Expected fractional "num/den" values in CSV data ' + "but found a value '" + inFields[j] + "' on line " + (1 + i) + " ('" + line + "') which is not of this form.");
	          fields[j] = [0, 0];
	        } else {
	          fields[j] = [utils.parseFloat_(vals[0], i, line), utils.parseFloat_(vals[1], i, line)];
	        }
	      }
	    } else if (this.getBooleanOption("errorBars")) {
	      // If there are error bars, values are (value, stddev) pairs
	      if (inFields.length % 2 != 1) {
	        console.error('Expected alternating (value, stdev.) pairs in CSV data ' + 'but line ' + (1 + i) + ' has an odd number of values (' + (inFields.length - 1) + "): '" + line + "'");
	      }
	      for (j = 1; j < inFields.length; j += 2) {
	        fields[(j + 1) / 2] = [utils.parseFloat_(inFields[j], i, line), utils.parseFloat_(inFields[j + 1], i, line)];
	      }
	    } else if (this.getBooleanOption("customBars")) {
	      // Bars are a low;center;high tuple
	      for (j = 1; j < inFields.length; j++) {
	        var val = inFields[j];
	        if (/^ *$/.test(val)) {
	          fields[j] = [null, null, null];
	        } else {
	          vals = val.split(";");
	          if (vals.length == 3) {
	            fields[j] = [utils.parseFloat_(vals[0], i, line), utils.parseFloat_(vals[1], i, line), utils.parseFloat_(vals[2], i, line)];
	          } else {
	            console.warn('When using customBars, values must be either blank ' + 'or "low;center;high" tuples (got "' + val + '" on line ' + (1 + i));
	          }
	        }
	      }
	    } else {
	      // Values are just numbers
	      for (j = 1; j < inFields.length; j++) {
	        fields[j] = utils.parseFloat_(inFields[j], i, line);
	      }
	    }
	    if (ret.length > 0 && fields[0] < ret[ret.length - 1][0]) {
	      outOfOrder = true;
	    }

	    if (fields.length != expectedCols) {
	      console.error("Number of columns in line " + i + " (" + fields.length + ") does not agree with number of labels (" + expectedCols + ") " + line);
	    }

	    // If the user specified the 'labels' option and none of the cells of the
	    // first row parsed correctly, then they probably double-specified the
	    // labels. We go with the values set in the option, discard this row and
	    // log a warning to the JS console.
	    if (i === 0 && this.attr_('labels')) {
	      var all_null = true;
	      for (j = 0; all_null && j < fields.length; j++) {
	        if (fields[j]) all_null = false;
	      }
	      if (all_null) {
	        console.warn("The dygraphs 'labels' option is set, but the first row " + "of CSV data ('" + line + "') appears to also contain " + "labels. Will drop the CSV labels and use the option " + "labels.");
	        continue;
	      }
	    }
	    ret.push(fields);
	  }

	  if (outOfOrder) {
	    console.warn("CSV is out of order; order it correctly to speed loading.");
	    ret.sort(function (a, b) {
	      return a[0] - b[0];
	    });
	  }

	  return ret;
	};

	// In native format, all values must be dates or numbers.
	// This check isn't perfect but will catch most mistaken uses of strings.
	function validateNativeFormat(data) {
	  var firstRow = data[0];
	  var firstX = firstRow[0];
	  if (typeof firstX !== 'number' && !utils.isDateLike(firstX)) {
	    throw new Error('Expected number or date but got ' + typeof firstX + ': ' + firstX + '.');
	  }
	  for (var i = 1; i < firstRow.length; i++) {
	    var val = firstRow[i];
	    if (val === null || val === undefined) continue;
	    if (typeof val === 'number') continue;
	    if (utils.isArrayLike(val)) continue; // e.g. error bars or custom bars.
	    throw new Error('Expected number or array but got ' + typeof val + ': ' + val + '.');
	  }
	}

	/**
	 * The user has provided their data as a pre-packaged JS array. If the x values
	 * are numeric, this is the same as dygraphs' internal format. If the x values
	 * are dates, we need to convert them from Date objects to ms since epoch.
	 * @param {!Array} data
	 * @return {Object} data with numeric x values.
	 * @private
	 */
	Dygraph.prototype.parseArray_ = function (data) {
	  // Peek at the first x value to see if it's numeric.
	  if (data.length === 0) {
	    console.error("Can't plot empty data set");
	    return null;
	  }
	  if (data[0].length === 0) {
	    console.error("Data set cannot contain an empty row");
	    return null;
	  }

	  validateNativeFormat(data);

	  var i;
	  if (this.attr_("labels") === null) {
	    console.warn("Using default labels. Set labels explicitly via 'labels' " + "in the options parameter");
	    this.attrs_.labels = ["X"];
	    for (i = 1; i < data[0].length; i++) {
	      this.attrs_.labels.push("Y" + i); // Not user_attrs_.
	    }
	    this.attributes_.reparseSeries();
	  } else {
	    var num_labels = this.attr_("labels");
	    if (num_labels.length != data[0].length) {
	      console.error("Mismatch between number of labels (" + num_labels + ")" + " and number of columns in array (" + data[0].length + ")");
	      return null;
	    }
	  }

	  if (utils.isDateLike(data[0][0])) {
	    // Some intelligent defaults for a date x-axis.
	    this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;
	    this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;
	    this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;

	    // Assume they're all dates.
	    var parsedData = utils.clone(data);
	    for (i = 0; i < data.length; i++) {
	      if (parsedData[i].length === 0) {
	        console.error("Row " + (1 + i) + " of data is empty");
	        return null;
	      }
	      if (parsedData[i][0] === null || typeof parsedData[i][0].getTime != 'function' || isNaN(parsedData[i][0].getTime())) {
	        console.error("x value in row " + (1 + i) + " is not a Date");
	        return null;
	      }
	      parsedData[i][0] = parsedData[i][0].getTime();
	    }
	    return parsedData;
	  } else {
	    // Some intelligent defaults for a numeric x-axis.
	    /** @private (shut up, jsdoc!) */
	    this.attrs_.axes.x.valueFormatter = function (x) {
	      return x;
	    };
	    this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;
	    this.attrs_.axes.x.axisLabelFormatter = utils.numberAxisLabelFormatter;
	    return data;
	  }
	};

	/**
	 * Parses a DataTable object from gviz.
	 * The data is expected to have a first column that is either a date or a
	 * number. All subsequent columns must be numbers. If there is a clear mismatch
	 * between this.xValueParser_ and the type of the first column, it will be
	 * fixed. Fills out rawData_.
	 * @param {!google.visualization.DataTable} data See above.
	 * @private
	 */
	Dygraph.prototype.parseDataTable_ = function (data) {
	  var shortTextForAnnotationNum = function shortTextForAnnotationNum(num) {
	    // converts [0-9]+ [A-Z][a-z]*
	    // example: 0=A, 1=B, 25=Z, 26=Aa, 27=Ab
	    // and continues like.. Ba Bb .. Za .. Zz..Aaa...Zzz Aaaa Zzzz
	    var shortText = String.fromCharCode(65 /* A */ + num % 26);
	    num = Math.floor(num / 26);
	    while (num > 0) {
	      shortText = String.fromCharCode(65 /* A */ + (num - 1) % 26) + shortText.toLowerCase();
	      num = Math.floor((num - 1) / 26);
	    }
	    return shortText;
	  };

	  var cols = data.getNumberOfColumns();
	  var rows = data.getNumberOfRows();

	  var indepType = data.getColumnType(0);
	  if (indepType == 'date' || indepType == 'datetime') {
	    this.attrs_.xValueParser = utils.dateParser;
	    this.attrs_.axes.x.valueFormatter = utils.dateValueFormatter;
	    this.attrs_.axes.x.ticker = DygraphTickers.dateTicker;
	    this.attrs_.axes.x.axisLabelFormatter = utils.dateAxisLabelFormatter;
	  } else if (indepType == 'number') {
	    this.attrs_.xValueParser = function (x) {
	      return parseFloat(x);
	    };
	    this.attrs_.axes.x.valueFormatter = function (x) {
	      return x;
	    };
	    this.attrs_.axes.x.ticker = DygraphTickers.numericTicks;
	    this.attrs_.axes.x.axisLabelFormatter = this.attrs_.axes.x.valueFormatter;
	  } else {
	    throw new Error("only 'date', 'datetime' and 'number' types are supported " + "for column 1 of DataTable input (Got '" + indepType + "')");
	  }

	  // Array of the column indices which contain data (and not annotations).
	  var colIdx = [];
	  var annotationCols = {}; // data index -> [annotation cols]
	  var hasAnnotations = false;
	  var i, j;
	  for (i = 1; i < cols; i++) {
	    var type = data.getColumnType(i);
	    if (type == 'number') {
	      colIdx.push(i);
	    } else if (type == 'string' && this.getBooleanOption('displayAnnotations')) {
	      // This is OK -- it's an annotation column.
	      var dataIdx = colIdx[colIdx.length - 1];
	      if (!annotationCols.hasOwnProperty(dataIdx)) {
	        annotationCols[dataIdx] = [i];
	      } else {
	        annotationCols[dataIdx].push(i);
	      }
	      hasAnnotations = true;
	    } else {
	      throw new Error("Only 'number' is supported as a dependent type with Gviz." + " 'string' is only supported if displayAnnotations is true");
	    }
	  }

	  // Read column labels
	  // TODO(danvk): add support back for errorBars
	  var labels = [data.getColumnLabel(0)];
	  for (i = 0; i < colIdx.length; i++) {
	    labels.push(data.getColumnLabel(colIdx[i]));
	    if (this.getBooleanOption("errorBars")) i += 1;
	  }
	  this.attrs_.labels = labels;
	  cols = labels.length;

	  var ret = [];
	  var outOfOrder = false;
	  var annotations = [];
	  for (i = 0; i < rows; i++) {
	    var row = [];
	    if (typeof data.getValue(i, 0) === 'undefined' || data.getValue(i, 0) === null) {
	      console.warn("Ignoring row " + i + " of DataTable because of undefined or null first column.");
	      continue;
	    }

	    if (indepType == 'date' || indepType == 'datetime') {
	      row.push(data.getValue(i, 0).getTime());
	    } else {
	      row.push(data.getValue(i, 0));
	    }
	    if (!this.getBooleanOption("errorBars")) {
	      for (j = 0; j < colIdx.length; j++) {
	        var col = colIdx[j];
	        row.push(data.getValue(i, col));
	        if (hasAnnotations && annotationCols.hasOwnProperty(col) && data.getValue(i, annotationCols[col][0]) !== null) {
	          var ann = {};
	          ann.series = data.getColumnLabel(col);
	          ann.xval = row[0];
	          ann.shortText = shortTextForAnnotationNum(annotations.length);
	          ann.text = '';
	          for (var k = 0; k < annotationCols[col].length; k++) {
	            if (k) ann.text += "\n";
	            ann.text += data.getValue(i, annotationCols[col][k]);
	          }
	          annotations.push(ann);
	        }
	      }

	      // Strip out infinities, which give dygraphs problems later on.
	      for (j = 0; j < row.length; j++) {
	        if (!isFinite(row[j])) row[j] = null;
	      }
	    } else {
	      for (j = 0; j < cols - 1; j++) {
	        row.push([data.getValue(i, 1 + 2 * j), data.getValue(i, 2 + 2 * j)]);
	      }
	    }
	    if (ret.length > 0 && row[0] < ret[ret.length - 1][0]) {
	      outOfOrder = true;
	    }
	    ret.push(row);
	  }

	  if (outOfOrder) {
	    console.warn("DataTable is out of order; order it correctly to speed loading.");
	    ret.sort(function (a, b) {
	      return a[0] - b[0];
	    });
	  }
	  this.rawData_ = ret;

	  if (annotations.length > 0) {
	    this.setAnnotations(annotations, true);
	  }
	  this.attributes_.reparseSeries();
	};

	/**
	 * Signals to plugins that the chart data has updated.
	 * This happens after the data has updated but before the chart has redrawn.
	 * @private
	 */
	Dygraph.prototype.cascadeDataDidUpdateEvent_ = function () {
	  // TODO(danvk): there are some issues checking xAxisRange() and using
	  // toDomCoords from handlers of this event. The visible range should be set
	  // when the chart is drawn, not derived from the data.
	  this.cascadeEvents_('dataDidUpdate', {});
	};

	/**
	 * Get the CSV data. If it's in a function, call that function. If it's in a
	 * file, do an XMLHttpRequest to get it.
	 * @private
	 */
	Dygraph.prototype.start_ = function () {
	  var data = this.file_;

	  // Functions can return references of all other types.
	  if (typeof data == 'function') {
	    data = data();
	  }

	  if (utils.isArrayLike(data)) {
	    this.rawData_ = this.parseArray_(data);
	    this.cascadeDataDidUpdateEvent_();
	    this.predraw_();
	  } else if (typeof data == 'object' && typeof data.getColumnRange == 'function') {
	    // must be a DataTable from gviz.
	    this.parseDataTable_(data);
	    this.cascadeDataDidUpdateEvent_();
	    this.predraw_();
	  } else if (typeof data == 'string') {
	    // Heuristic: a newline means it's CSV data. Otherwise it's an URL.
	    var line_delimiter = utils.detectLineDelimiter(data);
	    if (line_delimiter) {
	      this.loadedEvent_(data);
	    } else {
	      // REMOVE_FOR_IE
	      var req;
	      if (window.XMLHttpRequest) {
	        // Firefox, Opera, IE7, and other browsers will use the native object
	        req = new XMLHttpRequest();
	      } else {
	        // IE 5 and 6 will use the ActiveX control
	        req = new ActiveXObject("Microsoft.XMLHTTP");
	      }

	      var caller = this;
	      req.onreadystatechange = function () {
	        if (req.readyState == 4) {
	          if (req.status === 200 || // Normal http
	          req.status === 0) {
	            // Chrome w/ --allow-file-access-from-files
	            caller.loadedEvent_(req.responseText);
	          }
	        }
	      };

	      req.open("GET", data, true);
	      req.send(null);
	    }
	  } else {
	    console.error("Unknown data format: " + typeof data);
	  }
	};

	/**
	 * Changes various properties of the graph. These can include:
	 * <ul>
	 * <li>file: changes the source data for the graph</li>
	 * <li>errorBars: changes whether the data contains stddev</li>
	 * </ul>
	 *
	 * There's a huge variety of options that can be passed to this method. For a
	 * full list, see http://dygraphs.com/options.html.
	 *
	 * @param {Object} input_attrs The new properties and values
	 * @param {boolean} block_redraw Usually the chart is redrawn after every
	 *     call to updateOptions(). If you know better, you can pass true to
	 *     explicitly block the redraw. This can be useful for chaining
	 *     updateOptions() calls, avoiding the occasional infinite loop and
	 *     preventing redraws when it's not necessary (e.g. when updating a
	 *     callback).
	 */
	Dygraph.prototype.updateOptions = function (input_attrs, block_redraw) {
	  if (typeof block_redraw == 'undefined') block_redraw = false;

	  // copyUserAttrs_ drops the "file" parameter as a convenience to us.
	  var file = input_attrs.file;
	  var attrs = Dygraph.copyUserAttrs_(input_attrs);

	  // TODO(danvk): this is a mess. Move these options into attr_.
	  if ('rollPeriod' in attrs) {
	    this.rollPeriod_ = attrs.rollPeriod;
	  }
	  if ('dateWindow' in attrs) {
	    this.dateWindow_ = attrs.dateWindow;
	  }

	  // TODO(danvk): validate per-series options.
	  // Supported:
	  // strokeWidth
	  // pointSize
	  // drawPoints
	  // highlightCircleSize

	  // Check if this set options will require new points.
	  var requiresNewPoints = utils.isPixelChangingOptionList(this.attr_("labels"), attrs);

	  utils.updateDeep(this.user_attrs_, attrs);

	  this.attributes_.reparseSeries();

	  if (file) {
	    // This event indicates that the data is about to change, but hasn't yet.
	    // TODO(danvk): support cancelation of the update via this event.
	    this.cascadeEvents_('dataWillUpdate', {});

	    this.file_ = file;
	    if (!block_redraw) this.start_();
	  } else {
	    if (!block_redraw) {
	      if (requiresNewPoints) {
	        this.predraw_();
	      } else {
	        this.renderGraph_(false);
	      }
	    }
	  }
	};

	/**
	 * Make a copy of input attributes, removing file as a convenience.
	 * @private
	 */
	Dygraph.copyUserAttrs_ = function (attrs) {
	  var my_attrs = {};
	  for (var k in attrs) {
	    if (!attrs.hasOwnProperty(k)) continue;
	    if (k == 'file') continue;
	    if (attrs.hasOwnProperty(k)) my_attrs[k] = attrs[k];
	  }
	  return my_attrs;
	};

	/**
	 * Resizes the dygraph. If no parameters are specified, resizes to fill the
	 * containing div (which has presumably changed size since the dygraph was
	 * instantiated. If the width/height are specified, the div will be resized.
	 *
	 * This is far more efficient than destroying and re-instantiating a
	 * Dygraph, since it doesn't have to reparse the underlying data.
	 *
	 * @param {number} width Width (in pixels)
	 * @param {number} height Height (in pixels)
	 */
	Dygraph.prototype.resize = function (width, height) {
	  if (this.resize_lock) {
	    return;
	  }
	  this.resize_lock = true;

	  if (width === null != (height === null)) {
	    console.warn("Dygraph.resize() should be called with zero parameters or " + "two non-NULL parameters. Pretending it was zero.");
	    width = height = null;
	  }

	  var old_width = this.width_;
	  var old_height = this.height_;

	  if (width) {
	    this.maindiv_.style.width = width + "px";
	    this.maindiv_.style.height = height + "px";
	    this.width_ = width;
	    this.height_ = height;
	  } else {
	    this.width_ = this.maindiv_.clientWidth;
	    this.height_ = this.maindiv_.clientHeight;
	  }

	  if (old_width != this.width_ || old_height != this.height_) {
	    // Resizing a canvas erases it, even when the size doesn't change, so
	    // any resize needs to be followed by a redraw.
	    this.resizeElements_();
	    this.predraw_();
	  }

	  this.resize_lock = false;
	};

	/**
	 * Adjusts the number of points in the rolling average. Updates the graph to
	 * reflect the new averaging period.
	 * @param {number} length Number of points over which to average the data.
	 */
	Dygraph.prototype.adjustRoll = function (length) {
	  this.rollPeriod_ = length;
	  this.predraw_();
	};

	/**
	 * Returns a boolean array of visibility statuses.
	 */
	Dygraph.prototype.visibility = function () {
	  // Do lazy-initialization, so that this happens after we know the number of
	  // data series.
	  if (!this.getOption("visibility")) {
	    this.attrs_.visibility = [];
	  }
	  // TODO(danvk): it looks like this could go into an infinite loop w/ user_attrs.
	  while (this.getOption("visibility").length < this.numColumns() - 1) {
	    this.attrs_.visibility.push(true);
	  }
	  return this.getOption("visibility");
	};

	/**
	 * Changes the visibility of one or more series.
	 *
	 * @param {number|number[]|object} num the series index or an array of series indices
	 *                                     or a boolean array of visibility states by index
	 *                                     or an object mapping series numbers, as keys, to
	 *                                     visibility state (boolean values)
	 * @param {boolean} value the visibility state expressed as a boolean
	 */
	Dygraph.prototype.setVisibility = function (num, value) {
	  var x = this.visibility();
	  var numIsObject = false;

	  if (!Array.isArray(num)) {
	    if (num !== null && typeof num === 'object') {
	      numIsObject = true;
	    } else {
	      num = [num];
	    }
	  }

	  if (numIsObject) {
	    for (var i in num) {
	      if (num.hasOwnProperty(i)) {
	        if (i < 0 || i >= x.length) {
	          console.warn("Invalid series number in setVisibility: " + i);
	        } else {
	          x[i] = num[i];
	        }
	      }
	    }
	  } else {
	    for (var i = 0; i < num.length; i++) {
	      if (typeof num[i] === 'boolean') {
	        if (i >= x.length) {
	          console.warn("Invalid series number in setVisibility: " + i);
	        } else {
	          x[i] = num[i];
	        }
	      } else {
	        if (num[i] < 0 || num[i] >= x.length) {
	          console.warn("Invalid series number in setVisibility: " + num[i]);
	        } else {
	          x[num[i]] = value;
	        }
	      }
	    }
	  }

	  this.predraw_();
	};

	/**
	 * How large of an area will the dygraph render itself in?
	 * This is used for testing.
	 * @return A {width: w, height: h} object.
	 * @private
	 */
	Dygraph.prototype.size = function () {
	  return { width: this.width_, height: this.height_ };
	};

	/**
	 * Update the list of annotations and redraw the chart.
	 * See dygraphs.com/annotations.html for more info on how to use annotations.
	 * @param ann {Array} An array of annotation objects.
	 * @param suppressDraw {Boolean} Set to "true" to block chart redraw (optional).
	 */
	Dygraph.prototype.setAnnotations = function (ann, suppressDraw) {
	  // Only add the annotation CSS rule once we know it will be used.
	  this.annotations_ = ann;
	  if (!this.layout_) {
	    console.warn("Tried to setAnnotations before dygraph was ready. " + "Try setting them in a ready() block. See " + "dygraphs.com/tests/annotation.html");
	    return;
	  }

	  this.layout_.setAnnotations(this.annotations_);
	  if (!suppressDraw) {
	    this.predraw_();
	  }
	};

	/**
	 * Return the list of annotations.
	 */
	Dygraph.prototype.annotations = function () {
	  return this.annotations_;
	};

	/**
	 * Get the list of label names for this graph. The first column is the
	 * x-axis, so the data series names start at index 1.
	 *
	 * Returns null when labels have not yet been defined.
	 */
	Dygraph.prototype.getLabels = function () {
	  var labels = this.attr_("labels");
	  return labels ? labels.slice() : null;
	};

	/**
	 * Get the index of a series (column) given its name. The first column is the
	 * x-axis, so the data series start with index 1.
	 */
	Dygraph.prototype.indexFromSetName = function (name) {
	  return this.setIndexByName_[name];
	};

	/**
	 * Find the row number corresponding to the given x-value.
	 * Returns null if there is no such x-value in the data.
	 * If there are multiple rows with the same x-value, this will return the
	 * first one.
	 * @param {number} xVal The x-value to look for (e.g. millis since epoch).
	 * @return {?number} The row number, which you can pass to getValue(), or null.
	 */
	Dygraph.prototype.getRowForX = function (xVal) {
	  var low = 0,
	      high = this.numRows() - 1;

	  while (low <= high) {
	    var idx = high + low >> 1;
	    var x = this.getValue(idx, 0);
	    if (x < xVal) {
	      low = idx + 1;
	    } else if (x > xVal) {
	      high = idx - 1;
	    } else if (low != idx) {
	      // equal, but there may be an earlier match.
	      high = idx;
	    } else {
	      return idx;
	    }
	  }

	  return null;
	};

	/**
	 * Trigger a callback when the dygraph has drawn itself and is ready to be
	 * manipulated. This is primarily useful when dygraphs has to do an XHR for the
	 * data (i.e. a URL is passed as the data source) and the chart is drawn
	 * asynchronously. If the chart has already drawn, the callback will fire
	 * immediately.
	 *
	 * This is a good place to call setAnnotation().
	 *
	 * @param {function(!Dygraph)} callback The callback to trigger when the chart
	 *     is ready.
	 */
	Dygraph.prototype.ready = function (callback) {
	  if (this.is_initial_draw_) {
	    this.readyFns_.push(callback);
	  } else {
	    callback.call(this, this);
	  }
	};

	/**
	 * Add an event handler. This event handler is kept until the graph is
	 * destroyed with a call to graph.destroy().
	 *
	 * @param {!Node} elem The element to add the event to.
	 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
	 * @param {function(Event):(boolean|undefined)} fn The function to call
	 *     on the event. The function takes one parameter: the event object.
	 * @private
	 */
	Dygraph.prototype.addAndTrackEvent = function (elem, type, fn) {
	  utils.addEvent(elem, type, fn);
	  this.registeredEvents_.push({ elem: elem, type: type, fn: fn });
	};

	Dygraph.prototype.removeTrackedEvents_ = function () {
	  if (this.registeredEvents_) {
	    for (var idx = 0; idx < this.registeredEvents_.length; idx++) {
	      var reg = this.registeredEvents_[idx];
	      utils.removeEvent(reg.elem, reg.type, reg.fn);
	    }
	  }

	  this.registeredEvents_ = [];
	};

	// Installed plugins, in order of precedence (most-general to most-specific).
	Dygraph.PLUGINS = [_pluginsLegend2['default'], _pluginsAxes2['default'], _pluginsRangeSelector2['default'], // Has to be before ChartLabels so that its callbacks are called after ChartLabels' callbacks.
	_pluginsChartLabels2['default'], _pluginsAnnotations2['default'], _pluginsGrid2['default']];

	// There are many symbols which have historically been available through the
	// Dygraph class. These are exported here for backwards compatibility.
	Dygraph.GVizChart = _dygraphGviz2['default'];
	Dygraph.DASHED_LINE = utils.DASHED_LINE;
	Dygraph.DOT_DASH_LINE = utils.DOT_DASH_LINE;
	Dygraph.dateAxisLabelFormatter = utils.dateAxisLabelFormatter;
	Dygraph.toRGB_ = utils.toRGB_;
	Dygraph.findPos = utils.findPos;
	Dygraph.pageX = utils.pageX;
	Dygraph.pageY = utils.pageY;
	Dygraph.dateString_ = utils.dateString_;
	Dygraph.defaultInteractionModel = _dygraphInteractionModel2['default'].defaultModel;
	Dygraph.nonInteractiveModel = Dygraph.nonInteractiveModel_ = _dygraphInteractionModel2['default'].nonInteractiveModel_;
	Dygraph.Circles = utils.Circles;

	Dygraph.Plugins = {
	  Legend: _pluginsLegend2['default'],
	  Axes: _pluginsAxes2['default'],
	  Annotations: _pluginsAnnotations2['default'],
	  ChartLabels: _pluginsChartLabels2['default'],
	  Grid: _pluginsGrid2['default'],
	  RangeSelector: _pluginsRangeSelector2['default']
	};

	Dygraph.DataHandlers = {
	  DefaultHandler: _datahandlerDefault2['default'],
	  BarsHandler: _datahandlerBars2['default'],
	  CustomBarsHandler: _datahandlerBarsCustom2['default'],
	  DefaultFractionHandler: _datahandlerDefaultFractions2['default'],
	  ErrorBarsHandler: _datahandlerBarsError2['default'],
	  FractionsBarsHandler: _datahandlerBarsFractions2['default']
	};

	Dygraph.startPan = _dygraphInteractionModel2['default'].startPan;
	Dygraph.startZoom = _dygraphInteractionModel2['default'].startZoom;
	Dygraph.movePan = _dygraphInteractionModel2['default'].movePan;
	Dygraph.moveZoom = _dygraphInteractionModel2['default'].moveZoom;
	Dygraph.endPan = _dygraphInteractionModel2['default'].endPan;
	Dygraph.endZoom = _dygraphInteractionModel2['default'].endZoom;

	Dygraph.numericLinearTicks = DygraphTickers.numericLinearTicks;
	Dygraph.numericTicks = DygraphTickers.numericTicks;
	Dygraph.dateTicker = DygraphTickers.dateTicker;
	Dygraph.Granularity = DygraphTickers.Granularity;
	Dygraph.getDateAxis = DygraphTickers.getDateAxis;
	Dygraph.floatFormat = utils.floatFormat;

	exports['default'] = Dygraph;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview Based on PlotKitLayout, but modified to meet the needs of
	 * dygraphs.
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	/**
	 * Creates a new DygraphLayout object.
	 *
	 * This class contains all the data to be charted.
	 * It uses data coordinates, but also records the chart range (in data
	 * coordinates) and hence is able to calculate percentage positions ('In this
	 * view, Point A lies 25% down the x-axis.')
	 *
	 * Two things that it does not do are:
	 * 1. Record pixel coordinates for anything.
	 * 2. (oddly) determine anything about the layout of chart elements.
	 *
	 * The naming is a vestige of Dygraph's original PlotKit roots.
	 *
	 * @constructor
	 */
	var DygraphLayout = function DygraphLayout(dygraph) {
	  this.dygraph_ = dygraph;
	  /**
	   * Array of points for each series.
	   *
	   * [series index][row index in series] = |Point| structure,
	   * where series index refers to visible series only, and the
	   * point index is for the reduced set of points for the current
	   * zoom region (including one point just outside the window).
	   * All points in the same row index share the same X value.
	   *
	   * @type {Array.<Array.<Dygraph.PointType>>}
	   */
	  this.points = [];
	  this.setNames = [];
	  this.annotations = [];
	  this.yAxes_ = null;

	  // TODO(danvk): it's odd that xTicks_ and yTicks_ are inputs, but xticks and
	  // yticks are outputs. Clean this up.
	  this.xTicks_ = null;
	  this.yTicks_ = null;
	};

	/**
	 * Add points for a single series.
	 *
	 * @param {string} setname Name of the series.
	 * @param {Array.<Dygraph.PointType>} set_xy Points for the series.
	 */
	DygraphLayout.prototype.addDataset = function (setname, set_xy) {
	  this.points.push(set_xy);
	  this.setNames.push(setname);
	};

	/**
	 * Returns the box which the chart should be drawn in. This is the canvas's
	 * box, less space needed for the axis and chart labels.
	 *
	 * @return {{x: number, y: number, w: number, h: number}}
	 */
	DygraphLayout.prototype.getPlotArea = function () {
	  return this.area_;
	};

	// Compute the box which the chart should be drawn in. This is the canvas's
	// box, less space needed for axis, chart labels, and other plug-ins.
	// NOTE: This should only be called by Dygraph.predraw_().
	DygraphLayout.prototype.computePlotArea = function () {
	  var area = {
	    // TODO(danvk): per-axis setting.
	    x: 0,
	    y: 0
	  };

	  area.w = this.dygraph_.width_ - area.x - this.dygraph_.getOption('rightGap');
	  area.h = this.dygraph_.height_;

	  // Let plugins reserve space.
	  var e = {
	    chart_div: this.dygraph_.graphDiv,
	    reserveSpaceLeft: function reserveSpaceLeft(px) {
	      var r = {
	        x: area.x,
	        y: area.y,
	        w: px,
	        h: area.h
	      };
	      area.x += px;
	      area.w -= px;
	      return r;
	    },
	    reserveSpaceRight: function reserveSpaceRight(px) {
	      var r = {
	        x: area.x + area.w - px,
	        y: area.y,
	        w: px,
	        h: area.h
	      };
	      area.w -= px;
	      return r;
	    },
	    reserveSpaceTop: function reserveSpaceTop(px) {
	      var r = {
	        x: area.x,
	        y: area.y,
	        w: area.w,
	        h: px
	      };
	      area.y += px;
	      area.h -= px;
	      return r;
	    },
	    reserveSpaceBottom: function reserveSpaceBottom(px) {
	      var r = {
	        x: area.x,
	        y: area.y + area.h - px,
	        w: area.w,
	        h: px
	      };
	      area.h -= px;
	      return r;
	    },
	    chartRect: function chartRect() {
	      return { x: area.x, y: area.y, w: area.w, h: area.h };
	    }
	  };
	  this.dygraph_.cascadeEvents_('layout', e);

	  this.area_ = area;
	};

	DygraphLayout.prototype.setAnnotations = function (ann) {
	  // The Dygraph object's annotations aren't parsed. We parse them here and
	  // save a copy. If there is no parser, then the user must be using raw format.
	  this.annotations = [];
	  var parse = this.dygraph_.getOption('xValueParser') || function (x) {
	    return x;
	  };
	  for (var i = 0; i < ann.length; i++) {
	    var a = {};
	    if (!ann[i].xval && ann[i].x === undefined) {
	      console.error("Annotations must have an 'x' property");
	      return;
	    }
	    if (ann[i].icon && !(ann[i].hasOwnProperty('width') && ann[i].hasOwnProperty('height'))) {
	      console.error("Must set width and height when setting " + "annotation.icon property");
	      return;
	    }
	    utils.update(a, ann[i]);
	    if (!a.xval) a.xval = parse(a.x);
	    this.annotations.push(a);
	  }
	};

	DygraphLayout.prototype.setXTicks = function (xTicks) {
	  this.xTicks_ = xTicks;
	};

	// TODO(danvk): add this to the Dygraph object's API or move it into Layout.
	DygraphLayout.prototype.setYAxes = function (yAxes) {
	  this.yAxes_ = yAxes;
	};

	DygraphLayout.prototype.evaluate = function () {
	  this._xAxis = {};
	  this._evaluateLimits();
	  this._evaluateLineCharts();
	  this._evaluateLineTicks();
	  this._evaluateAnnotations();
	};

	DygraphLayout.prototype._evaluateLimits = function () {
	  var xlimits = this.dygraph_.xAxisRange();
	  this._xAxis.minval = xlimits[0];
	  this._xAxis.maxval = xlimits[1];
	  var xrange = xlimits[1] - xlimits[0];
	  this._xAxis.scale = xrange !== 0 ? 1 / xrange : 1.0;

	  if (this.dygraph_.getOptionForAxis("logscale", 'x')) {
	    this._xAxis.xlogrange = utils.log10(this._xAxis.maxval) - utils.log10(this._xAxis.minval);
	    this._xAxis.xlogscale = this._xAxis.xlogrange !== 0 ? 1.0 / this._xAxis.xlogrange : 1.0;
	  }
	  for (var i = 0; i < this.yAxes_.length; i++) {
	    var axis = this.yAxes_[i];
	    axis.minyval = axis.computedValueRange[0];
	    axis.maxyval = axis.computedValueRange[1];
	    axis.yrange = axis.maxyval - axis.minyval;
	    axis.yscale = axis.yrange !== 0 ? 1.0 / axis.yrange : 1.0;

	    if (this.dygraph_.getOption("logscale")) {
	      axis.ylogrange = utils.log10(axis.maxyval) - utils.log10(axis.minyval);
	      axis.ylogscale = axis.ylogrange !== 0 ? 1.0 / axis.ylogrange : 1.0;
	      if (!isFinite(axis.ylogrange) || isNaN(axis.ylogrange)) {
	        console.error('axis ' + i + ' of graph at ' + axis.g + ' can\'t be displayed in log scale for range [' + axis.minyval + ' - ' + axis.maxyval + ']');
	      }
	    }
	  }
	};

	DygraphLayout.calcXNormal_ = function (value, xAxis, logscale) {
	  if (logscale) {
	    return (utils.log10(value) - utils.log10(xAxis.minval)) * xAxis.xlogscale;
	  } else {
	    return (value - xAxis.minval) * xAxis.scale;
	  }
	};

	/**
	 * @param {DygraphAxisType} axis
	 * @param {number} value
	 * @param {boolean} logscale
	 * @return {number}
	 */
	DygraphLayout.calcYNormal_ = function (axis, value, logscale) {
	  if (logscale) {
	    var x = 1.0 - (utils.log10(value) - utils.log10(axis.minyval)) * axis.ylogscale;
	    return isFinite(x) ? x : NaN; // shim for v8 issue; see pull request 276
	  } else {
	      return 1.0 - (value - axis.minyval) * axis.yscale;
	    }
	};

	DygraphLayout.prototype._evaluateLineCharts = function () {
	  var isStacked = this.dygraph_.getOption("stackedGraph");
	  var isLogscaleForX = this.dygraph_.getOptionForAxis("logscale", 'x');

	  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {
	    var points = this.points[setIdx];
	    var setName = this.setNames[setIdx];
	    var connectSeparated = this.dygraph_.getOption('connectSeparatedPoints', setName);
	    var axis = this.dygraph_.axisPropertiesForSeries(setName);
	    // TODO (konigsberg): use optionsForAxis instead.
	    var logscale = this.dygraph_.attributes_.getForSeries("logscale", setName);

	    for (var j = 0; j < points.length; j++) {
	      var point = points[j];

	      // Range from 0-1 where 0 represents left and 1 represents right.
	      point.x = DygraphLayout.calcXNormal_(point.xval, this._xAxis, isLogscaleForX);
	      // Range from 0-1 where 0 represents top and 1 represents bottom
	      var yval = point.yval;
	      if (isStacked) {
	        point.y_stacked = DygraphLayout.calcYNormal_(axis, point.yval_stacked, logscale);
	        if (yval !== null && !isNaN(yval)) {
	          yval = point.yval_stacked;
	        }
	      }
	      if (yval === null) {
	        yval = NaN;
	        if (!connectSeparated) {
	          point.yval = NaN;
	        }
	      }
	      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);
	    }

	    this.dygraph_.dataHandler_.onLineEvaluated(points, axis, logscale);
	  }
	};

	DygraphLayout.prototype._evaluateLineTicks = function () {
	  var i, tick, label, pos, v, has_tick;
	  this.xticks = [];
	  for (i = 0; i < this.xTicks_.length; i++) {
	    tick = this.xTicks_[i];
	    label = tick.label;
	    has_tick = !('label_v' in tick);
	    v = has_tick ? tick.v : tick.label_v;
	    pos = this.dygraph_.toPercentXCoord(v);
	    if (pos >= 0.0 && pos < 1.0) {
	      this.xticks.push({ pos: pos, label: label, has_tick: has_tick });
	    }
	  }

	  this.yticks = [];
	  for (i = 0; i < this.yAxes_.length; i++) {
	    var axis = this.yAxes_[i];
	    for (var j = 0; j < axis.ticks.length; j++) {
	      tick = axis.ticks[j];
	      label = tick.label;
	      has_tick = !('label_v' in tick);
	      v = has_tick ? tick.v : tick.label_v;
	      pos = this.dygraph_.toPercentYCoord(v, i);
	      if (pos > 0.0 && pos <= 1.0) {
	        this.yticks.push({ axis: i, pos: pos, label: label, has_tick: has_tick });
	      }
	    }
	  }
	};

	DygraphLayout.prototype._evaluateAnnotations = function () {
	  // Add the annotations to the point to which they belong.
	  // Make a map from (setName, xval) to annotation for quick lookups.
	  var i;
	  var annotations = {};
	  for (i = 0; i < this.annotations.length; i++) {
	    var a = this.annotations[i];
	    annotations[a.xval + "," + a.series] = a;
	  }

	  this.annotated_points = [];

	  // Exit the function early if there are no annotations.
	  if (!this.annotations || !this.annotations.length) {
	    return;
	  }

	  // TODO(antrob): loop through annotations not points.
	  for (var setIdx = 0; setIdx < this.points.length; setIdx++) {
	    var points = this.points[setIdx];
	    for (i = 0; i < points.length; i++) {
	      var p = points[i];
	      var k = p.xval + "," + p.name;
	      if (k in annotations) {
	        p.annotation = annotations[k];
	        this.annotated_points.push(p);
	      }
	    }
	  }
	};

	/**
	 * Convenience function to remove all the data sets from a graph
	 */
	DygraphLayout.prototype.removeAllDatasets = function () {
	  delete this.points;
	  delete this.setNames;
	  delete this.setPointsLengths;
	  delete this.setPointsOffsets;
	  this.points = [];
	  this.setNames = [];
	  this.setPointsLengths = [];
	  this.setPointsOffsets = [];
	};

	exports['default'] = DygraphLayout;
	module.exports = exports['default'];

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview This file contains utility functions used by dygraphs. These
	 * are typically static (i.e. not related to any particular dygraph). Examples
	 * include date/time formatting functions, basic algorithms (e.g. binary
	 * search) and generic DOM-manipulation functions.
	 */

	/*global Dygraph:false, Node:false */
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.removeEvent = removeEvent;
	exports.cancelEvent = cancelEvent;
	exports.hsvToRGB = hsvToRGB;
	exports.findPos = findPos;
	exports.pageX = pageX;
	exports.pageY = pageY;
	exports.dragGetX_ = dragGetX_;
	exports.dragGetY_ = dragGetY_;
	exports.isOK = isOK;
	exports.isValidPoint = isValidPoint;
	exports.floatFormat = floatFormat;
	exports.zeropad = zeropad;
	exports.hmsString_ = hmsString_;
	exports.dateString_ = dateString_;
	exports.round_ = round_;
	exports.binarySearch = binarySearch;
	exports.dateParser = dateParser;
	exports.dateStrToMillis = dateStrToMillis;
	exports.update = update;
	exports.updateDeep = updateDeep;
	exports.isArrayLike = isArrayLike;
	exports.isDateLike = isDateLike;
	exports.clone = clone;
	exports.createCanvas = createCanvas;
	exports.getContextPixelRatio = getContextPixelRatio;
	exports.Iterator = Iterator;
	exports.createIterator = createIterator;
	exports.repeatAndCleanup = repeatAndCleanup;
	exports.isPixelChangingOptionList = isPixelChangingOptionList;
	exports.detectLineDelimiter = detectLineDelimiter;
	exports.isNodeContainedBy = isNodeContainedBy;
	exports.pow = pow;
	exports.toRGB_ = toRGB_;
	exports.isCanvasSupported = isCanvasSupported;
	exports.parseFloat_ = parseFloat_;
	exports.numberValueFormatter = numberValueFormatter;
	exports.numberAxisLabelFormatter = numberAxisLabelFormatter;
	exports.dateAxisLabelFormatter = dateAxisLabelFormatter;
	exports.dateValueFormatter = dateValueFormatter;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

	var _dygraphTickers = __webpack_require__(167);

	var DygraphTickers = _interopRequireWildcard(_dygraphTickers);

	var LOG_SCALE = 10;
	exports.LOG_SCALE = LOG_SCALE;
	var LN_TEN = Math.log(LOG_SCALE);

	exports.LN_TEN = LN_TEN;
	/**
	 * @private
	 * @param {number} x
	 * @return {number}
	 */
	var log10 = function log10(x) {
	  return Math.log(x) / LN_TEN;
	};

	exports.log10 = log10;
	/**
	 * @private
	 * @param {number} r0
	 * @param {number} r1
	 * @param {number} pct
	 * @return {number}
	 */
	var logRangeFraction = function logRangeFraction(r0, r1, pct) {
	  // Computing the inverse of toPercentXCoord. The function was arrived at with
	  // the following steps:
	  //
	  // Original calcuation:
	  // pct = (log(x) - log(xRange[0])) / (log(xRange[1]) - log(xRange[0])));
	  //
	  // Multiply both sides by the right-side demoninator.
	  // pct * (log(xRange[1] - log(xRange[0]))) = log(x) - log(xRange[0])
	  //
	  // add log(xRange[0]) to both sides
	  // log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])) = log(x);
	  //
	  // Swap both sides of the equation,
	  // log(x) = log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0]))
	  //
	  // Use both sides as the exponent in 10^exp and we're done.
	  // x = 10 ^ (log(xRange[0]) + (pct * (log(xRange[1]) - log(xRange[0])))

	  var logr0 = log10(r0);
	  var logr1 = log10(r1);
	  var exponent = logr0 + pct * (logr1 - logr0);
	  var value = Math.pow(LOG_SCALE, exponent);
	  return value;
	};

	exports.logRangeFraction = logRangeFraction;
	/** A dotted line stroke pattern. */
	var DOTTED_LINE = [2, 2];
	exports.DOTTED_LINE = DOTTED_LINE;
	/** A dashed line stroke pattern. */
	var DASHED_LINE = [7, 3];
	exports.DASHED_LINE = DASHED_LINE;
	/** A dot dash stroke pattern. */
	var DOT_DASH_LINE = [7, 2, 2, 2];

	exports.DOT_DASH_LINE = DOT_DASH_LINE;
	// Directions for panning and zooming. Use bit operations when combined
	// values are possible.
	var HORIZONTAL = 1;
	exports.HORIZONTAL = HORIZONTAL;
	var VERTICAL = 2;

	exports.VERTICAL = VERTICAL;
	/**
	 * Return the 2d context for a dygraph canvas.
	 *
	 * This method is only exposed for the sake of replacing the function in
	 * automated tests.
	 *
	 * @param {!HTMLCanvasElement} canvas
	 * @return {!CanvasRenderingContext2D}
	 * @private
	 */
	var getContext = function getContext(canvas) {
	  return (/** @type{!CanvasRenderingContext2D}*/canvas.getContext("2d")
	  );
	};

	exports.getContext = getContext;
	/**
	 * Add an event handler.
	 * @param {!Node} elem The element to add the event to.
	 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
	 * @param {function(Event):(boolean|undefined)} fn The function to call
	 *     on the event. The function takes one parameter: the event object.
	 * @private
	 */
	var addEvent = function addEvent(elem, type, fn) {
	  elem.addEventListener(type, fn, false);
	};

	exports.addEvent = addEvent;
	/**
	 * Remove an event handler.
	 * @param {!Node} elem The element to remove the event from.
	 * @param {string} type The type of the event, e.g. 'click' or 'mousemove'.
	 * @param {function(Event):(boolean|undefined)} fn The function to call
	 *     on the event. The function takes one parameter: the event object.
	 */

	function removeEvent(elem, type, fn) {
	  elem.removeEventListener(type, fn, false);
	}

	;

	/**
	 * Cancels further processing of an event. This is useful to prevent default
	 * browser actions, e.g. highlighting text on a double-click.
	 * Based on the article at
	 * http://www.switchonthecode.com/tutorials/javascript-tutorial-the-scroll-wheel
	 * @param {!Event} e The event whose normal behavior should be canceled.
	 * @private
	 */

	function cancelEvent(e) {
	  e = e ? e : window.event;
	  if (e.stopPropagation) {
	    e.stopPropagation();
	  }
	  if (e.preventDefault) {
	    e.preventDefault();
	  }
	  e.cancelBubble = true;
	  e.cancel = true;
	  e.returnValue = false;
	  return false;
	}

	;

	/**
	 * Convert hsv values to an rgb(r,g,b) string. Taken from MochiKit.Color. This
	 * is used to generate default series colors which are evenly spaced on the
	 * color wheel.
	 * @param { number } hue Range is 0.0-1.0.
	 * @param { number } saturation Range is 0.0-1.0.
	 * @param { number } value Range is 0.0-1.0.
	 * @return { string } "rgb(r,g,b)" where r, g and b range from 0-255.
	 * @private
	 */

	function hsvToRGB(hue, saturation, value) {
	  var red;
	  var green;
	  var blue;
	  if (saturation === 0) {
	    red = value;
	    green = value;
	    blue = value;
	  } else {
	    var i = Math.floor(hue * 6);
	    var f = hue * 6 - i;
	    var p = value * (1 - saturation);
	    var q = value * (1 - saturation * f);
	    var t = value * (1 - saturation * (1 - f));
	    switch (i) {
	      case 1:
	        red = q;green = value;blue = p;break;
	      case 2:
	        red = p;green = value;blue = t;break;
	      case 3:
	        red = p;green = q;blue = value;break;
	      case 4:
	        red = t;green = p;blue = value;break;
	      case 5:
	        red = value;green = p;blue = q;break;
	      case 6: // fall through
	      case 0:
	        red = value;green = t;blue = p;break;
	    }
	  }
	  red = Math.floor(255 * red + 0.5);
	  green = Math.floor(255 * green + 0.5);
	  blue = Math.floor(255 * blue + 0.5);
	  return 'rgb(' + red + ',' + green + ',' + blue + ')';
	}

	;

	/**
	 * Find the coordinates of an object relative to the top left of the page.
	 *
	 * @param {Node} obj
	 * @return {{x:number,y:number}}
	 * @private
	 */

	function findPos(obj) {
	  var p = obj.getBoundingClientRect(),
	      w = window,
	      d = document.documentElement;

	  return {
	    x: p.left + (w.pageXOffset || d.scrollLeft),
	    y: p.top + (w.pageYOffset || d.scrollTop)
	  };
	}

	;

	/**
	 * Returns the x-coordinate of the event in a coordinate system where the
	 * top-left corner of the page (not the window) is (0,0).
	 * Taken from MochiKit.Signal
	 * @param {!Event} e
	 * @return {number}
	 * @private
	 */

	function pageX(e) {
	  return !e.pageX || e.pageX < 0 ? 0 : e.pageX;
	}

	;

	/**
	 * Returns the y-coordinate of the event in a coordinate system where the
	 * top-left corner of the page (not the window) is (0,0).
	 * Taken from MochiKit.Signal
	 * @param {!Event} e
	 * @return {number}
	 * @private
	 */

	function pageY(e) {
	  return !e.pageY || e.pageY < 0 ? 0 : e.pageY;
	}

	;

	/**
	 * Converts page the x-coordinate of the event to pixel x-coordinates on the
	 * canvas (i.e. DOM Coords).
	 * @param {!Event} e Drag event.
	 * @param {!DygraphInteractionContext} context Interaction context object.
	 * @return {number} The amount by which the drag has moved to the right.
	 */

	function dragGetX_(e, context) {
	  return pageX(e) - context.px;
	}

	;

	/**
	 * Converts page the y-coordinate of the event to pixel y-coordinates on the
	 * canvas (i.e. DOM Coords).
	 * @param {!Event} e Drag event.
	 * @param {!DygraphInteractionContext} context Interaction context object.
	 * @return {number} The amount by which the drag has moved down.
	 */

	function dragGetY_(e, context) {
	  return pageY(e) - context.py;
	}

	;

	/**
	 * This returns true unless the parameter is 0, null, undefined or NaN.
	 * TODO(danvk): rename this function to something like 'isNonZeroNan'.
	 *
	 * @param {number} x The number to consider.
	 * @return {boolean} Whether the number is zero or NaN.
	 * @private
	 */

	function isOK(x) {
	  return !!x && !isNaN(x);
	}

	;

	/**
	 * @param {{x:?number,y:?number,yval:?number}} p The point to consider, valid
	 *     points are {x, y} objects
	 * @param {boolean=} opt_allowNaNY Treat point with y=NaN as valid
	 * @return {boolean} Whether the point has numeric x and y.
	 * @private
	 */

	function isValidPoint(p, opt_allowNaNY) {
	  if (!p) return false; // null or undefined object
	  if (p.yval === null) return false; // missing point
	  if (p.x === null || p.x === undefined) return false;
	  if (p.y === null || p.y === undefined) return false;
	  if (isNaN(p.x) || !opt_allowNaNY && isNaN(p.y)) return false;
	  return true;
	}

	;

	/**
	 * Number formatting function which mimicks the behavior of %g in printf, i.e.
	 * either exponential or fixed format (without trailing 0s) is used depending on
	 * the length of the generated string.  The advantage of this format is that
	 * there is a predictable upper bound on the resulting string length,
	 * significant figures are not dropped, and normal numbers are not displayed in
	 * exponential notation.
	 *
	 * NOTE: JavaScript's native toPrecision() is NOT a drop-in replacement for %g.
	 * It creates strings which are too long for absolute values between 10^-4 and
	 * 10^-6, e.g. '0.00001' instead of '1e-5'. See tests/number-format.html for
	 * output examples.
	 *
	 * @param {number} x The number to format
	 * @param {number=} opt_precision The precision to use, default 2.
	 * @return {string} A string formatted like %g in printf.  The max generated
	 *                  string length should be precision + 6 (e.g 1.123e+300).
	 */

	function floatFormat(x, opt_precision) {
	  // Avoid invalid precision values; [1, 21] is the valid range.
	  var p = Math.min(Math.max(1, opt_precision || 2), 21);

	  // This is deceptively simple.  The actual algorithm comes from:
	  //
	  // Max allowed length = p + 4
	  // where 4 comes from 'e+n' and '.'.
	  //
	  // Length of fixed format = 2 + y + p
	  // where 2 comes from '0.' and y = # of leading zeroes.
	  //
	  // Equating the two and solving for y yields y = 2, or 0.00xxxx which is
	  // 1.0e-3.
	  //
	  // Since the behavior of toPrecision() is identical for larger numbers, we
	  // don't have to worry about the other bound.
	  //
	  // Finally, the argument for toExponential() is the number of trailing digits,
	  // so we take off 1 for the value before the '.'.
	  return Math.abs(x) < 1.0e-3 && x !== 0.0 ? x.toExponential(p - 1) : x.toPrecision(p);
	}

	;

	/**
	 * Converts '9' to '09' (useful for dates)
	 * @param {number} x
	 * @return {string}
	 * @private
	 */

	function zeropad(x) {
	  if (x < 10) return "0" + x;else return "" + x;
	}

	;

	/**
	 * Date accessors to get the parts of a calendar date (year, month,
	 * day, hour, minute, second and millisecond) according to local time,
	 * and factory method to call the Date constructor with an array of arguments.
	 */
	var DateAccessorsLocal = {
	  getFullYear: function getFullYear(d) {
	    return d.getFullYear();
	  },
	  getMonth: function getMonth(d) {
	    return d.getMonth();
	  },
	  getDate: function getDate(d) {
	    return d.getDate();
	  },
	  getHours: function getHours(d) {
	    return d.getHours();
	  },
	  getMinutes: function getMinutes(d) {
	    return d.getMinutes();
	  },
	  getSeconds: function getSeconds(d) {
	    return d.getSeconds();
	  },
	  getMilliseconds: function getMilliseconds(d) {
	    return d.getMilliseconds();
	  },
	  getDay: function getDay(d) {
	    return d.getDay();
	  },
	  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {
	    return new Date(y, m, d, hh, mm, ss, ms);
	  }
	};

	exports.DateAccessorsLocal = DateAccessorsLocal;
	/**
	 * Date accessors to get the parts of a calendar date (year, month,
	 * day of month, hour, minute, second and millisecond) according to UTC time,
	 * and factory method to call the Date constructor with an array of arguments.
	 */
	var DateAccessorsUTC = {
	  getFullYear: function getFullYear(d) {
	    return d.getUTCFullYear();
	  },
	  getMonth: function getMonth(d) {
	    return d.getUTCMonth();
	  },
	  getDate: function getDate(d) {
	    return d.getUTCDate();
	  },
	  getHours: function getHours(d) {
	    return d.getUTCHours();
	  },
	  getMinutes: function getMinutes(d) {
	    return d.getUTCMinutes();
	  },
	  getSeconds: function getSeconds(d) {
	    return d.getUTCSeconds();
	  },
	  getMilliseconds: function getMilliseconds(d) {
	    return d.getUTCMilliseconds();
	  },
	  getDay: function getDay(d) {
	    return d.getUTCDay();
	  },
	  makeDate: function makeDate(y, m, d, hh, mm, ss, ms) {
	    return new Date(Date.UTC(y, m, d, hh, mm, ss, ms));
	  }
	};

	exports.DateAccessorsUTC = DateAccessorsUTC;
	/**
	 * Return a string version of the hours, minutes and seconds portion of a date.
	 * @param {number} hh The hours (from 0-23)
	 * @param {number} mm The minutes (from 0-59)
	 * @param {number} ss The seconds (from 0-59)
	 * @return {string} A time of the form "HH:MM" or "HH:MM:SS"
	 * @private
	 */

	function hmsString_(hh, mm, ss, ms) {
	  var ret = zeropad(hh) + ":" + zeropad(mm);
	  if (ss) {
	    ret += ":" + zeropad(ss);
	    if (ms) {
	      var str = "" + ms;
	      ret += "." + ('000' + str).substring(str.length);
	    }
	  }
	  return ret;
	}

	;

	/**
	 * Convert a JS date (millis since epoch) to a formatted string.
	 * @param {number} time The JavaScript time value (ms since epoch)
	 * @param {boolean} utc Wether output UTC or local time
	 * @return {string} A date of one of these forms:
	 *     "YYYY/MM/DD", "YYYY/MM/DD HH:MM" or "YYYY/MM/DD HH:MM:SS"
	 * @private
	 */

	function dateString_(time, utc) {
	  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;
	  var date = new Date(time);
	  var y = accessors.getFullYear(date);
	  var m = accessors.getMonth(date);
	  var d = accessors.getDate(date);
	  var hh = accessors.getHours(date);
	  var mm = accessors.getMinutes(date);
	  var ss = accessors.getSeconds(date);
	  var ms = accessors.getMilliseconds(date);
	  // Get a year string:
	  var year = "" + y;
	  // Get a 0 padded month string
	  var month = zeropad(m + 1); //months are 0-offset, sigh
	  // Get a 0 padded day string
	  var day = zeropad(d);
	  var frac = hh * 3600 + mm * 60 + ss + 1e-3 * ms;
	  var ret = year + "/" + month + "/" + day;
	  if (frac) {
	    ret += " " + hmsString_(hh, mm, ss, ms);
	  }
	  return ret;
	}

	;

	/**
	 * Round a number to the specified number of digits past the decimal point.
	 * @param {number} num The number to round
	 * @param {number} places The number of decimals to which to round
	 * @return {number} The rounded number
	 * @private
	 */

	function round_(num, places) {
	  var shift = Math.pow(10, places);
	  return Math.round(num * shift) / shift;
	}

	;

	/**
	 * Implementation of binary search over an array.
	 * Currently does not work when val is outside the range of arry's values.
	 * @param {number} val the value to search for
	 * @param {Array.<number>} arry is the value over which to search
	 * @param {number} abs If abs > 0, find the lowest entry greater than val
	 *     If abs < 0, find the highest entry less than val.
	 *     If abs == 0, find the entry that equals val.
	 * @param {number=} low The first index in arry to consider (optional)
	 * @param {number=} high The last index in arry to consider (optional)
	 * @return {number} Index of the element, or -1 if it isn't found.
	 * @private
	 */

	function binarySearch(_x, _x2, _x3, _x4, _x5) {
	  var _again = true;

	  _function: while (_again) {
	    var val = _x,
	        arry = _x2,
	        abs = _x3,
	        low = _x4,
	        high = _x5;
	    _again = false;

	    if (low === null || low === undefined || high === null || high === undefined) {
	      low = 0;
	      high = arry.length - 1;
	    }
	    if (low > high) {
	      return -1;
	    }
	    if (abs === null || abs === undefined) {
	      abs = 0;
	    }
	    var validIndex = function validIndex(idx) {
	      return idx >= 0 && idx < arry.length;
	    };
	    var mid = parseInt((low + high) / 2, 10);
	    var element = arry[mid];
	    var idx;
	    if (element == val) {
	      return mid;
	    } else if (element > val) {
	      if (abs > 0) {
	        // Accept if element > val, but also if prior element < val.
	        idx = mid - 1;
	        if (validIndex(idx) && arry[idx] < val) {
	          return mid;
	        }
	      }
	      _x = val;
	      _x2 = arry;
	      _x3 = abs;
	      _x4 = low;
	      _x5 = mid - 1;
	      _again = true;
	      validIndex = mid = element = idx = undefined;
	      continue _function;
	    } else if (element < val) {
	      if (abs < 0) {
	        // Accept if element < val, but also if prior element > val.
	        idx = mid + 1;
	        if (validIndex(idx) && arry[idx] > val) {
	          return mid;
	        }
	      }
	      _x = val;
	      _x2 = arry;
	      _x3 = abs;
	      _x4 = mid + 1;
	      _x5 = high;
	      _again = true;
	      validIndex = mid = element = idx = undefined;
	      continue _function;
	    }
	    return -1; // can't actually happen, but makes closure compiler happy
	  }
	}

	;

	/**
	 * Parses a date, returning the number of milliseconds since epoch. This can be
	 * passed in as an xValueParser in the Dygraph constructor.
	 * TODO(danvk): enumerate formats that this understands.
	 *
	 * @param {string} dateStr A date in a variety of possible string formats.
	 * @return {number} Milliseconds since epoch.
	 * @private
	 */

	function dateParser(dateStr) {
	  var dateStrSlashed;
	  var d;

	  // Let the system try the format first, with one caveat:
	  // YYYY-MM-DD[ HH:MM:SS] is interpreted as UTC by a variety of browsers.
	  // dygraphs displays dates in local time, so this will result in surprising
	  // inconsistencies. But if you specify "T" or "Z" (i.e. YYYY-MM-DDTHH:MM:SS),
	  // then you probably know what you're doing, so we'll let you go ahead.
	  // Issue: http://code.google.com/p/dygraphs/issues/detail?id=255
	  if (dateStr.search("-") == -1 || dateStr.search("T") != -1 || dateStr.search("Z") != -1) {
	    d = dateStrToMillis(dateStr);
	    if (d && !isNaN(d)) return d;
	  }

	  if (dateStr.search("-") != -1) {
	    // e.g. '2009-7-12' or '2009-07-12'
	    dateStrSlashed = dateStr.replace("-", "/", "g");
	    while (dateStrSlashed.search("-") != -1) {
	      dateStrSlashed = dateStrSlashed.replace("-", "/");
	    }
	    d = dateStrToMillis(dateStrSlashed);
	  } else if (dateStr.length == 8) {
	    // e.g. '20090712'
	    // TODO(danvk): remove support for this format. It's confusing.
	    dateStrSlashed = dateStr.substr(0, 4) + "/" + dateStr.substr(4, 2) + "/" + dateStr.substr(6, 2);
	    d = dateStrToMillis(dateStrSlashed);
	  } else {
	    // Any format that Date.parse will accept, e.g. "2009/07/12" or
	    // "2009/07/12 12:34:56"
	    d = dateStrToMillis(dateStr);
	  }

	  if (!d || isNaN(d)) {
	    console.error("Couldn't parse " + dateStr + " as a date");
	  }
	  return d;
	}

	;

	/**
	 * This is identical to JavaScript's built-in Date.parse() method, except that
	 * it doesn't get replaced with an incompatible method by aggressive JS
	 * libraries like MooTools or Joomla.
	 * @param {string} str The date string, e.g. "2011/05/06"
	 * @return {number} millis since epoch
	 * @private
	 */

	function dateStrToMillis(str) {
	  return new Date(str).getTime();
	}

	;

	// These functions are all based on MochiKit.
	/**
	 * Copies all the properties from o to self.
	 *
	 * @param {!Object} self
	 * @param {!Object} o
	 * @return {!Object}
	 */

	function update(self, o) {
	  if (typeof o != 'undefined' && o !== null) {
	    for (var k in o) {
	      if (o.hasOwnProperty(k)) {
	        self[k] = o[k];
	      }
	    }
	  }
	  return self;
	}

	;

	/**
	 * Copies all the properties from o to self.
	 *
	 * @param {!Object} self
	 * @param {!Object} o
	 * @return {!Object}
	 * @private
	 */

	function updateDeep(self, o) {
	  // Taken from http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
	  function isNode(o) {
	    return typeof Node === "object" ? o instanceof Node : typeof o === "object" && typeof o.nodeType === "number" && typeof o.nodeName === "string";
	  }

	  if (typeof o != 'undefined' && o !== null) {
	    for (var k in o) {
	      if (o.hasOwnProperty(k)) {
	        if (o[k] === null) {
	          self[k] = null;
	        } else if (isArrayLike(o[k])) {
	          self[k] = o[k].slice();
	        } else if (isNode(o[k])) {
	          // DOM objects are shallowly-copied.
	          self[k] = o[k];
	        } else if (typeof o[k] == 'object') {
	          if (typeof self[k] != 'object' || self[k] === null) {
	            self[k] = {};
	          }
	          updateDeep(self[k], o[k]);
	        } else {
	          self[k] = o[k];
	        }
	      }
	    }
	  }
	  return self;
	}

	;

	/**
	 * @param {*} o
	 * @return {boolean}
	 * @private
	 */

	function isArrayLike(o) {
	  var typ = typeof o;
	  if (typ != 'object' && !(typ == 'function' && typeof o.item == 'function') || o === null || typeof o.length != 'number' || o.nodeType === 3) {
	    return false;
	  }
	  return true;
	}

	;

	/**
	 * @param {Object} o
	 * @return {boolean}
	 * @private
	 */

	function isDateLike(o) {
	  if (typeof o != "object" || o === null || typeof o.getTime != 'function') {
	    return false;
	  }
	  return true;
	}

	;

	/**
	 * Note: this only seems to work for arrays.
	 * @param {!Array} o
	 * @return {!Array}
	 * @private
	 */

	function clone(o) {
	  // TODO(danvk): figure out how MochiKit's version works
	  var r = [];
	  for (var i = 0; i < o.length; i++) {
	    if (isArrayLike(o[i])) {
	      r.push(clone(o[i]));
	    } else {
	      r.push(o[i]);
	    }
	  }
	  return r;
	}

	;

	/**
	 * Create a new canvas element.
	 *
	 * @return {!HTMLCanvasElement}
	 * @private
	 */

	function createCanvas() {
	  return document.createElement('canvas');
	}

	;

	/**
	 * Returns the context's pixel ratio, which is the ratio between the device
	 * pixel ratio and the backing store ratio. Typically this is 1 for conventional
	 * displays, and > 1 for HiDPI displays (such as the Retina MBP).
	 * See http://www.html5rocks.com/en/tutorials/canvas/hidpi/ for more details.
	 *
	 * @param {!CanvasRenderingContext2D} context The canvas's 2d context.
	 * @return {number} The ratio of the device pixel ratio and the backing store
	 * ratio for the specified context.
	 */

	function getContextPixelRatio(context) {
	  try {
	    var devicePixelRatio = window.devicePixelRatio;
	    var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
	    if (devicePixelRatio !== undefined) {
	      return devicePixelRatio / backingStoreRatio;
	    } else {
	      // At least devicePixelRatio must be defined for this ratio to make sense.
	      // We default backingStoreRatio to 1: this does not exist on some browsers
	      // (i.e. desktop Chrome).
	      return 1;
	    }
	  } catch (e) {
	    return 1;
	  }
	}

	;

	/**
	 * TODO(danvk): use @template here when it's better supported for classes.
	 * @param {!Array} array
	 * @param {number} start
	 * @param {number} length
	 * @param {function(!Array,?):boolean=} predicate
	 * @constructor
	 */

	function Iterator(array, start, length, predicate) {
	  start = start || 0;
	  length = length || array.length;
	  this.hasNext = true; // Use to identify if there's another element.
	  this.peek = null; // Use for look-ahead
	  this.start_ = start;
	  this.array_ = array;
	  this.predicate_ = predicate;
	  this.end_ = Math.min(array.length, start + length);
	  this.nextIdx_ = start - 1; // use -1 so initial advance works.
	  this.next(); // ignoring result.
	}

	;

	/**
	 * @return {Object}
	 */
	Iterator.prototype.next = function () {
	  if (!this.hasNext) {
	    return null;
	  }
	  var obj = this.peek;

	  var nextIdx = this.nextIdx_ + 1;
	  var found = false;
	  while (nextIdx < this.end_) {
	    if (!this.predicate_ || this.predicate_(this.array_, nextIdx)) {
	      this.peek = this.array_[nextIdx];
	      found = true;
	      break;
	    }
	    nextIdx++;
	  }
	  this.nextIdx_ = nextIdx;
	  if (!found) {
	    this.hasNext = false;
	    this.peek = null;
	  }
	  return obj;
	};

	/**
	 * Returns a new iterator over array, between indexes start and
	 * start + length, and only returns entries that pass the accept function
	 *
	 * @param {!Array} array the array to iterate over.
	 * @param {number} start the first index to iterate over, 0 if absent.
	 * @param {number} length the number of elements in the array to iterate over.
	 *     This, along with start, defines a slice of the array, and so length
	 *     doesn't imply the number of elements in the iterator when accept doesn't
	 *     always accept all values. array.length when absent.
	 * @param {function(?):boolean=} opt_predicate a function that takes
	 *     parameters array and idx, which returns true when the element should be
	 *     returned.  If omitted, all elements are accepted.
	 * @private
	 */

	function createIterator(array, start, length, opt_predicate) {
	  return new Iterator(array, start, length, opt_predicate);
	}

	;

	// Shim layer with setTimeout fallback.
	// From: http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	// Should be called with the window context:
	//   Dygraph.requestAnimFrame.call(window, function() {})
	var requestAnimFrame = (function () {
	  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
	    window.setTimeout(callback, 1000 / 60);
	  };
	})();

	exports.requestAnimFrame = requestAnimFrame;
	/**
	 * Call a function at most maxFrames times at an attempted interval of
	 * framePeriodInMillis, then call a cleanup function once. repeatFn is called
	 * once immediately, then at most (maxFrames - 1) times asynchronously. If
	 * maxFrames==1, then cleanup_fn() is also called synchronously.  This function
	 * is used to sequence animation.
	 * @param {function(number)} repeatFn Called repeatedly -- takes the frame
	 *     number (from 0 to maxFrames-1) as an argument.
	 * @param {number} maxFrames The max number of times to call repeatFn
	 * @param {number} framePeriodInMillis Max requested time between frames.
	 * @param {function()} cleanupFn A function to call after all repeatFn calls.
	 * @private
	 */

	function repeatAndCleanup(repeatFn, maxFrames, framePeriodInMillis, cleanupFn) {
	  var frameNumber = 0;
	  var previousFrameNumber;
	  var startTime = new Date().getTime();
	  repeatFn(frameNumber);
	  if (maxFrames == 1) {
	    cleanupFn();
	    return;
	  }
	  var maxFrameArg = maxFrames - 1;

	  (function loop() {
	    if (frameNumber >= maxFrames) return;
	    requestAnimFrame.call(window, function () {
	      // Determine which frame to draw based on the delay so far.  Will skip
	      // frames if necessary.
	      var currentTime = new Date().getTime();
	      var delayInMillis = currentTime - startTime;
	      previousFrameNumber = frameNumber;
	      frameNumber = Math.floor(delayInMillis / framePeriodInMillis);
	      var frameDelta = frameNumber - previousFrameNumber;
	      // If we predict that the subsequent repeatFn call will overshoot our
	      // total frame target, so our last call will cause a stutter, then jump to
	      // the last call immediately.  If we're going to cause a stutter, better
	      // to do it faster than slower.
	      var predictOvershootStutter = frameNumber + frameDelta > maxFrameArg;
	      if (predictOvershootStutter || frameNumber >= maxFrameArg) {
	        repeatFn(maxFrameArg); // Ensure final call with maxFrameArg.
	        cleanupFn();
	      } else {
	        if (frameDelta !== 0) {
	          // Don't call repeatFn with duplicate frames.
	          repeatFn(frameNumber);
	        }
	        loop();
	      }
	    });
	  })();
	}

	;

	// A whitelist of options that do not change pixel positions.
	var pixelSafeOptions = {
	  'annotationClickHandler': true,
	  'annotationDblClickHandler': true,
	  'annotationMouseOutHandler': true,
	  'annotationMouseOverHandler': true,
	  'axisLineColor': true,
	  'axisLineWidth': true,
	  'clickCallback': true,
	  'drawCallback': true,
	  'drawHighlightPointCallback': true,
	  'drawPoints': true,
	  'drawPointCallback': true,
	  'drawGrid': true,
	  'fillAlpha': true,
	  'gridLineColor': true,
	  'gridLineWidth': true,
	  'hideOverlayOnMouseOut': true,
	  'highlightCallback': true,
	  'highlightCircleSize': true,
	  'interactionModel': true,
	  'labelsDiv': true,
	  'labelsKMB': true,
	  'labelsKMG2': true,
	  'labelsSeparateLines': true,
	  'labelsShowZeroValues': true,
	  'legend': true,
	  'panEdgeFraction': true,
	  'pixelsPerYLabel': true,
	  'pointClickCallback': true,
	  'pointSize': true,
	  'rangeSelectorPlotFillColor': true,
	  'rangeSelectorPlotFillGradientColor': true,
	  'rangeSelectorPlotStrokeColor': true,
	  'rangeSelectorBackgroundStrokeColor': true,
	  'rangeSelectorBackgroundLineWidth': true,
	  'rangeSelectorPlotLineWidth': true,
	  'rangeSelectorForegroundStrokeColor': true,
	  'rangeSelectorForegroundLineWidth': true,
	  'rangeSelectorAlpha': true,
	  'showLabelsOnHighlight': true,
	  'showRoller': true,
	  'strokeWidth': true,
	  'underlayCallback': true,
	  'unhighlightCallback': true,
	  'zoomCallback': true
	};

	/**
	 * This function will scan the option list and determine if they
	 * require us to recalculate the pixel positions of each point.
	 * TODO: move this into dygraph-options.js
	 * @param {!Array.<string>} labels a list of options to check.
	 * @param {!Object} attrs
	 * @return {boolean} true if the graph needs new points else false.
	 * @private
	 */

	function isPixelChangingOptionList(labels, attrs) {
	  // Assume that we do not require new points.
	  // This will change to true if we actually do need new points.

	  // Create a dictionary of series names for faster lookup.
	  // If there are no labels, then the dictionary stays empty.
	  var seriesNamesDictionary = {};
	  if (labels) {
	    for (var i = 1; i < labels.length; i++) {
	      seriesNamesDictionary[labels[i]] = true;
	    }
	  }

	  // Scan through a flat (i.e. non-nested) object of options.
	  // Returns true/false depending on whether new points are needed.
	  var scanFlatOptions = function scanFlatOptions(options) {
	    for (var property in options) {
	      if (options.hasOwnProperty(property) && !pixelSafeOptions[property]) {
	        return true;
	      }
	    }
	    return false;
	  };

	  // Iterate through the list of updated options.
	  for (var property in attrs) {
	    if (!attrs.hasOwnProperty(property)) continue;

	    // Find out of this field is actually a series specific options list.
	    if (property == 'highlightSeriesOpts' || seriesNamesDictionary[property] && !attrs.series) {
	      // This property value is a list of options for this series.
	      if (scanFlatOptions(attrs[property])) return true;
	    } else if (property == 'series' || property == 'axes') {
	      // This is twice-nested options list.
	      var perSeries = attrs[property];
	      for (var series in perSeries) {
	        if (perSeries.hasOwnProperty(series) && scanFlatOptions(perSeries[series])) {
	          return true;
	        }
	      }
	    } else {
	      // If this was not a series specific option list, check if it's a pixel
	      // changing property.
	      if (!pixelSafeOptions[property]) return true;
	    }
	  }

	  return false;
	}

	;

	var Circles = {
	  DEFAULT: function DEFAULT(g, name, ctx, canvasx, canvasy, color, radius) {
	    ctx.beginPath();
	    ctx.fillStyle = color;
	    ctx.arc(canvasx, canvasy, radius, 0, 2 * Math.PI, false);
	    ctx.fill();
	  }
	  // For more shapes, include extras/shapes.js
	};

	exports.Circles = Circles;
	/**
	 * Determine whether |data| is delimited by CR, CRLF, LF, LFCR.
	 * @param {string} data
	 * @return {?string} the delimiter that was detected (or null on failure).
	 */

	function detectLineDelimiter(data) {
	  for (var i = 0; i < data.length; i++) {
	    var code = data.charAt(i);
	    if (code === '\r') {
	      // Might actually be "\r\n".
	      if (i + 1 < data.length && data.charAt(i + 1) === '\n') {
	        return '\r\n';
	      }
	      return code;
	    }
	    if (code === '\n') {
	      // Might actually be "\n\r".
	      if (i + 1 < data.length && data.charAt(i + 1) === '\r') {
	        return '\n\r';
	      }
	      return code;
	    }
	  }

	  return null;
	}

	;

	/**
	 * Is one node contained by another?
	 * @param {Node} containee The contained node.
	 * @param {Node} container The container node.
	 * @return {boolean} Whether containee is inside (or equal to) container.
	 * @private
	 */

	function isNodeContainedBy(containee, container) {
	  if (container === null || containee === null) {
	    return false;
	  }
	  var containeeNode = /** @type {Node} */containee;
	  while (containeeNode && containeeNode !== container) {
	    containeeNode = containeeNode.parentNode;
	  }
	  return containeeNode === container;
	}

	;

	// This masks some numeric issues in older versions of Firefox,
	// where 1.0/Math.pow(10,2) != Math.pow(10,-2).
	/** @type {function(number,number):number} */

	function pow(base, exp) {
	  if (exp < 0) {
	    return 1.0 / Math.pow(base, -exp);
	  }
	  return Math.pow(base, exp);
	}

	;

	var RGBA_RE = /^rgba?\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})(?:,\s*([01](?:\.\d+)?))?\)$/;

	/**
	 * Helper for toRGB_ which parses strings of the form:
	 * rgb(123, 45, 67)
	 * rgba(123, 45, 67, 0.5)
	 * @return parsed {r,g,b,a?} tuple or null.
	 */
	function parseRGBA(rgbStr) {
	  var bits = RGBA_RE.exec(rgbStr);
	  if (!bits) return null;
	  var r = parseInt(bits[1], 10),
	      g = parseInt(bits[2], 10),
	      b = parseInt(bits[3], 10);
	  if (bits[4]) {
	    return { r: r, g: g, b: b, a: parseFloat(bits[4]) };
	  } else {
	    return { r: r, g: g, b: b };
	  }
	}

	/**
	 * Converts any valid CSS color (hex, rgb(), named color) to an RGB tuple.
	 *
	 * @param {!string} colorStr Any valid CSS color string.
	 * @return {{r:number,g:number,b:number,a:number?}} Parsed RGB tuple.
	 * @private
	 */

	function toRGB_(colorStr) {
	  // Strategy: First try to parse colorStr directly. This is fast & avoids DOM
	  // manipulation.  If that fails (e.g. for named colors like 'red'), then
	  // create a hidden DOM element and parse its computed color.
	  var rgb = parseRGBA(colorStr);
	  if (rgb) return rgb;

	  var div = document.createElement('div');
	  div.style.backgroundColor = colorStr;
	  div.style.visibility = 'hidden';
	  document.body.appendChild(div);
	  var rgbStr = window.getComputedStyle(div, null).backgroundColor;
	  document.body.removeChild(div);
	  return parseRGBA(rgbStr);
	}

	;

	/**
	 * Checks whether the browser supports the &lt;canvas&gt; tag.
	 * @param {HTMLCanvasElement=} opt_canvasElement Pass a canvas element as an
	 *     optimization if you have one.
	 * @return {boolean} Whether the browser supports canvas.
	 */

	function isCanvasSupported(opt_canvasElement) {
	  try {
	    var canvas = opt_canvasElement || document.createElement("canvas");
	    canvas.getContext("2d");
	  } catch (e) {
	    return false;
	  }
	  return true;
	}

	;

	/**
	 * Parses the value as a floating point number. This is like the parseFloat()
	 * built-in, but with a few differences:
	 * - the empty string is parsed as null, rather than NaN.
	 * - if the string cannot be parsed at all, an error is logged.
	 * If the string can't be parsed, this method returns null.
	 * @param {string} x The string to be parsed
	 * @param {number=} opt_line_no The line number from which the string comes.
	 * @param {string=} opt_line The text of the line from which the string comes.
	 */

	function parseFloat_(x, opt_line_no, opt_line) {
	  var val = parseFloat(x);
	  if (!isNaN(val)) return val;

	  // Try to figure out what happeend.
	  // If the value is the empty string, parse it as null.
	  if (/^ *$/.test(x)) return null;

	  // If it was actually "NaN", return it as NaN.
	  if (/^ *nan *$/i.test(x)) return NaN;

	  // Looks like a parsing error.
	  var msg = "Unable to parse '" + x + "' as a number";
	  if (opt_line !== undefined && opt_line_no !== undefined) {
	    msg += " on line " + (1 + (opt_line_no || 0)) + " ('" + opt_line + "') of CSV.";
	  }
	  console.error(msg);

	  return null;
	}

	;

	// Label constants for the labelsKMB and labelsKMG2 options.
	// (i.e. '100000' -> '100K')
	var KMB_LABELS = ['K', 'M', 'B', 'T', 'Q'];
	var KMG2_BIG_LABELS = ['k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
	var KMG2_SMALL_LABELS = ['m', 'u', 'n', 'p', 'f', 'a', 'z', 'y'];

	/**
	 * @private
	 * Return a string version of a number. This respects the digitsAfterDecimal
	 * and maxNumberWidth options.
	 * @param {number} x The number to be formatted
	 * @param {Dygraph} opts An options view
	 */

	function numberValueFormatter(x, opts) {
	  var sigFigs = opts('sigFigs');

	  if (sigFigs !== null) {
	    // User has opted for a fixed number of significant figures.
	    return floatFormat(x, sigFigs);
	  }

	  var digits = opts('digitsAfterDecimal');
	  var maxNumberWidth = opts('maxNumberWidth');

	  var kmb = opts('labelsKMB');
	  var kmg2 = opts('labelsKMG2');

	  var label;

	  // switch to scientific notation if we underflow or overflow fixed display.
	  if (x !== 0.0 && (Math.abs(x) >= Math.pow(10, maxNumberWidth) || Math.abs(x) < Math.pow(10, -digits))) {
	    label = x.toExponential(digits);
	  } else {
	    label = '' + round_(x, digits);
	  }

	  if (kmb || kmg2) {
	    var k;
	    var k_labels = [];
	    var m_labels = [];
	    if (kmb) {
	      k = 1000;
	      k_labels = KMB_LABELS;
	    }
	    if (kmg2) {
	      if (kmb) console.warn("Setting both labelsKMB and labelsKMG2. Pick one!");
	      k = 1024;
	      k_labels = KMG2_BIG_LABELS;
	      m_labels = KMG2_SMALL_LABELS;
	    }

	    var absx = Math.abs(x);
	    var n = pow(k, k_labels.length);
	    for (var j = k_labels.length - 1; j >= 0; j--, n /= k) {
	      if (absx >= n) {
	        label = round_(x / n, digits) + k_labels[j];
	        break;
	      }
	    }
	    if (kmg2) {
	      // TODO(danvk): clean up this logic. Why so different than kmb?
	      var x_parts = String(x.toExponential()).split('e-');
	      if (x_parts.length === 2 && x_parts[1] >= 3 && x_parts[1] <= 24) {
	        if (x_parts[1] % 3 > 0) {
	          label = round_(x_parts[0] / pow(10, x_parts[1] % 3), digits);
	        } else {
	          label = Number(x_parts[0]).toFixed(2);
	        }
	        label += m_labels[Math.floor(x_parts[1] / 3) - 1];
	      }
	    }
	  }

	  return label;
	}

	;

	/**
	 * variant for use as an axisLabelFormatter.
	 * @private
	 */

	function numberAxisLabelFormatter(x, granularity, opts) {
	  return numberValueFormatter.call(this, x, opts);
	}

	;

	/**
	 * @type {!Array.<string>}
	 * @private
	 * @constant
	 */
	var SHORT_MONTH_NAMES_ = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

	/**
	 * Convert a JS date to a string appropriate to display on an axis that
	 * is displaying values at the stated granularity. This respects the
	 * labelsUTC option.
	 * @param {Date} date The date to format
	 * @param {number} granularity One of the Dygraph granularity constants
	 * @param {Dygraph} opts An options view
	 * @return {string} The date formatted as local time
	 * @private
	 */

	function dateAxisLabelFormatter(date, granularity, opts) {
	  var utc = opts('labelsUTC');
	  var accessors = utc ? DateAccessorsUTC : DateAccessorsLocal;

	  var year = accessors.getFullYear(date),
	      month = accessors.getMonth(date),
	      day = accessors.getDate(date),
	      hours = accessors.getHours(date),
	      mins = accessors.getMinutes(date),
	      secs = accessors.getSeconds(date),
	      millis = accessors.getMilliseconds(date);

	  if (granularity >= DygraphTickers.Granularity.DECADAL) {
	    return '' + year;
	  } else if (granularity >= DygraphTickers.Granularity.MONTHLY) {
	    return SHORT_MONTH_NAMES_[month] + '&#160;' + year;
	  } else {
	    var frac = hours * 3600 + mins * 60 + secs + 1e-3 * millis;
	    if (frac === 0 || granularity >= DygraphTickers.Granularity.DAILY) {
	      // e.g. '21 Jan' (%d%b)
	      return zeropad(day) + '&#160;' + SHORT_MONTH_NAMES_[month];
	    } else {
	      return hmsString_(hours, mins, secs, millis);
	    }
	  }
	}

	;
	// alias in case anyone is referencing the old method.
	// Dygraph.dateAxisFormatter = Dygraph.dateAxisLabelFormatter;

	/**
	 * Return a string version of a JS date for a value label. This respects the
	 * labelsUTC option.
	 * @param {Date} date The date to be formatted
	 * @param {Dygraph} opts An options view
	 * @private
	 */

	function dateValueFormatter(d, opts) {
	  return dateString_(d, opts('labelsUTC'));
	}

	;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview Description of this file.
	 * @author danvk@google.com (Dan Vanderkam)
	 *
	 * A ticker is a function with the following interface:
	 *
	 * function(a, b, pixels, options_view, dygraph, forced_values);
	 * -> [ { v: tick1_v, label: tick1_label[, label_v: label_v1] },
	 *      { v: tick2_v, label: tick2_label[, label_v: label_v2] },
	 *      ...
	 *    ]
	 *
	 * The returned value is called a "tick list".
	 *
	 * Arguments
	 * ---------
	 *
	 * [a, b] is the range of the axis for which ticks are being generated. For a
	 * numeric axis, these will simply be numbers. For a date axis, these will be
	 * millis since epoch (convertable to Date objects using "new Date(a)" and "new
	 * Date(b)").
	 *
	 * opts provides access to chart- and axis-specific options. It can be used to
	 * access number/date formatting code/options, check for a log scale, etc.
	 *
	 * pixels is the length of the axis in pixels. opts('pixelsPerLabel') is the
	 * minimum amount of space to be allotted to each label. For instance, if
	 * pixels=400 and opts('pixelsPerLabel')=40 then the ticker should return
	 * between zero and ten (400/40) ticks.
	 *
	 * dygraph is the Dygraph object for which an axis is being constructed.
	 *
	 * forced_values is used for secondary y-axes. The tick positions are typically
	 * set by the primary y-axis, so the secondary y-axis has no choice in where to
	 * put these. It simply has to generate labels for these data values.
	 *
	 * Tick lists
	 * ----------
	 * Typically a tick will have both a grid/tick line and a label at one end of
	 * that line (at the bottom for an x-axis, at left or right for the y-axis).
	 *
	 * A tick may be missing one of these two components:
	 * - If "label_v" is specified instead of "v", then there will be no tick or
	 *   gridline, just a label.
	 * - Similarly, if "label" is not specified, then there will be a gridline
	 *   without a label.
	 *
	 * This flexibility is useful in a few situations:
	 * - For log scales, some of the tick lines may be too close to all have labels.
	 * - For date scales where years are being displayed, it is desirable to display
	 *   tick marks at the beginnings of years but labels (e.g. "2006") in the
	 *   middle of the years.
	 */

	/*jshint sub:true */
	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	/** @typedef {Array.<{v:number, label:string, label_v:(string|undefined)}>} */
	var TickList = undefined; // the ' = undefined' keeps jshint happy.

	/** @typedef {function(
	 *    number,
	 *    number,
	 *    number,
	 *    function(string):*,
	 *    Dygraph=,
	 *    Array.<number>=
	 *  ): TickList}
	 */
	var Ticker = undefined; // the ' = undefined' keeps jshint happy.

	/** @type {Ticker} */
	var numericLinearTicks = function numericLinearTicks(a, b, pixels, opts, dygraph, vals) {
	  var nonLogscaleOpts = function nonLogscaleOpts(opt) {
	    if (opt === 'logscale') return false;
	    return opts(opt);
	  };
	  return numericTicks(a, b, pixels, nonLogscaleOpts, dygraph, vals);
	};

	exports.numericLinearTicks = numericLinearTicks;
	/** @type {Ticker} */
	var numericTicks = function numericTicks(a, b, pixels, opts, dygraph, vals) {
	  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');
	  var ticks = [];
	  var i, j, tickV, nTicks;
	  if (vals) {
	    for (i = 0; i < vals.length; i++) {
	      ticks.push({ v: vals[i] });
	    }
	  } else {
	    // TODO(danvk): factor this log-scale block out into a separate function.
	    if (opts("logscale")) {
	      nTicks = Math.floor(pixels / pixels_per_tick);
	      var minIdx = utils.binarySearch(a, PREFERRED_LOG_TICK_VALUES, 1);
	      var maxIdx = utils.binarySearch(b, PREFERRED_LOG_TICK_VALUES, -1);
	      if (minIdx == -1) {
	        minIdx = 0;
	      }
	      if (maxIdx == -1) {
	        maxIdx = PREFERRED_LOG_TICK_VALUES.length - 1;
	      }
	      // Count the number of tick values would appear, if we can get at least
	      // nTicks / 4 accept them.
	      var lastDisplayed = null;
	      if (maxIdx - minIdx >= nTicks / 4) {
	        for (var idx = maxIdx; idx >= minIdx; idx--) {
	          var tickValue = PREFERRED_LOG_TICK_VALUES[idx];
	          var pixel_coord = Math.log(tickValue / a) / Math.log(b / a) * pixels;
	          var tick = { v: tickValue };
	          if (lastDisplayed === null) {
	            lastDisplayed = {
	              tickValue: tickValue,
	              pixel_coord: pixel_coord
	            };
	          } else {
	            if (Math.abs(pixel_coord - lastDisplayed.pixel_coord) >= pixels_per_tick) {
	              lastDisplayed = {
	                tickValue: tickValue,
	                pixel_coord: pixel_coord
	              };
	            } else {
	              tick.label = "";
	            }
	          }
	          ticks.push(tick);
	        }
	        // Since we went in backwards order.
	        ticks.reverse();
	      }
	    }

	    // ticks.length won't be 0 if the log scale function finds values to insert.
	    if (ticks.length === 0) {
	      // Basic idea:
	      // Try labels every 1, 2, 5, 10, 20, 50, 100, etc.
	      // Calculate the resulting tick spacing (i.e. this.height_ / nTicks).
	      // The first spacing greater than pixelsPerYLabel is what we use.
	      // TODO(danvk): version that works on a log scale.
	      var kmg2 = opts("labelsKMG2");
	      var mults, base;
	      if (kmg2) {
	        mults = [1, 2, 4, 8, 16, 32, 64, 128, 256];
	        base = 16;
	      } else {
	        mults = [1, 2, 5, 10, 20, 50, 100];
	        base = 10;
	      }

	      // Get the maximum number of permitted ticks based on the
	      // graph's pixel size and pixels_per_tick setting.
	      var max_ticks = Math.ceil(pixels / pixels_per_tick);

	      // Now calculate the data unit equivalent of this tick spacing.
	      // Use abs() since graphs may have a reversed Y axis.
	      var units_per_tick = Math.abs(b - a) / max_ticks;

	      // Based on this, get a starting scale which is the largest
	      // integer power of the chosen base (10 or 16) that still remains
	      // below the requested pixels_per_tick spacing.
	      var base_power = Math.floor(Math.log(units_per_tick) / Math.log(base));
	      var base_scale = Math.pow(base, base_power);

	      // Now try multiples of the starting scale until we find one
	      // that results in tick marks spaced sufficiently far apart.
	      // The "mults" array should cover the range 1 .. base^2 to
	      // adjust for rounding and edge effects.
	      var scale, low_val, high_val, spacing;
	      for (j = 0; j < mults.length; j++) {
	        scale = base_scale * mults[j];
	        low_val = Math.floor(a / scale) * scale;
	        high_val = Math.ceil(b / scale) * scale;
	        nTicks = Math.abs(high_val - low_val) / scale;
	        spacing = pixels / nTicks;
	        if (spacing > pixels_per_tick) break;
	      }

	      // Construct the set of ticks.
	      // Allow reverse y-axis if it's explicitly requested.
	      if (low_val > high_val) scale *= -1;
	      for (i = 0; i <= nTicks; i++) {
	        tickV = low_val + i * scale;
	        ticks.push({ v: tickV });
	      }
	    }
	  }

	  var formatter = /**@type{AxisLabelFormatter}*/opts('axisLabelFormatter');

	  // Add labels to the ticks.
	  for (i = 0; i < ticks.length; i++) {
	    if (ticks[i].label !== undefined) continue; // Use current label.
	    // TODO(danvk): set granularity to something appropriate here.
	    ticks[i].label = formatter.call(dygraph, ticks[i].v, 0, opts, dygraph);
	  }

	  return ticks;
	};

	exports.numericTicks = numericTicks;
	/** @type {Ticker} */
	var dateTicker = function dateTicker(a, b, pixels, opts, dygraph, vals) {
	  var chosen = pickDateTickGranularity(a, b, pixels, opts);

	  if (chosen >= 0) {
	    return getDateAxis(a, b, chosen, opts, dygraph);
	  } else {
	    // this can happen if self.width_ is zero.
	    return [];
	  }
	};

	exports.dateTicker = dateTicker;
	// Time granularity enumeration
	var Granularity = {
	  SECONDLY: 0,
	  TWO_SECONDLY: 1,
	  FIVE_SECONDLY: 2,
	  TEN_SECONDLY: 3,
	  THIRTY_SECONDLY: 4,
	  MINUTELY: 5,
	  TWO_MINUTELY: 6,
	  FIVE_MINUTELY: 7,
	  TEN_MINUTELY: 8,
	  THIRTY_MINUTELY: 9,
	  HOURLY: 10,
	  TWO_HOURLY: 11,
	  SIX_HOURLY: 12,
	  DAILY: 13,
	  TWO_DAILY: 14,
	  WEEKLY: 15,
	  MONTHLY: 16,
	  QUARTERLY: 17,
	  BIANNUAL: 18,
	  ANNUAL: 19,
	  DECADAL: 20,
	  CENTENNIAL: 21,
	  NUM_GRANULARITIES: 22
	};

	exports.Granularity = Granularity;
	// Date components enumeration (in the order of the arguments in Date)
	// TODO: make this an @enum
	var DateField = {
	  DATEFIELD_Y: 0,
	  DATEFIELD_M: 1,
	  DATEFIELD_D: 2,
	  DATEFIELD_HH: 3,
	  DATEFIELD_MM: 4,
	  DATEFIELD_SS: 5,
	  DATEFIELD_MS: 6,
	  NUM_DATEFIELDS: 7
	};

	/**
	 * The value of datefield will start at an even multiple of "step", i.e.
	 *   if datefield=SS and step=5 then the first tick will be on a multiple of 5s.
	 *
	 * For granularities <= HOURLY, ticks are generated every `spacing` ms.
	 *
	 * At coarser granularities, ticks are generated by incrementing `datefield` by
	 *   `step`. In this case, the `spacing` value is only used to estimate the
	 *   number of ticks. It should roughly correspond to the spacing between
	 *   adjacent ticks.
	 *
	 * @type {Array.<{datefield:number, step:number, spacing:number}>}
	 */
	var TICK_PLACEMENT = [];
	TICK_PLACEMENT[Granularity.SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 1, spacing: 1000 * 1 };
	TICK_PLACEMENT[Granularity.TWO_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 2, spacing: 1000 * 2 };
	TICK_PLACEMENT[Granularity.FIVE_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 5, spacing: 1000 * 5 };
	TICK_PLACEMENT[Granularity.TEN_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 10, spacing: 1000 * 10 };
	TICK_PLACEMENT[Granularity.THIRTY_SECONDLY] = { datefield: DateField.DATEFIELD_SS, step: 30, spacing: 1000 * 30 };
	TICK_PLACEMENT[Granularity.MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 1, spacing: 1000 * 60 };
	TICK_PLACEMENT[Granularity.TWO_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 2, spacing: 1000 * 60 * 2 };
	TICK_PLACEMENT[Granularity.FIVE_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 5, spacing: 1000 * 60 * 5 };
	TICK_PLACEMENT[Granularity.TEN_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 10, spacing: 1000 * 60 * 10 };
	TICK_PLACEMENT[Granularity.THIRTY_MINUTELY] = { datefield: DateField.DATEFIELD_MM, step: 30, spacing: 1000 * 60 * 30 };
	TICK_PLACEMENT[Granularity.HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 1, spacing: 1000 * 3600 };
	TICK_PLACEMENT[Granularity.TWO_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 2, spacing: 1000 * 3600 * 2 };
	TICK_PLACEMENT[Granularity.SIX_HOURLY] = { datefield: DateField.DATEFIELD_HH, step: 6, spacing: 1000 * 3600 * 6 };
	TICK_PLACEMENT[Granularity.DAILY] = { datefield: DateField.DATEFIELD_D, step: 1, spacing: 1000 * 86400 };
	TICK_PLACEMENT[Granularity.TWO_DAILY] = { datefield: DateField.DATEFIELD_D, step: 2, spacing: 1000 * 86400 * 2 };
	TICK_PLACEMENT[Granularity.WEEKLY] = { datefield: DateField.DATEFIELD_D, step: 7, spacing: 1000 * 604800 };
	TICK_PLACEMENT[Granularity.MONTHLY] = { datefield: DateField.DATEFIELD_M, step: 1, spacing: 1000 * 7200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 12
	TICK_PLACEMENT[Granularity.QUARTERLY] = { datefield: DateField.DATEFIELD_M, step: 3, spacing: 1000 * 21600 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 4
	TICK_PLACEMENT[Granularity.BIANNUAL] = { datefield: DateField.DATEFIELD_M, step: 6, spacing: 1000 * 43200 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 / 2
	TICK_PLACEMENT[Granularity.ANNUAL] = { datefield: DateField.DATEFIELD_Y, step: 1, spacing: 1000 * 86400 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 1
	TICK_PLACEMENT[Granularity.DECADAL] = { datefield: DateField.DATEFIELD_Y, step: 10, spacing: 1000 * 864000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 10
	TICK_PLACEMENT[Granularity.CENTENNIAL] = { datefield: DateField.DATEFIELD_Y, step: 100, spacing: 1000 * 8640000 * 365.2524 }; // 1e3 * 60 * 60 * 24 * 365.2524 * 100

	/**
	 * This is a list of human-friendly values at which to show tick marks on a log
	 * scale. It is k * 10^n, where k=1..9 and n=-39..+39, so:
	 * ..., 1, 2, 3, 4, 5, ..., 9, 10, 20, 30, ..., 90, 100, 200, 300, ...
	 * NOTE: this assumes that utils.LOG_SCALE = 10.
	 * @type {Array.<number>}
	 */
	var PREFERRED_LOG_TICK_VALUES = (function () {
	  var vals = [];
	  for (var power = -39; power <= 39; power++) {
	    var range = Math.pow(10, power);
	    for (var mult = 1; mult <= 9; mult++) {
	      var val = range * mult;
	      vals.push(val);
	    }
	  }
	  return vals;
	})();

	/**
	 * Determine the correct granularity of ticks on a date axis.
	 *
	 * @param {number} a Left edge of the chart (ms)
	 * @param {number} b Right edge of the chart (ms)
	 * @param {number} pixels Size of the chart in the relevant dimension (width).
	 * @param {function(string):*} opts Function mapping from option name -&gt; value.
	 * @return {number} The appropriate axis granularity for this chart. See the
	 *     enumeration of possible values in dygraph-tickers.js.
	 */
	var pickDateTickGranularity = function pickDateTickGranularity(a, b, pixels, opts) {
	  var pixels_per_tick = /** @type{number} */opts('pixelsPerLabel');
	  for (var i = 0; i < Granularity.NUM_GRANULARITIES; i++) {
	    var num_ticks = numDateTicks(a, b, i);
	    if (pixels / num_ticks >= pixels_per_tick) {
	      return i;
	    }
	  }
	  return -1;
	};

	/**
	 * Compute the number of ticks on a date axis for a given granularity.
	 * @param {number} start_time
	 * @param {number} end_time
	 * @param {number} granularity (one of the granularities enumerated above)
	 * @return {number} (Approximate) number of ticks that would result.
	 */
	var numDateTicks = function numDateTicks(start_time, end_time, granularity) {
	  var spacing = TICK_PLACEMENT[granularity].spacing;
	  return Math.round(1.0 * (end_time - start_time) / spacing);
	};

	/**
	 * Compute the positions and labels of ticks on a date axis for a given granularity.
	 * @param {number} start_time
	 * @param {number} end_time
	 * @param {number} granularity (one of the granularities enumerated above)
	 * @param {function(string):*} opts Function mapping from option name -&gt; value.
	 * @param {Dygraph=} dg
	 * @return {!TickList}
	 */
	var getDateAxis = function getDateAxis(start_time, end_time, granularity, opts, dg) {
	  var formatter = /** @type{AxisLabelFormatter} */opts("axisLabelFormatter");
	  var utc = opts("labelsUTC");
	  var accessors = utc ? utils.DateAccessorsUTC : utils.DateAccessorsLocal;

	  var datefield = TICK_PLACEMENT[granularity].datefield;
	  var step = TICK_PLACEMENT[granularity].step;
	  var spacing = TICK_PLACEMENT[granularity].spacing;

	  // Choose a nice tick position before the initial instant.
	  // Currently, this code deals properly with the existent daily granularities:
	  // DAILY (with step of 1) and WEEKLY (with step of 7 but specially handled).
	  // Other daily granularities (say TWO_DAILY) should also be handled specially
	  // by setting the start_date_offset to 0.
	  var start_date = new Date(start_time);
	  var date_array = [];
	  date_array[DateField.DATEFIELD_Y] = accessors.getFullYear(start_date);
	  date_array[DateField.DATEFIELD_M] = accessors.getMonth(start_date);
	  date_array[DateField.DATEFIELD_D] = accessors.getDate(start_date);
	  date_array[DateField.DATEFIELD_HH] = accessors.getHours(start_date);
	  date_array[DateField.DATEFIELD_MM] = accessors.getMinutes(start_date);
	  date_array[DateField.DATEFIELD_SS] = accessors.getSeconds(start_date);
	  date_array[DateField.DATEFIELD_MS] = accessors.getMilliseconds(start_date);

	  var start_date_offset = date_array[datefield] % step;
	  if (granularity == Granularity.WEEKLY) {
	    // This will put the ticks on Sundays.
	    start_date_offset = accessors.getDay(start_date);
	  }

	  date_array[datefield] -= start_date_offset;
	  for (var df = datefield + 1; df < DateField.NUM_DATEFIELDS; df++) {
	    // The minimum value is 1 for the day of month, and 0 for all other fields.
	    date_array[df] = df === DateField.DATEFIELD_D ? 1 : 0;
	  }

	  // Generate the ticks.
	  // For granularities not coarser than HOURLY we use the fact that:
	  //   the number of milliseconds between ticks is constant
	  //   and equal to the defined spacing.
	  // Otherwise we rely on the 'roll over' property of the Date functions:
	  //   when some date field is set to a value outside of its logical range,
	  //   the excess 'rolls over' the next (more significant) field.
	  // However, when using local time with DST transitions,
	  // there are dates that do not represent any time value at all
	  // (those in the hour skipped at the 'spring forward'),
	  // and the JavaScript engines usually return an equivalent value.
	  // Hence we have to check that the date is properly increased at each step,
	  // returning a date at a nice tick position.
	  var ticks = [];
	  var tick_date = accessors.makeDate.apply(null, date_array);
	  var tick_time = tick_date.getTime();
	  if (granularity <= Granularity.HOURLY) {
	    if (tick_time < start_time) {
	      tick_time += spacing;
	      tick_date = new Date(tick_time);
	    }
	    while (tick_time <= end_time) {
	      ticks.push({ v: tick_time,
	        label: formatter.call(dg, tick_date, granularity, opts, dg)
	      });
	      tick_time += spacing;
	      tick_date = new Date(tick_time);
	    }
	  } else {
	    if (tick_time < start_time) {
	      date_array[datefield] += step;
	      tick_date = accessors.makeDate.apply(null, date_array);
	      tick_time = tick_date.getTime();
	    }
	    while (tick_time <= end_time) {
	      if (granularity >= Granularity.DAILY || accessors.getHours(tick_date) % step === 0) {
	        ticks.push({ v: tick_time,
	          label: formatter.call(dg, tick_date, granularity, opts, dg)
	        });
	      }
	      date_array[datefield] += step;
	      tick_date = accessors.makeDate.apply(null, date_array);
	      tick_time = tick_date.getTime();
	    }
	  }
	  return ticks;
	};
	exports.getDateAxis = getDateAxis;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2006 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview Based on PlotKit.CanvasRenderer, but modified to meet the
	 * needs of dygraphs.
	 *
	 * In particular, support for:
	 * - grid overlays
	 * - error bars
	 * - dygraphs attribute system
	 */

	/**
	 * The DygraphCanvasRenderer class does the actual rendering of the chart onto
	 * a canvas. It's based on PlotKit.CanvasRenderer.
	 * @param {Object} element The canvas to attach to
	 * @param {Object} elementContext The 2d context of the canvas (injected so it
	 * can be mocked for testing.)
	 * @param {Layout} layout The DygraphLayout object for this graph.
	 * @constructor
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	var _dygraph = __webpack_require__(164);

	var _dygraph2 = _interopRequireDefault(_dygraph);

	/**
	 * @constructor
	 *
	 * This gets called when there are "new points" to chart. This is generally the
	 * case when the underlying data being charted has changed. It is _not_ called
	 * in the common case that the user has zoomed or is panning the view.
	 *
	 * The chart canvas has already been created by the Dygraph object. The
	 * renderer simply gets a drawing context.
	 *
	 * @param {Dygraph} dygraph The chart to which this renderer belongs.
	 * @param {HTMLCanvasElement} element The &lt;canvas&gt; DOM element on which to draw.
	 * @param {CanvasRenderingContext2D} elementContext The drawing context.
	 * @param {DygraphLayout} layout The chart's DygraphLayout object.
	 *
	 * TODO(danvk): remove the elementContext property.
	 */
	var DygraphCanvasRenderer = function DygraphCanvasRenderer(dygraph, element, elementContext, layout) {
	  this.dygraph_ = dygraph;

	  this.layout = layout;
	  this.element = element;
	  this.elementContext = elementContext;

	  this.height = dygraph.height_;
	  this.width = dygraph.width_;

	  // --- check whether everything is ok before we return
	  if (!utils.isCanvasSupported(this.element)) {
	    throw "Canvas is not supported.";
	  }

	  // internal state
	  this.area = layout.getPlotArea();

	  // Set up a clipping area for the canvas (and the interaction canvas).
	  // This ensures that we don't overdraw.
	  var ctx = this.dygraph_.canvas_ctx_;
	  ctx.beginPath();
	  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);
	  ctx.clip();

	  ctx = this.dygraph_.hidden_ctx_;
	  ctx.beginPath();
	  ctx.rect(this.area.x, this.area.y, this.area.w, this.area.h);
	  ctx.clip();
	};

	/**
	 * Clears out all chart content and DOM elements.
	 * This is called immediately before render() on every frame, including
	 * during zooms and pans.
	 * @private
	 */
	DygraphCanvasRenderer.prototype.clear = function () {
	  this.elementContext.clearRect(0, 0, this.width, this.height);
	};

	/**
	 * This method is responsible for drawing everything on the chart, including
	 * lines, error bars, fills and axes.
	 * It is called immediately after clear() on every frame, including during pans
	 * and zooms.
	 * @private
	 */
	DygraphCanvasRenderer.prototype.render = function () {
	  // attaches point.canvas{x,y}
	  this._updatePoints();

	  // actually draws the chart.
	  this._renderLineChart();
	};

	/**
	 * Returns a predicate to be used with an iterator, which will
	 * iterate over points appropriately, depending on whether
	 * connectSeparatedPoints is true. When it's false, the predicate will
	 * skip over points with missing yVals.
	 */
	DygraphCanvasRenderer._getIteratorPredicate = function (connectSeparatedPoints) {
	  return connectSeparatedPoints ? DygraphCanvasRenderer._predicateThatSkipsEmptyPoints : null;
	};

	DygraphCanvasRenderer._predicateThatSkipsEmptyPoints = function (array, idx) {
	  return array[idx].yval !== null;
	};

	/**
	 * Draws a line with the styles passed in and calls all the drawPointCallbacks.
	 * @param {Object} e The dictionary passed to the plotter function.
	 * @private
	 */
	DygraphCanvasRenderer._drawStyledLine = function (e, color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize) {
	  var g = e.dygraph;
	  // TODO(konigsberg): Compute attributes outside this method call.
	  var stepPlot = g.getBooleanOption("stepPlot", e.setName);

	  if (!utils.isArrayLike(strokePattern)) {
	    strokePattern = null;
	  }

	  var drawGapPoints = g.getBooleanOption('drawGapEdgePoints', e.setName);

	  var points = e.points;
	  var setName = e.setName;
	  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

	  var stroking = strokePattern && strokePattern.length >= 2;

	  var ctx = e.drawingContext;
	  ctx.save();
	  if (stroking) {
	    if (ctx.setLineDash) ctx.setLineDash(strokePattern);
	  }

	  var pointsOnLine = DygraphCanvasRenderer._drawSeries(e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color);
	  DygraphCanvasRenderer._drawPointsOnLine(e, pointsOnLine, drawPointCallback, color, pointSize);

	  if (stroking) {
	    if (ctx.setLineDash) ctx.setLineDash([]);
	  }

	  ctx.restore();
	};

	/**
	 * This does the actual drawing of lines on the canvas, for just one series.
	 * Returns a list of [canvasx, canvasy] pairs for points for which a
	 * drawPointCallback should be fired.  These include isolated points, or all
	 * points if drawPoints=true.
	 * @param {Object} e The dictionary passed to the plotter function.
	 * @private
	 */
	DygraphCanvasRenderer._drawSeries = function (e, iter, strokeWidth, pointSize, drawPoints, drawGapPoints, stepPlot, color) {

	  var prevCanvasX = null;
	  var prevCanvasY = null;
	  var nextCanvasY = null;
	  var isIsolated; // true if this point is isolated (no line segments)
	  var point; // the point being processed in the while loop
	  var pointsOnLine = []; // Array of [canvasx, canvasy] pairs.
	  var first = true; // the first cycle through the while loop

	  var ctx = e.drawingContext;
	  ctx.beginPath();
	  ctx.strokeStyle = color;
	  ctx.lineWidth = strokeWidth;

	  // NOTE: we break the iterator's encapsulation here for about a 25% speedup.
	  var arr = iter.array_;
	  var limit = iter.end_;
	  var predicate = iter.predicate_;

	  for (var i = iter.start_; i < limit; i++) {
	    point = arr[i];
	    if (predicate) {
	      while (i < limit && !predicate(arr, i)) {
	        i++;
	      }
	      if (i == limit) break;
	      point = arr[i];
	    }

	    // FIXME: The 'canvasy != canvasy' test here catches NaN values but the test
	    // doesn't catch Infinity values. Could change this to
	    // !isFinite(point.canvasy), but I assume it avoids isNaN for performance?
	    if (point.canvasy === null || point.canvasy != point.canvasy) {
	      if (stepPlot && prevCanvasX !== null) {
	        // Draw a horizontal line to the start of the missing data
	        ctx.moveTo(prevCanvasX, prevCanvasY);
	        ctx.lineTo(point.canvasx, prevCanvasY);
	      }
	      prevCanvasX = prevCanvasY = null;
	    } else {
	      isIsolated = false;
	      if (drawGapPoints || prevCanvasX === null) {
	        iter.nextIdx_ = i;
	        iter.next();
	        nextCanvasY = iter.hasNext ? iter.peek.canvasy : null;

	        var isNextCanvasYNullOrNaN = nextCanvasY === null || nextCanvasY != nextCanvasY;
	        isIsolated = prevCanvasX === null && isNextCanvasYNullOrNaN;
	        if (drawGapPoints) {
	          // Also consider a point to be "isolated" if it's adjacent to a
	          // null point, excluding the graph edges.
	          if (!first && prevCanvasX === null || iter.hasNext && isNextCanvasYNullOrNaN) {
	            isIsolated = true;
	          }
	        }
	      }

	      if (prevCanvasX !== null) {
	        if (strokeWidth) {
	          if (stepPlot) {
	            ctx.moveTo(prevCanvasX, prevCanvasY);
	            ctx.lineTo(point.canvasx, prevCanvasY);
	          }

	          ctx.lineTo(point.canvasx, point.canvasy);
	        }
	      } else {
	        ctx.moveTo(point.canvasx, point.canvasy);
	      }
	      if (drawPoints || isIsolated) {
	        pointsOnLine.push([point.canvasx, point.canvasy, point.idx]);
	      }
	      prevCanvasX = point.canvasx;
	      prevCanvasY = point.canvasy;
	    }
	    first = false;
	  }
	  ctx.stroke();
	  return pointsOnLine;
	};

	/**
	 * This fires the drawPointCallback functions, which draw dots on the points by
	 * default. This gets used when the "drawPoints" option is set, or when there
	 * are isolated points.
	 * @param {Object} e The dictionary passed to the plotter function.
	 * @private
	 */
	DygraphCanvasRenderer._drawPointsOnLine = function (e, pointsOnLine, drawPointCallback, color, pointSize) {
	  var ctx = e.drawingContext;
	  for (var idx = 0; idx < pointsOnLine.length; idx++) {
	    var cb = pointsOnLine[idx];
	    ctx.save();
	    drawPointCallback.call(e.dygraph, e.dygraph, e.setName, ctx, cb[0], cb[1], color, pointSize, cb[2]);
	    ctx.restore();
	  }
	};

	/**
	 * Attaches canvas coordinates to the points array.
	 * @private
	 */
	DygraphCanvasRenderer.prototype._updatePoints = function () {
	  // Update Points
	  // TODO(danvk): here
	  //
	  // TODO(bhs): this loop is a hot-spot for high-point-count charts. These
	  // transformations can be pushed into the canvas via linear transformation
	  // matrices.
	  // NOTE(danvk): this is trickier than it sounds at first. The transformation
	  // needs to be done before the .moveTo() and .lineTo() calls, but must be
	  // undone before the .stroke() call to ensure that the stroke width is
	  // unaffected.  An alternative is to reduce the stroke width in the
	  // transformed coordinate space, but you can't specify different values for
	  // each dimension (as you can with .scale()). The speedup here is ~12%.
	  var sets = this.layout.points;
	  for (var i = sets.length; i--;) {
	    var points = sets[i];
	    for (var j = points.length; j--;) {
	      var point = points[j];
	      point.canvasx = this.area.w * point.x + this.area.x;
	      point.canvasy = this.area.h * point.y + this.area.y;
	    }
	  }
	};

	/**
	 * Add canvas Actually draw the lines chart, including error bars.
	 *
	 * This function can only be called if DygraphLayout's points array has been
	 * updated with canvas{x,y} attributes, i.e. by
	 * DygraphCanvasRenderer._updatePoints.
	 *
	 * @param {string=} opt_seriesName when specified, only that series will
	 *     be drawn. (This is used for expedited redrawing with highlightSeriesOpts)
	 * @param {CanvasRenderingContext2D} opt_ctx when specified, the drawing
	 *     context.  However, lines are typically drawn on the object's
	 *     elementContext.
	 * @private
	 */
	DygraphCanvasRenderer.prototype._renderLineChart = function (opt_seriesName, opt_ctx) {
	  var ctx = opt_ctx || this.elementContext;
	  var i;

	  var sets = this.layout.points;
	  var setNames = this.layout.setNames;
	  var setName;

	  this.colors = this.dygraph_.colorsMap_;

	  // Determine which series have specialized plotters.
	  var plotter_attr = this.dygraph_.getOption("plotter");
	  var plotters = plotter_attr;
	  if (!utils.isArrayLike(plotters)) {
	    plotters = [plotters];
	  }

	  var setPlotters = {}; // series name -> plotter fn.
	  for (i = 0; i < setNames.length; i++) {
	    setName = setNames[i];
	    var setPlotter = this.dygraph_.getOption("plotter", setName);
	    if (setPlotter == plotter_attr) continue; // not specialized.

	    setPlotters[setName] = setPlotter;
	  }

	  for (i = 0; i < plotters.length; i++) {
	    var plotter = plotters[i];
	    var is_last = i == plotters.length - 1;

	    for (var j = 0; j < sets.length; j++) {
	      setName = setNames[j];
	      if (opt_seriesName && setName != opt_seriesName) continue;

	      var points = sets[j];

	      // Only throw in the specialized plotters on the last iteration.
	      var p = plotter;
	      if (setName in setPlotters) {
	        if (is_last) {
	          p = setPlotters[setName];
	        } else {
	          // Don't use the standard plotters in this case.
	          continue;
	        }
	      }

	      var color = this.colors[setName];
	      var strokeWidth = this.dygraph_.getOption("strokeWidth", setName);

	      ctx.save();
	      ctx.strokeStyle = color;
	      ctx.lineWidth = strokeWidth;
	      p({
	        points: points,
	        setName: setName,
	        drawingContext: ctx,
	        color: color,
	        strokeWidth: strokeWidth,
	        dygraph: this.dygraph_,
	        axis: this.dygraph_.axisPropertiesForSeries(setName),
	        plotArea: this.area,
	        seriesIndex: j,
	        seriesCount: sets.length,
	        singleSeriesName: opt_seriesName,
	        allSeriesPoints: sets
	      });
	      ctx.restore();
	    }
	  }
	};

	/**
	 * Standard plotters. These may be used by clients via Dygraph.Plotters.
	 * See comments there for more details.
	 */
	DygraphCanvasRenderer._Plotters = {
	  linePlotter: function linePlotter(e) {
	    DygraphCanvasRenderer._linePlotter(e);
	  },

	  fillPlotter: function fillPlotter(e) {
	    DygraphCanvasRenderer._fillPlotter(e);
	  },

	  errorPlotter: function errorPlotter(e) {
	    DygraphCanvasRenderer._errorPlotter(e);
	  }
	};

	/**
	 * Plotter which draws the central lines for a series.
	 * @private
	 */
	DygraphCanvasRenderer._linePlotter = function (e) {
	  var g = e.dygraph;
	  var setName = e.setName;
	  var strokeWidth = e.strokeWidth;

	  // TODO(danvk): Check if there's any performance impact of just calling
	  // getOption() inside of _drawStyledLine. Passing in so many parameters makes
	  // this code a bit nasty.
	  var borderWidth = g.getNumericOption("strokeBorderWidth", setName);
	  var drawPointCallback = g.getOption("drawPointCallback", setName) || utils.Circles.DEFAULT;
	  var strokePattern = g.getOption("strokePattern", setName);
	  var drawPoints = g.getBooleanOption("drawPoints", setName);
	  var pointSize = g.getNumericOption("pointSize", setName);

	  if (borderWidth && strokeWidth) {
	    DygraphCanvasRenderer._drawStyledLine(e, g.getOption("strokeBorderColor", setName), strokeWidth + 2 * borderWidth, strokePattern, drawPoints, drawPointCallback, pointSize);
	  }

	  DygraphCanvasRenderer._drawStyledLine(e, e.color, strokeWidth, strokePattern, drawPoints, drawPointCallback, pointSize);
	};

	/**
	 * Draws the shaded error bars/confidence intervals for each series.
	 * This happens before the center lines are drawn, since the center lines
	 * need to be drawn on top of the error bars for all series.
	 * @private
	 */
	DygraphCanvasRenderer._errorPlotter = function (e) {
	  var g = e.dygraph;
	  var setName = e.setName;
	  var errorBars = g.getBooleanOption("errorBars") || g.getBooleanOption("customBars");
	  if (!errorBars) return;

	  var fillGraph = g.getBooleanOption("fillGraph", setName);
	  if (fillGraph) {
	    console.warn("Can't use fillGraph option with error bars");
	  }

	  var ctx = e.drawingContext;
	  var color = e.color;
	  var fillAlpha = g.getNumericOption('fillAlpha', setName);
	  var stepPlot = g.getBooleanOption("stepPlot", setName);
	  var points = e.points;

	  var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

	  var newYs;

	  // setup graphics context
	  var prevX = NaN;
	  var prevY = NaN;
	  var prevYs = [-1, -1];
	  // should be same color as the lines but only 15% opaque.
	  var rgb = utils.toRGB_(color);
	  var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';
	  ctx.fillStyle = err_color;
	  ctx.beginPath();

	  var isNullUndefinedOrNaN = function isNullUndefinedOrNaN(x) {
	    return x === null || x === undefined || isNaN(x);
	  };

	  while (iter.hasNext) {
	    var point = iter.next();
	    if (!stepPlot && isNullUndefinedOrNaN(point.y) || stepPlot && !isNaN(prevY) && isNullUndefinedOrNaN(prevY)) {
	      prevX = NaN;
	      continue;
	    }

	    newYs = [point.y_bottom, point.y_top];
	    if (stepPlot) {
	      prevY = point.y;
	    }

	    // The documentation specifically disallows nulls inside the point arrays,
	    // but in case it happens we should do something sensible.
	    if (isNaN(newYs[0])) newYs[0] = point.y;
	    if (isNaN(newYs[1])) newYs[1] = point.y;

	    newYs[0] = e.plotArea.h * newYs[0] + e.plotArea.y;
	    newYs[1] = e.plotArea.h * newYs[1] + e.plotArea.y;
	    if (!isNaN(prevX)) {
	      if (stepPlot) {
	        ctx.moveTo(prevX, prevYs[0]);
	        ctx.lineTo(point.canvasx, prevYs[0]);
	        ctx.lineTo(point.canvasx, prevYs[1]);
	      } else {
	        ctx.moveTo(prevX, prevYs[0]);
	        ctx.lineTo(point.canvasx, newYs[0]);
	        ctx.lineTo(point.canvasx, newYs[1]);
	      }
	      ctx.lineTo(prevX, prevYs[1]);
	      ctx.closePath();
	    }
	    prevYs = newYs;
	    prevX = point.canvasx;
	  }
	  ctx.fill();
	};

	/**
	 * Proxy for CanvasRenderingContext2D which drops moveTo/lineTo calls which are
	 * superfluous. It accumulates all movements which haven't changed the x-value
	 * and only applies the two with the most extreme y-values.
	 *
	 * Calls to lineTo/moveTo must have non-decreasing x-values.
	 */
	DygraphCanvasRenderer._fastCanvasProxy = function (context) {
	  var pendingActions = []; // array of [type, x, y] tuples
	  var lastRoundedX = null;
	  var lastFlushedX = null;

	  var LINE_TO = 1,
	      MOVE_TO = 2;

	  var actionCount = 0; // number of moveTos and lineTos passed to context.

	  // Drop superfluous motions
	  // Assumes all pendingActions have the same (rounded) x-value.
	  var compressActions = function compressActions(opt_losslessOnly) {
	    if (pendingActions.length <= 1) return;

	    // Lossless compression: drop inconsequential moveTos.
	    for (var i = pendingActions.length - 1; i > 0; i--) {
	      var action = pendingActions[i];
	      if (action[0] == MOVE_TO) {
	        var prevAction = pendingActions[i - 1];
	        if (prevAction[1] == action[1] && prevAction[2] == action[2]) {
	          pendingActions.splice(i, 1);
	        }
	      }
	    }

	    // Lossless compression: ... drop consecutive moveTos ...
	    for (var i = 0; i < pendingActions.length - 1;) /* incremented internally */{
	      var action = pendingActions[i];
	      if (action[0] == MOVE_TO && pendingActions[i + 1][0] == MOVE_TO) {
	        pendingActions.splice(i, 1);
	      } else {
	        i++;
	      }
	    }

	    // Lossy compression: ... drop all but the extreme y-values ...
	    if (pendingActions.length > 2 && !opt_losslessOnly) {
	      // keep an initial moveTo, but drop all others.
	      var startIdx = 0;
	      if (pendingActions[0][0] == MOVE_TO) startIdx++;
	      var minIdx = null,
	          maxIdx = null;
	      for (var i = startIdx; i < pendingActions.length; i++) {
	        var action = pendingActions[i];
	        if (action[0] != LINE_TO) continue;
	        if (minIdx === null && maxIdx === null) {
	          minIdx = i;
	          maxIdx = i;
	        } else {
	          var y = action[2];
	          if (y < pendingActions[minIdx][2]) {
	            minIdx = i;
	          } else if (y > pendingActions[maxIdx][2]) {
	            maxIdx = i;
	          }
	        }
	      }
	      var minAction = pendingActions[minIdx],
	          maxAction = pendingActions[maxIdx];
	      pendingActions.splice(startIdx, pendingActions.length - startIdx);
	      if (minIdx < maxIdx) {
	        pendingActions.push(minAction);
	        pendingActions.push(maxAction);
	      } else if (minIdx > maxIdx) {
	        pendingActions.push(maxAction);
	        pendingActions.push(minAction);
	      } else {
	        pendingActions.push(minAction);
	      }
	    }
	  };

	  var flushActions = function flushActions(opt_noLossyCompression) {
	    compressActions(opt_noLossyCompression);
	    for (var i = 0, len = pendingActions.length; i < len; i++) {
	      var action = pendingActions[i];
	      if (action[0] == LINE_TO) {
	        context.lineTo(action[1], action[2]);
	      } else if (action[0] == MOVE_TO) {
	        context.moveTo(action[1], action[2]);
	      }
	    }
	    if (pendingActions.length) {
	      lastFlushedX = pendingActions[pendingActions.length - 1][1];
	    }
	    actionCount += pendingActions.length;
	    pendingActions = [];
	  };

	  var addAction = function addAction(action, x, y) {
	    var rx = Math.round(x);
	    if (lastRoundedX === null || rx != lastRoundedX) {
	      // if there are large gaps on the x-axis, it's essential to keep the
	      // first and last point as well.
	      var hasGapOnLeft = lastRoundedX - lastFlushedX > 1,
	          hasGapOnRight = rx - lastRoundedX > 1,
	          hasGap = hasGapOnLeft || hasGapOnRight;
	      flushActions(hasGap);
	      lastRoundedX = rx;
	    }
	    pendingActions.push([action, x, y]);
	  };

	  return {
	    moveTo: function moveTo(x, y) {
	      addAction(MOVE_TO, x, y);
	    },
	    lineTo: function lineTo(x, y) {
	      addAction(LINE_TO, x, y);
	    },

	    // for major operations like stroke/fill, we skip compression to ensure
	    // that there are no artifacts at the right edge.
	    stroke: function stroke() {
	      flushActions(true);context.stroke();
	    },
	    fill: function fill() {
	      flushActions(true);context.fill();
	    },
	    beginPath: function beginPath() {
	      flushActions(true);context.beginPath();
	    },
	    closePath: function closePath() {
	      flushActions(true);context.closePath();
	    },

	    _count: function _count() {
	      return actionCount;
	    }
	  };
	};

	/**
	 * Draws the shaded regions when "fillGraph" is set. Not to be confused with
	 * error bars.
	 *
	 * For stacked charts, it's more convenient to handle all the series
	 * simultaneously. So this plotter plots all the points on the first series
	 * it's asked to draw, then ignores all the other series.
	 *
	 * @private
	 */
	DygraphCanvasRenderer._fillPlotter = function (e) {
	  // Skip if we're drawing a single series for interactive highlight overlay.
	  if (e.singleSeriesName) return;

	  // We'll handle all the series at once, not one-by-one.
	  if (e.seriesIndex !== 0) return;

	  var g = e.dygraph;
	  var setNames = g.getLabels().slice(1); // remove x-axis

	  // getLabels() includes names for invisible series, which are not included in
	  // allSeriesPoints. We remove those to make the two match.
	  // TODO(danvk): provide a simpler way to get this information.
	  for (var i = setNames.length; i >= 0; i--) {
	    if (!g.visibility()[i]) setNames.splice(i, 1);
	  }

	  var anySeriesFilled = (function () {
	    for (var i = 0; i < setNames.length; i++) {
	      if (g.getBooleanOption("fillGraph", setNames[i])) return true;
	    }
	    return false;
	  })();

	  if (!anySeriesFilled) return;

	  var area = e.plotArea;
	  var sets = e.allSeriesPoints;
	  var setCount = sets.length;

	  var stackedGraph = g.getBooleanOption("stackedGraph");
	  var colors = g.getColors();

	  // For stacked graphs, track the baseline for filling.
	  //
	  // The filled areas below graph lines are trapezoids with two
	  // vertical edges. The top edge is the line segment being drawn, and
	  // the baseline is the bottom edge. Each baseline corresponds to the
	  // top line segment from the previous stacked line. In the case of
	  // step plots, the trapezoids are rectangles.
	  var baseline = {};
	  var currBaseline;
	  var prevStepPlot; // for different line drawing modes (line/step) per series

	  // Helper function to trace a line back along the baseline.
	  var traceBackPath = function traceBackPath(ctx, baselineX, baselineY, pathBack) {
	    ctx.lineTo(baselineX, baselineY);
	    if (stackedGraph) {
	      for (var i = pathBack.length - 1; i >= 0; i--) {
	        var pt = pathBack[i];
	        ctx.lineTo(pt[0], pt[1]);
	      }
	    }
	  };

	  // process sets in reverse order (needed for stacked graphs)
	  for (var setIdx = setCount - 1; setIdx >= 0; setIdx--) {
	    var ctx = e.drawingContext;
	    var setName = setNames[setIdx];
	    if (!g.getBooleanOption('fillGraph', setName)) continue;

	    var fillAlpha = g.getNumericOption('fillAlpha', setName);
	    var stepPlot = g.getBooleanOption('stepPlot', setName);
	    var color = colors[setIdx];
	    var axis = g.axisPropertiesForSeries(setName);
	    var axisY = 1.0 + axis.minyval * axis.yscale;
	    if (axisY < 0.0) axisY = 0.0;else if (axisY > 1.0) axisY = 1.0;
	    axisY = area.h * axisY + area.y;

	    var points = sets[setIdx];
	    var iter = utils.createIterator(points, 0, points.length, DygraphCanvasRenderer._getIteratorPredicate(g.getBooleanOption("connectSeparatedPoints", setName)));

	    // setup graphics context
	    var prevX = NaN;
	    var prevYs = [-1, -1];
	    var newYs;
	    // should be same color as the lines but only 15% opaque.
	    var rgb = utils.toRGB_(color);
	    var err_color = 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + fillAlpha + ')';
	    ctx.fillStyle = err_color;
	    ctx.beginPath();
	    var last_x,
	        is_first = true;

	    // If the point density is high enough, dropping segments on their way to
	    // the canvas justifies the overhead of doing so.
	    if (points.length > 2 * g.width_ || _dygraph2['default'].FORCE_FAST_PROXY) {
	      ctx = DygraphCanvasRenderer._fastCanvasProxy(ctx);
	    }

	    // For filled charts, we draw points from left to right, then back along
	    // the x-axis to complete a shape for filling.
	    // For stacked plots, this "back path" is a more complex shape. This array
	    // stores the [x, y] values needed to trace that shape.
	    var pathBack = [];

	    // TODO(danvk): there are a lot of options at play in this loop.
	    //     The logic would be much clearer if some (e.g. stackGraph and
	    //     stepPlot) were split off into separate sub-plotters.
	    var point;
	    while (iter.hasNext) {
	      point = iter.next();
	      if (!utils.isOK(point.y) && !stepPlot) {
	        traceBackPath(ctx, prevX, prevYs[1], pathBack);
	        pathBack = [];
	        prevX = NaN;
	        if (point.y_stacked !== null && !isNaN(point.y_stacked)) {
	          baseline[point.canvasx] = area.h * point.y_stacked + area.y;
	        }
	        continue;
	      }
	      if (stackedGraph) {
	        if (!is_first && last_x == point.xval) {
	          continue;
	        } else {
	          is_first = false;
	          last_x = point.xval;
	        }

	        currBaseline = baseline[point.canvasx];
	        var lastY;
	        if (currBaseline === undefined) {
	          lastY = axisY;
	        } else {
	          if (prevStepPlot) {
	            lastY = currBaseline[0];
	          } else {
	            lastY = currBaseline;
	          }
	        }
	        newYs = [point.canvasy, lastY];

	        if (stepPlot) {
	          // Step plots must keep track of the top and bottom of
	          // the baseline at each point.
	          if (prevYs[0] === -1) {
	            baseline[point.canvasx] = [point.canvasy, axisY];
	          } else {
	            baseline[point.canvasx] = [point.canvasy, prevYs[0]];
	          }
	        } else {
	          baseline[point.canvasx] = point.canvasy;
	        }
	      } else {
	        if (isNaN(point.canvasy) && stepPlot) {
	          newYs = [area.y + area.h, axisY];
	        } else {
	          newYs = [point.canvasy, axisY];
	        }
	      }
	      if (!isNaN(prevX)) {
	        // Move to top fill point
	        if (stepPlot) {
	          ctx.lineTo(point.canvasx, prevYs[0]);
	          ctx.lineTo(point.canvasx, newYs[0]);
	        } else {
	          ctx.lineTo(point.canvasx, newYs[0]);
	        }

	        // Record the baseline for the reverse path.
	        if (stackedGraph) {
	          pathBack.push([prevX, prevYs[1]]);
	          if (prevStepPlot && currBaseline) {
	            // Draw to the bottom of the baseline
	            pathBack.push([point.canvasx, currBaseline[1]]);
	          } else {
	            pathBack.push([point.canvasx, newYs[1]]);
	          }
	        }
	      } else {
	        ctx.moveTo(point.canvasx, newYs[1]);
	        ctx.lineTo(point.canvasx, newYs[0]);
	      }
	      prevYs = newYs;
	      prevX = point.canvasx;
	    }
	    prevStepPlot = stepPlot;
	    if (newYs && point) {
	      traceBackPath(ctx, point.canvasx, newYs[1], pathBack);
	      pathBack = [];
	    }
	    ctx.fill();
	  }
	};

	exports['default'] = DygraphCanvasRenderer;
	module.exports = exports['default'];

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * @license
	 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview DygraphOptions is responsible for parsing and returning
	 * information about options.
	 */

	// TODO: remove this jshint directive & fix the warnings.
	/*jshint sub:true */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	var _dygraphDefaultAttrs = __webpack_require__(170);

	var _dygraphDefaultAttrs2 = _interopRequireDefault(_dygraphDefaultAttrs);

	var _dygraphOptionsReference = __webpack_require__(172);

	var _dygraphOptionsReference2 = _interopRequireDefault(_dygraphOptionsReference);

	/*
	 * Interesting member variables: (REMOVING THIS LIST AS I CLOSURIZE)
	 * global_ - global attributes (common among all graphs, AIUI)
	 * user - attributes set by the user
	 * series_ - { seriesName -> { idx, yAxis, options }}
	 */

	/**
	 * This parses attributes into an object that can be easily queried.
	 *
	 * It doesn't necessarily mean that all options are available, specifically
	 * if labels are not yet available, since those drive details of the per-series
	 * and per-axis options.
	 *
	 * @param {Dygraph} dygraph The chart to which these options belong.
	 * @constructor
	 */
	var DygraphOptions = function DygraphOptions(dygraph) {
	  /**
	   * The dygraph.
	   * @type {!Dygraph}
	   */
	  this.dygraph_ = dygraph;

	  /**
	   * Array of axis index to { series : [ series names ] , options : { axis-specific options. }
	   * @type {Array.<{series : Array.<string>, options : Object}>} @private
	   */
	  this.yAxes_ = [];

	  /**
	   * Contains x-axis specific options, which are stored in the options key.
	   * This matches the yAxes_ object structure (by being a dictionary with an
	   * options element) allowing for shared code.
	   * @type {options: Object} @private
	   */
	  this.xAxis_ = {};
	  this.series_ = {};

	  // Once these two objects are initialized, you can call get();
	  this.global_ = this.dygraph_.attrs_;
	  this.user_ = this.dygraph_.user_attrs_ || {};

	  /**
	   * A list of series in columnar order.
	   * @type {Array.<string>}
	   */
	  this.labels_ = [];

	  this.highlightSeries_ = this.get("highlightSeriesOpts") || {};
	  this.reparseSeries();
	};

	/**
	 * Not optimal, but does the trick when you're only using two axes.
	 * If we move to more axes, this can just become a function.
	 *
	 * @type {Object.<number>}
	 * @private
	 */
	DygraphOptions.AXIS_STRING_MAPPINGS_ = {
	  'y': 0,
	  'Y': 0,
	  'y1': 0,
	  'Y1': 0,
	  'y2': 1,
	  'Y2': 1
	};

	/**
	 * @param {string|number} axis
	 * @private
	 */
	DygraphOptions.axisToIndex_ = function (axis) {
	  if (typeof axis == "string") {
	    if (DygraphOptions.AXIS_STRING_MAPPINGS_.hasOwnProperty(axis)) {
	      return DygraphOptions.AXIS_STRING_MAPPINGS_[axis];
	    }
	    throw "Unknown axis : " + axis;
	  }
	  if (typeof axis == "number") {
	    if (axis === 0 || axis === 1) {
	      return axis;
	    }
	    throw "Dygraphs only supports two y-axes, indexed from 0-1.";
	  }
	  if (axis) {
	    throw "Unknown axis : " + axis;
	  }
	  // No axis specification means axis 0.
	  return 0;
	};

	/**
	 * Reparses options that are all related to series. This typically occurs when
	 * options are either updated, or source data has been made available.
	 *
	 * TODO(konigsberg): The method name is kind of weak; fix.
	 */
	DygraphOptions.prototype.reparseSeries = function () {
	  var labels = this.get("labels");
	  if (!labels) {
	    return; // -- can't do more for now, will parse after getting the labels.
	  }

	  this.labels_ = labels.slice(1);

	  this.yAxes_ = [{ series: [], options: {} }]; // Always one axis at least.
	  this.xAxis_ = { options: {} };
	  this.series_ = {};

	  // Series are specified in the series element:
	  //
	  // {
	  //   labels: [ "X", "foo", "bar" ],
	  //   pointSize: 3,
	  //   series : {
	  //     foo : {}, // options for foo
	  //     bar : {} // options for bar
	  //   }
	  // }
	  //
	  // So, if series is found, it's expected to contain per-series data, otherwise set a
	  // default.
	  var seriesDict = this.user_.series || {};
	  for (var idx = 0; idx < this.labels_.length; idx++) {
	    var seriesName = this.labels_[idx];
	    var optionsForSeries = seriesDict[seriesName] || {};
	    var yAxis = DygraphOptions.axisToIndex_(optionsForSeries["axis"]);

	    this.series_[seriesName] = {
	      idx: idx,
	      yAxis: yAxis,
	      options: optionsForSeries };

	    if (!this.yAxes_[yAxis]) {
	      this.yAxes_[yAxis] = { series: [seriesName], options: {} };
	    } else {
	      this.yAxes_[yAxis].series.push(seriesName);
	    }
	  }

	  var axis_opts = this.user_["axes"] || {};
	  utils.update(this.yAxes_[0].options, axis_opts["y"] || {});
	  if (this.yAxes_.length > 1) {
	    utils.update(this.yAxes_[1].options, axis_opts["y2"] || {});
	  }
	  utils.update(this.xAxis_.options, axis_opts["x"] || {});

	  // For "production" code, this gets removed by uglifyjs.
	  if (typeof process !== 'undefined') {
	    if (process.env.NODE_ENV != 'production') {
	      this.validateOptions_();
	    }
	  }
	};

	/**
	 * Get a global value.
	 *
	 * @param {string} name the name of the option.
	 */
	DygraphOptions.prototype.get = function (name) {
	  var result = this.getGlobalUser_(name);
	  if (result !== null) {
	    return result;
	  }
	  return this.getGlobalDefault_(name);
	};

	DygraphOptions.prototype.getGlobalUser_ = function (name) {
	  if (this.user_.hasOwnProperty(name)) {
	    return this.user_[name];
	  }
	  return null;
	};

	DygraphOptions.prototype.getGlobalDefault_ = function (name) {
	  if (this.global_.hasOwnProperty(name)) {
	    return this.global_[name];
	  }
	  if (_dygraphDefaultAttrs2['default'].hasOwnProperty(name)) {
	    return _dygraphDefaultAttrs2['default'][name];
	  }
	  return null;
	};

	/**
	 * Get a value for a specific axis. If there is no specific value for the axis,
	 * the global value is returned.
	 *
	 * @param {string} name the name of the option.
	 * @param {string|number} axis the axis to search. Can be the string representation
	 * ("y", "y2") or the axis number (0, 1).
	 */
	DygraphOptions.prototype.getForAxis = function (name, axis) {
	  var axisIdx;
	  var axisString;

	  // Since axis can be a number or a string, straighten everything out here.
	  if (typeof axis == 'number') {
	    axisIdx = axis;
	    axisString = axisIdx === 0 ? "y" : "y2";
	  } else {
	    if (axis == "y1") {
	      axis = "y";
	    } // Standardize on 'y'. Is this bad? I think so.
	    if (axis == "y") {
	      axisIdx = 0;
	    } else if (axis == "y2") {
	      axisIdx = 1;
	    } else if (axis == "x") {
	      axisIdx = -1; // simply a placeholder for below.
	    } else {
	        throw "Unknown axis " + axis;
	      }
	    axisString = axis;
	  }

	  var userAxis = axisIdx == -1 ? this.xAxis_ : this.yAxes_[axisIdx];

	  // Search the user-specified axis option first.
	  if (userAxis) {
	    // This condition could be removed if we always set up this.yAxes_ for y2.
	    var axisOptions = userAxis.options;
	    if (axisOptions.hasOwnProperty(name)) {
	      return axisOptions[name];
	    }
	  }

	  // User-specified global options second.
	  // But, hack, ignore globally-specified 'logscale' for 'x' axis declaration.
	  if (!(axis === 'x' && name === 'logscale')) {
	    var result = this.getGlobalUser_(name);
	    if (result !== null) {
	      return result;
	    }
	  }
	  // Default axis options third.
	  var defaultAxisOptions = _dygraphDefaultAttrs2['default'].axes[axisString];
	  if (defaultAxisOptions.hasOwnProperty(name)) {
	    return defaultAxisOptions[name];
	  }

	  // Default global options last.
	  return this.getGlobalDefault_(name);
	};

	/**
	 * Get a value for a specific series. If there is no specific value for the series,
	 * the value for the axis is returned (and afterwards, the global value.)
	 *
	 * @param {string} name the name of the option.
	 * @param {string} series the series to search.
	 */
	DygraphOptions.prototype.getForSeries = function (name, series) {
	  // Honors indexes as series.
	  if (series === this.dygraph_.getHighlightSeries()) {
	    if (this.highlightSeries_.hasOwnProperty(name)) {
	      return this.highlightSeries_[name];
	    }
	  }

	  if (!this.series_.hasOwnProperty(series)) {
	    throw "Unknown series: " + series;
	  }

	  var seriesObj = this.series_[series];
	  var seriesOptions = seriesObj["options"];
	  if (seriesOptions.hasOwnProperty(name)) {
	    return seriesOptions[name];
	  }

	  return this.getForAxis(name, seriesObj["yAxis"]);
	};

	/**
	 * Returns the number of y-axes on the chart.
	 * @return {number} the number of axes.
	 */
	DygraphOptions.prototype.numAxes = function () {
	  return this.yAxes_.length;
	};

	/**
	 * Return the y-axis for a given series, specified by name.
	 */
	DygraphOptions.prototype.axisForSeries = function (series) {
	  return this.series_[series].yAxis;
	};

	/**
	 * Returns the options for the specified axis.
	 */
	// TODO(konigsberg): this is y-axis specific. Support the x axis.
	DygraphOptions.prototype.axisOptions = function (yAxis) {
	  return this.yAxes_[yAxis].options;
	};

	/**
	 * Return the series associated with an axis.
	 */
	DygraphOptions.prototype.seriesForAxis = function (yAxis) {
	  return this.yAxes_[yAxis].series;
	};

	/**
	 * Return the list of all series, in their columnar order.
	 */
	DygraphOptions.prototype.seriesNames = function () {
	  return this.labels_;
	};

	// For "production" code, this gets removed by uglifyjs.
	if (typeof process !== 'undefined') {
	  if (process.env.NODE_ENV != 'production') {

	    /**
	     * Validate all options.
	     * This requires OPTIONS_REFERENCE, which is only available in debug builds.
	     * @private
	     */
	    DygraphOptions.prototype.validateOptions_ = function () {
	      if (typeof _dygraphOptionsReference2['default'] === 'undefined') {
	        throw 'Called validateOptions_ in prod build.';
	      }

	      var that = this;
	      var validateOption = function validateOption(optionName) {
	        if (!_dygraphOptionsReference2['default'][optionName]) {
	          that.warnInvalidOption_(optionName);
	        }
	      };

	      var optionsDicts = [this.xAxis_.options, this.yAxes_[0].options, this.yAxes_[1] && this.yAxes_[1].options, this.global_, this.user_, this.highlightSeries_];
	      var names = this.seriesNames();
	      for (var i = 0; i < names.length; i++) {
	        var name = names[i];
	        if (this.series_.hasOwnProperty(name)) {
	          optionsDicts.push(this.series_[name].options);
	        }
	      }
	      for (var i = 0; i < optionsDicts.length; i++) {
	        var dict = optionsDicts[i];
	        if (!dict) continue;
	        for (var optionName in dict) {
	          if (dict.hasOwnProperty(optionName)) {
	            validateOption(optionName);
	          }
	        }
	      }
	    };

	    var WARNINGS = {}; // Only show any particular warning once.

	    /**
	     * Logs a warning about invalid options.
	     * TODO: make this throw for testing
	     * @private
	     */
	    DygraphOptions.prototype.warnInvalidOption_ = function (optionName) {
	      if (!WARNINGS[optionName]) {
	        WARNINGS[optionName] = true;
	        var isSeries = this.labels_.indexOf(optionName) >= 0;
	        if (isSeries) {
	          console.warn('Use new-style per-series options (saw ' + optionName + ' as top-level options key). See http://bit.ly/1tceaJs');
	        } else {
	          console.warn('Unknown option ' + optionName + ' (full list of options at dygraphs.com/options.html');
	        }
	        throw "invalid option " + optionName;
	      }
	    };

	    // Reset list of previously-shown warnings. Used for testing.
	    DygraphOptions.resetWarnings_ = function () {
	      WARNINGS = {};
	    };
	  }
	}

	exports['default'] = DygraphOptions;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _dygraphTickers = __webpack_require__(167);

	var DygraphTickers = _interopRequireWildcard(_dygraphTickers);

	var _dygraphInteractionModel = __webpack_require__(171);

	var _dygraphInteractionModel2 = _interopRequireDefault(_dygraphInteractionModel);

	var _dygraphCanvas = __webpack_require__(168);

	var _dygraphCanvas2 = _interopRequireDefault(_dygraphCanvas);

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	// Default attribute values.
	var DEFAULT_ATTRS = {
	  highlightCircleSize: 3,
	  highlightSeriesOpts: null,
	  highlightSeriesBackgroundAlpha: 0.5,
	  highlightSeriesBackgroundColor: 'rgb(255, 255, 255)',

	  labelsSeparateLines: false,
	  labelsShowZeroValues: true,
	  labelsKMB: false,
	  labelsKMG2: false,
	  showLabelsOnHighlight: true,

	  digitsAfterDecimal: 2,
	  maxNumberWidth: 6,
	  sigFigs: null,

	  strokeWidth: 1.0,
	  strokeBorderWidth: 0,
	  strokeBorderColor: "white",

	  axisTickSize: 3,
	  axisLabelFontSize: 14,
	  rightGap: 5,

	  showRoller: false,
	  xValueParser: undefined,

	  delimiter: ',',

	  sigma: 2.0,
	  errorBars: false,
	  fractions: false,
	  wilsonInterval: true, // only relevant if fractions is true
	  customBars: false,
	  fillGraph: false,
	  fillAlpha: 0.15,
	  connectSeparatedPoints: false,

	  stackedGraph: false,
	  stackedGraphNaNFill: 'all',
	  hideOverlayOnMouseOut: true,

	  legend: 'onmouseover',
	  stepPlot: false,
	  xRangePad: 0,
	  yRangePad: null,
	  drawAxesAtZero: false,

	  // Sizes of the various chart labels.
	  titleHeight: 28,
	  xLabelHeight: 18,
	  yLabelWidth: 18,

	  axisLineColor: "black",
	  axisLineWidth: 0.3,
	  gridLineWidth: 0.3,
	  axisLabelWidth: 50,
	  gridLineColor: "rgb(128,128,128)",

	  interactionModel: _dygraphInteractionModel2['default'].defaultModel,
	  animatedZooms: false, // (for now)

	  // Range selector options
	  showRangeSelector: false,
	  rangeSelectorHeight: 40,
	  rangeSelectorPlotStrokeColor: "#808FAB",
	  rangeSelectorPlotFillGradientColor: "white",
	  rangeSelectorPlotFillColor: "#A7B1C4",
	  rangeSelectorBackgroundStrokeColor: "gray",
	  rangeSelectorBackgroundLineWidth: 1,
	  rangeSelectorPlotLineWidth: 1.5,
	  rangeSelectorForegroundStrokeColor: "black",
	  rangeSelectorForegroundLineWidth: 1,
	  rangeSelectorAlpha: 0.6,
	  showInRangeSelector: null,

	  // The ordering here ensures that central lines always appear above any
	  // fill bars/error bars.
	  plotter: [_dygraphCanvas2['default']._fillPlotter, _dygraphCanvas2['default']._errorPlotter, _dygraphCanvas2['default']._linePlotter],

	  plugins: [],

	  // per-axis options
	  axes: {
	    x: {
	      pixelsPerLabel: 70,
	      axisLabelWidth: 60,
	      axisLabelFormatter: utils.dateAxisLabelFormatter,
	      valueFormatter: utils.dateValueFormatter,
	      drawGrid: true,
	      drawAxis: true,
	      independentTicks: true,
	      ticker: DygraphTickers.dateTicker
	    },
	    y: {
	      axisLabelWidth: 50,
	      pixelsPerLabel: 30,
	      valueFormatter: utils.numberValueFormatter,
	      axisLabelFormatter: utils.numberAxisLabelFormatter,
	      drawGrid: true,
	      drawAxis: true,
	      independentTicks: true,
	      ticker: DygraphTickers.numericTicks
	    },
	    y2: {
	      axisLabelWidth: 50,
	      pixelsPerLabel: 30,
	      valueFormatter: utils.numberValueFormatter,
	      axisLabelFormatter: utils.numberAxisLabelFormatter,
	      drawAxis: true, // only applies when there are two axes of data.
	      drawGrid: false,
	      independentTicks: false,
	      ticker: DygraphTickers.numericTicks
	    }
	  }
	};

	exports['default'] = DEFAULT_ATTRS;
	module.exports = exports['default'];

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2011 Robert Konigsberg (konigsberg@google.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview The default interaction model for Dygraphs. This is kept out
	 * of dygraph.js for better navigability.
	 * @author Robert Konigsberg (konigsberg@google.com)
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	/**
	 * You can drag this many pixels past the edge of the chart and still have it
	 * be considered a zoom. This makes it easier to zoom to the exact edge of the
	 * chart, a fairly common operation.
	 */
	var DRAG_EDGE_MARGIN = 100;

	/**
	 * A collection of functions to facilitate build custom interaction models.
	 * @class
	 */
	var DygraphInteraction = {};

	/**
	 * Checks whether the beginning & ending of an event were close enough that it
	 * should be considered a click. If it should, dispatch appropriate events.
	 * Returns true if the event was treated as a click.
	 *
	 * @param {Event} event
	 * @param {Dygraph} g
	 * @param {Object} context
	 */
	DygraphInteraction.maybeTreatMouseOpAsClick = function (event, g, context) {
	  context.dragEndX = utils.dragGetX_(event, context);
	  context.dragEndY = utils.dragGetY_(event, context);
	  var regionWidth = Math.abs(context.dragEndX - context.dragStartX);
	  var regionHeight = Math.abs(context.dragEndY - context.dragStartY);

	  if (regionWidth < 2 && regionHeight < 2 && g.lastx_ !== undefined && g.lastx_ != -1) {
	    DygraphInteraction.treatMouseOpAsClick(g, event, context);
	  }

	  context.regionWidth = regionWidth;
	  context.regionHeight = regionHeight;
	};

	/**
	 * Called in response to an interaction model operation that
	 * should start the default panning behavior.
	 *
	 * It's used in the default callback for "mousedown" operations.
	 * Custom interaction model builders can use it to provide the default
	 * panning behavior.
	 *
	 * @param {Event} event the event object which led to the startPan call.
	 * @param {Dygraph} g The dygraph on which to act.
	 * @param {Object} context The dragging context object (with
	 *     dragStartX/dragStartY/etc. properties). This function modifies the
	 *     context.
	 */
	DygraphInteraction.startPan = function (event, g, context) {
	  var i, axis;
	  context.isPanning = true;
	  var xRange = g.xAxisRange();

	  if (g.getOptionForAxis("logscale", "x")) {
	    context.initialLeftmostDate = utils.log10(xRange[0]);
	    context.dateRange = utils.log10(xRange[1]) - utils.log10(xRange[0]);
	  } else {
	    context.initialLeftmostDate = xRange[0];
	    context.dateRange = xRange[1] - xRange[0];
	  }
	  context.xUnitsPerPixel = context.dateRange / (g.plotter_.area.w - 1);

	  if (g.getNumericOption("panEdgeFraction")) {
	    var maxXPixelsToDraw = g.width_ * g.getNumericOption("panEdgeFraction");
	    var xExtremes = g.xAxisExtremes(); // I REALLY WANT TO CALL THIS xTremes!

	    var boundedLeftX = g.toDomXCoord(xExtremes[0]) - maxXPixelsToDraw;
	    var boundedRightX = g.toDomXCoord(xExtremes[1]) + maxXPixelsToDraw;

	    var boundedLeftDate = g.toDataXCoord(boundedLeftX);
	    var boundedRightDate = g.toDataXCoord(boundedRightX);
	    context.boundedDates = [boundedLeftDate, boundedRightDate];

	    var boundedValues = [];
	    var maxYPixelsToDraw = g.height_ * g.getNumericOption("panEdgeFraction");

	    for (i = 0; i < g.axes_.length; i++) {
	      axis = g.axes_[i];
	      var yExtremes = axis.extremeRange;

	      var boundedTopY = g.toDomYCoord(yExtremes[0], i) + maxYPixelsToDraw;
	      var boundedBottomY = g.toDomYCoord(yExtremes[1], i) - maxYPixelsToDraw;

	      var boundedTopValue = g.toDataYCoord(boundedTopY, i);
	      var boundedBottomValue = g.toDataYCoord(boundedBottomY, i);

	      boundedValues[i] = [boundedTopValue, boundedBottomValue];
	    }
	    context.boundedValues = boundedValues;
	  }

	  // Record the range of each y-axis at the start of the drag.
	  // If any axis has a valueRange, then we want a 2D pan.
	  // We can't store data directly in g.axes_, because it does not belong to us
	  // and could change out from under us during a pan (say if there's a data
	  // update).
	  context.is2DPan = false;
	  context.axes = [];
	  for (i = 0; i < g.axes_.length; i++) {
	    axis = g.axes_[i];
	    var axis_data = {};
	    var yRange = g.yAxisRange(i);
	    // TODO(konigsberg): These values should be in |context|.
	    // In log scale, initialTopValue, dragValueRange and unitsPerPixel are log scale.
	    var logscale = g.attributes_.getForAxis("logscale", i);
	    if (logscale) {
	      axis_data.initialTopValue = utils.log10(yRange[1]);
	      axis_data.dragValueRange = utils.log10(yRange[1]) - utils.log10(yRange[0]);
	    } else {
	      axis_data.initialTopValue = yRange[1];
	      axis_data.dragValueRange = yRange[1] - yRange[0];
	    }
	    axis_data.unitsPerPixel = axis_data.dragValueRange / (g.plotter_.area.h - 1);
	    context.axes.push(axis_data);

	    // While calculating axes, set 2dpan.
	    if (axis.valueRange) context.is2DPan = true;
	  }
	};

	/**
	 * Called in response to an interaction model operation that
	 * responds to an event that pans the view.
	 *
	 * It's used in the default callback for "mousemove" operations.
	 * Custom interaction model builders can use it to provide the default
	 * panning behavior.
	 *
	 * @param {Event} event the event object which led to the movePan call.
	 * @param {Dygraph} g The dygraph on which to act.
	 * @param {Object} context The dragging context object (with
	 *     dragStartX/dragStartY/etc. properties). This function modifies the
	 *     context.
	 */
	DygraphInteraction.movePan = function (event, g, context) {
	  context.dragEndX = utils.dragGetX_(event, context);
	  context.dragEndY = utils.dragGetY_(event, context);

	  var minDate = context.initialLeftmostDate - (context.dragEndX - context.dragStartX) * context.xUnitsPerPixel;
	  if (context.boundedDates) {
	    minDate = Math.max(minDate, context.boundedDates[0]);
	  }
	  var maxDate = minDate + context.dateRange;
	  if (context.boundedDates) {
	    if (maxDate > context.boundedDates[1]) {
	      // Adjust minDate, and recompute maxDate.
	      minDate = minDate - (maxDate - context.boundedDates[1]);
	      maxDate = minDate + context.dateRange;
	    }
	  }

	  if (g.getOptionForAxis("logscale", "x")) {
	    g.dateWindow_ = [Math.pow(utils.LOG_SCALE, minDate), Math.pow(utils.LOG_SCALE, maxDate)];
	  } else {
	    g.dateWindow_ = [minDate, maxDate];
	  }

	  // y-axis scaling is automatic unless this is a full 2D pan.
	  if (context.is2DPan) {

	    var pixelsDragged = context.dragEndY - context.dragStartY;

	    // Adjust each axis appropriately.
	    for (var i = 0; i < g.axes_.length; i++) {
	      var axis = g.axes_[i];
	      var axis_data = context.axes[i];
	      var unitsDragged = pixelsDragged * axis_data.unitsPerPixel;

	      var boundedValue = context.boundedValues ? context.boundedValues[i] : null;

	      // In log scale, maxValue and minValue are the logs of those values.
	      var maxValue = axis_data.initialTopValue + unitsDragged;
	      if (boundedValue) {
	        maxValue = Math.min(maxValue, boundedValue[1]);
	      }
	      var minValue = maxValue - axis_data.dragValueRange;
	      if (boundedValue) {
	        if (minValue < boundedValue[0]) {
	          // Adjust maxValue, and recompute minValue.
	          maxValue = maxValue - (minValue - boundedValue[0]);
	          minValue = maxValue - axis_data.dragValueRange;
	        }
	      }
	      if (g.attributes_.getForAxis("logscale", i)) {
	        axis.valueRange = [Math.pow(utils.LOG_SCALE, minValue), Math.pow(utils.LOG_SCALE, maxValue)];
	      } else {
	        axis.valueRange = [minValue, maxValue];
	      }
	    }
	  }

	  g.drawGraph_(false);
	};

	/**
	 * Called in response to an interaction model operation that
	 * responds to an event that ends panning.
	 *
	 * It's used in the default callback for "mouseup" operations.
	 * Custom interaction model builders can use it to provide the default
	 * panning behavior.
	 *
	 * @param {Event} event the event object which led to the endPan call.
	 * @param {Dygraph} g The dygraph on which to act.
	 * @param {Object} context The dragging context object (with
	 *     dragStartX/dragStartY/etc. properties). This function modifies the
	 *     context.
	 */
	DygraphInteraction.endPan = DygraphInteraction.maybeTreatMouseOpAsClick;

	/**
	 * Called in response to an interaction model operation that
	 * responds to an event that starts zooming.
	 *
	 * It's used in the default callback for "mousedown" operations.
	 * Custom interaction model builders can use it to provide the default
	 * zooming behavior.
	 *
	 * @param {Event} event the event object which led to the startZoom call.
	 * @param {Dygraph} g The dygraph on which to act.
	 * @param {Object} context The dragging context object (with
	 *     dragStartX/dragStartY/etc. properties). This function modifies the
	 *     context.
	 */
	DygraphInteraction.startZoom = function (event, g, context) {
	  context.isZooming = true;
	  context.zoomMoved = false;
	};

	/**
	 * Called in response to an interaction model operation that
	 * responds to an event that defines zoom boundaries.
	 *
	 * It's used in the default callback for "mousemove" operations.
	 * Custom interaction model builders can use it to provide the default
	 * zooming behavior.
	 *
	 * @param {Event} event the event object which led to the moveZoom call.
	 * @param {Dygraph} g The dygraph on which to act.
	 * @param {Object} context The dragging context object (with
	 *     dragStartX/dragStartY/etc. properties). This function modifies the
	 *     context.
	 */
	DygraphInteraction.moveZoom = function (event, g, context) {
	  context.zoomMoved = true;
	  context.dragEndX = utils.dragGetX_(event, context);
	  context.dragEndY = utils.dragGetY_(event, context);

	  var xDelta = Math.abs(context.dragStartX - context.dragEndX);
	  var yDelta = Math.abs(context.dragStartY - context.dragEndY);

	  // drag direction threshold for y axis is twice as large as x axis
	  context.dragDirection = xDelta < yDelta / 2 ? utils.VERTICAL : utils.HORIZONTAL;

	  g.drawZoomRect_(context.dragDirection, context.dragStartX, context.dragEndX, context.dragStartY, context.dragEndY, context.prevDragDirection, context.prevEndX, context.prevEndY);

	  context.prevEndX = context.dragEndX;
	  context.prevEndY = context.dragEndY;
	  context.prevDragDirection = context.dragDirection;
	};

	/**
	 * TODO(danvk): move this logic into dygraph.js
	 * @param {Dygraph} g
	 * @param {Event} event
	 * @param {Object} context
	 */
	DygraphInteraction.treatMouseOpAsClick = function (g, event, context) {
	  var clickCallback = g.getFunctionOption('clickCallback');
	  var pointClickCallback = g.getFunctionOption('pointClickCallback');

	  var selectedPoint = null;

	  // Find out if the click occurs on a point.
	  var closestIdx = -1;
	  var closestDistance = Number.MAX_VALUE;

	  // check if the click was on a particular point.
	  for (var i = 0; i < g.selPoints_.length; i++) {
	    var p = g.selPoints_[i];
	    var distance = Math.pow(p.canvasx - context.dragEndX, 2) + Math.pow(p.canvasy - context.dragEndY, 2);
	    if (!isNaN(distance) && (closestIdx == -1 || distance < closestDistance)) {
	      closestDistance = distance;
	      closestIdx = i;
	    }
	  }

	  // Allow any click within two pixels of the dot.
	  var radius = g.getNumericOption('highlightCircleSize') + 2;
	  if (closestDistance <= radius * radius) {
	    selectedPoint = g.selPoints_[closestIdx];
	  }

	  if (selectedPoint) {
	    var e = {
	      cancelable: true,
	      point: selectedPoint,
	      canvasx: context.dragEndX,
	      canvasy: context.dragEndY
	    };
	    var defaultPrevented = g.cascadeEvents_('pointClick', e);
	    if (defaultPrevented) {
	      // Note: this also prevents click / clickCallback from firing.
	      return;
	    }
	    if (pointClickCallback) {
	      pointClickCallback.call(g, event, selectedPoint);
	    }
	  }

	  var e = {
	    cancelable: true,
	    xval: g.lastx_, // closest point by x value
	    pts: g.selPoints_,
	    canvasx: context.dragEndX,
	    canvasy: context.dragEndY
	  };
	  if (!g.cascadeEvents_('click', e)) {
	    if (clickCallback) {
	      // TODO(danvk): pass along more info about the points, e.g. 'x'
	      clickCallback.call(g, event, g.lastx_, g.selPoints_);
	    }
	  }
	};

	/**
	 * Called in response to an interaction model operation that
	 * responds to an event that performs a zoom based on previously defined
	 * bounds..
	 *
	 * It's used in the default callback for "mouseup" operations.
	 * Custom interaction model builders can use it to provide the default
	 * zooming behavior.
	 *
	 * @param {Event} event the event object which led to the endZoom call.
	 * @param {Dygraph} g The dygraph on which to end the zoom.
	 * @param {Object} context The dragging context object (with
	 *     dragStartX/dragStartY/etc. properties). This function modifies the
	 *     context.
	 */
	DygraphInteraction.endZoom = function (event, g, context) {
	  g.clearZoomRect_();
	  context.isZooming = false;
	  DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);

	  // The zoom rectangle is visibly clipped to the plot area, so its behavior
	  // should be as well.
	  // See http://code.google.com/p/dygraphs/issues/detail?id=280
	  var plotArea = g.getArea();
	  if (context.regionWidth >= 10 && context.dragDirection == utils.HORIZONTAL) {
	    var left = Math.min(context.dragStartX, context.dragEndX),
	        right = Math.max(context.dragStartX, context.dragEndX);
	    left = Math.max(left, plotArea.x);
	    right = Math.min(right, plotArea.x + plotArea.w);
	    if (left < right) {
	      g.doZoomX_(left, right);
	    }
	    context.cancelNextDblclick = true;
	  } else if (context.regionHeight >= 10 && context.dragDirection == utils.VERTICAL) {
	    var top = Math.min(context.dragStartY, context.dragEndY),
	        bottom = Math.max(context.dragStartY, context.dragEndY);
	    top = Math.max(top, plotArea.y);
	    bottom = Math.min(bottom, plotArea.y + plotArea.h);
	    if (top < bottom) {
	      g.doZoomY_(top, bottom);
	    }
	    context.cancelNextDblclick = true;
	  }
	  context.dragStartX = null;
	  context.dragStartY = null;
	};

	/**
	 * @private
	 */
	DygraphInteraction.startTouch = function (event, g, context) {
	  event.preventDefault(); // touch browsers are all nice.
	  if (event.touches.length > 1) {
	    // If the user ever puts two fingers down, it's not a double tap.
	    context.startTimeForDoubleTapMs = null;
	  }

	  var touches = [];
	  for (var i = 0; i < event.touches.length; i++) {
	    var t = event.touches[i];
	    // we dispense with 'dragGetX_' because all touchBrowsers support pageX
	    touches.push({
	      pageX: t.pageX,
	      pageY: t.pageY,
	      dataX: g.toDataXCoord(t.pageX),
	      dataY: g.toDataYCoord(t.pageY)
	      // identifier: t.identifier
	    });
	  }
	  context.initialTouches = touches;

	  if (touches.length == 1) {
	    // This is just a swipe.
	    context.initialPinchCenter = touches[0];
	    context.touchDirections = { x: true, y: true };
	  } else if (touches.length >= 2) {
	    // It's become a pinch!
	    // In case there are 3+ touches, we ignore all but the "first" two.

	    // only screen coordinates can be averaged (data coords could be log scale).
	    context.initialPinchCenter = {
	      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),
	      pageY: 0.5 * (touches[0].pageY + touches[1].pageY),

	      // TODO(danvk): remove
	      dataX: 0.5 * (touches[0].dataX + touches[1].dataX),
	      dataY: 0.5 * (touches[0].dataY + touches[1].dataY)
	    };

	    // Make pinches in a 45-degree swath around either axis 1-dimensional zooms.
	    var initialAngle = 180 / Math.PI * Math.atan2(context.initialPinchCenter.pageY - touches[0].pageY, touches[0].pageX - context.initialPinchCenter.pageX);

	    // use symmetry to get it into the first quadrant.
	    initialAngle = Math.abs(initialAngle);
	    if (initialAngle > 90) initialAngle = 90 - initialAngle;

	    context.touchDirections = {
	      x: initialAngle < 90 - 45 / 2,
	      y: initialAngle > 45 / 2
	    };
	  }

	  // save the full x & y ranges.
	  context.initialRange = {
	    x: g.xAxisRange(),
	    y: g.yAxisRange()
	  };
	};

	/**
	 * @private
	 */
	DygraphInteraction.moveTouch = function (event, g, context) {
	  // If the tap moves, then it's definitely not part of a double-tap.
	  context.startTimeForDoubleTapMs = null;

	  var i,
	      touches = [];
	  for (i = 0; i < event.touches.length; i++) {
	    var t = event.touches[i];
	    touches.push({
	      pageX: t.pageX,
	      pageY: t.pageY
	    });
	  }
	  var initialTouches = context.initialTouches;

	  var c_now;

	  // old and new centers.
	  var c_init = context.initialPinchCenter;
	  if (touches.length == 1) {
	    c_now = touches[0];
	  } else {
	    c_now = {
	      pageX: 0.5 * (touches[0].pageX + touches[1].pageX),
	      pageY: 0.5 * (touches[0].pageY + touches[1].pageY)
	    };
	  }

	  // this is the "swipe" component
	  // we toss it out for now, but could use it in the future.
	  var swipe = {
	    pageX: c_now.pageX - c_init.pageX,
	    pageY: c_now.pageY - c_init.pageY
	  };
	  var dataWidth = context.initialRange.x[1] - context.initialRange.x[0];
	  var dataHeight = context.initialRange.y[0] - context.initialRange.y[1];
	  swipe.dataX = swipe.pageX / g.plotter_.area.w * dataWidth;
	  swipe.dataY = swipe.pageY / g.plotter_.area.h * dataHeight;
	  var xScale, yScale;

	  // The residual bits are usually split into scale & rotate bits, but we split
	  // them into x-scale and y-scale bits.
	  if (touches.length == 1) {
	    xScale = 1.0;
	    yScale = 1.0;
	  } else if (touches.length >= 2) {
	    var initHalfWidth = initialTouches[1].pageX - c_init.pageX;
	    xScale = (touches[1].pageX - c_now.pageX) / initHalfWidth;

	    var initHalfHeight = initialTouches[1].pageY - c_init.pageY;
	    yScale = (touches[1].pageY - c_now.pageY) / initHalfHeight;
	  }

	  // Clip scaling to [1/8, 8] to prevent too much blowup.
	  xScale = Math.min(8, Math.max(0.125, xScale));
	  yScale = Math.min(8, Math.max(0.125, yScale));

	  var didZoom = false;
	  if (context.touchDirections.x) {
	    g.dateWindow_ = [c_init.dataX - swipe.dataX + (context.initialRange.x[0] - c_init.dataX) / xScale, c_init.dataX - swipe.dataX + (context.initialRange.x[1] - c_init.dataX) / xScale];
	    didZoom = true;
	  }

	  if (context.touchDirections.y) {
	    for (i = 0; i < 1 /*g.axes_.length*/; i++) {
	      var axis = g.axes_[i];
	      var logscale = g.attributes_.getForAxis("logscale", i);
	      if (logscale) {
	        // TODO(danvk): implement
	      } else {
	          axis.valueRange = [c_init.dataY - swipe.dataY + (context.initialRange.y[0] - c_init.dataY) / yScale, c_init.dataY - swipe.dataY + (context.initialRange.y[1] - c_init.dataY) / yScale];
	          didZoom = true;
	        }
	    }
	  }

	  g.drawGraph_(false);

	  // We only call zoomCallback on zooms, not pans, to mirror desktop behavior.
	  if (didZoom && touches.length > 1 && g.getFunctionOption('zoomCallback')) {
	    var viewWindow = g.xAxisRange();
	    g.getFunctionOption("zoomCallback").call(g, viewWindow[0], viewWindow[1], g.yAxisRanges());
	  }
	};

	/**
	 * @private
	 */
	DygraphInteraction.endTouch = function (event, g, context) {
	  if (event.touches.length !== 0) {
	    // this is effectively a "reset"
	    DygraphInteraction.startTouch(event, g, context);
	  } else if (event.changedTouches.length == 1) {
	    // Could be part of a "double tap"
	    // The heuristic here is that it's a double-tap if the two touchend events
	    // occur within 500ms and within a 50x50 pixel box.
	    var now = new Date().getTime();
	    var t = event.changedTouches[0];
	    if (context.startTimeForDoubleTapMs && now - context.startTimeForDoubleTapMs < 500 && context.doubleTapX && Math.abs(context.doubleTapX - t.screenX) < 50 && context.doubleTapY && Math.abs(context.doubleTapY - t.screenY) < 50) {
	      g.resetZoom();
	    } else {
	      context.startTimeForDoubleTapMs = now;
	      context.doubleTapX = t.screenX;
	      context.doubleTapY = t.screenY;
	    }
	  }
	};

	// Determine the distance from x to [left, right].
	var distanceFromInterval = function distanceFromInterval(x, left, right) {
	  if (x < left) {
	    return left - x;
	  } else if (x > right) {
	    return x - right;
	  } else {
	    return 0;
	  }
	};

	/**
	 * Returns the number of pixels by which the event happens from the nearest
	 * edge of the chart. For events in the interior of the chart, this returns zero.
	 */
	var distanceFromChart = function distanceFromChart(event, g) {
	  var chartPos = utils.findPos(g.canvas_);
	  var box = {
	    left: chartPos.x,
	    right: chartPos.x + g.canvas_.offsetWidth,
	    top: chartPos.y,
	    bottom: chartPos.y + g.canvas_.offsetHeight
	  };

	  var pt = {
	    x: utils.pageX(event),
	    y: utils.pageY(event)
	  };

	  var dx = distanceFromInterval(pt.x, box.left, box.right),
	      dy = distanceFromInterval(pt.y, box.top, box.bottom);
	  return Math.max(dx, dy);
	};

	/**
	 * Default interation model for dygraphs. You can refer to specific elements of
	 * this when constructing your own interaction model, e.g.:
	 * g.updateOptions( {
	 *   interactionModel: {
	 *     mousedown: DygraphInteraction.defaultInteractionModel.mousedown
	 *   }
	 * } );
	 */
	DygraphInteraction.defaultModel = {
	  // Track the beginning of drag events
	  mousedown: function mousedown(event, g, context) {
	    // Right-click should not initiate a zoom.
	    if (event.button && event.button == 2) return;

	    context.initializeMouseDown(event, g, context);

	    if (event.altKey || event.shiftKey) {
	      DygraphInteraction.startPan(event, g, context);
	    } else {
	      DygraphInteraction.startZoom(event, g, context);
	    }

	    // Note: we register mousemove/mouseup on document to allow some leeway for
	    // events to move outside of the chart. Interaction model events get
	    // registered on the canvas, which is too small to allow this.
	    var mousemove = function mousemove(event) {
	      if (context.isZooming) {
	        // When the mouse moves >200px from the chart edge, cancel the zoom.
	        var d = distanceFromChart(event, g);
	        if (d < DRAG_EDGE_MARGIN) {
	          DygraphInteraction.moveZoom(event, g, context);
	        } else {
	          if (context.dragEndX !== null) {
	            context.dragEndX = null;
	            context.dragEndY = null;
	            g.clearZoomRect_();
	          }
	        }
	      } else if (context.isPanning) {
	        DygraphInteraction.movePan(event, g, context);
	      }
	    };
	    var mouseup = function mouseup(event) {
	      if (context.isZooming) {
	        if (context.dragEndX !== null) {
	          DygraphInteraction.endZoom(event, g, context);
	        } else {
	          DygraphInteraction.maybeTreatMouseOpAsClick(event, g, context);
	        }
	      } else if (context.isPanning) {
	        DygraphInteraction.endPan(event, g, context);
	      }

	      utils.removeEvent(document, 'mousemove', mousemove);
	      utils.removeEvent(document, 'mouseup', mouseup);
	      context.destroy();
	    };

	    g.addAndTrackEvent(document, 'mousemove', mousemove);
	    g.addAndTrackEvent(document, 'mouseup', mouseup);
	  },
	  willDestroyContextMyself: true,

	  touchstart: function touchstart(event, g, context) {
	    DygraphInteraction.startTouch(event, g, context);
	  },
	  touchmove: function touchmove(event, g, context) {
	    DygraphInteraction.moveTouch(event, g, context);
	  },
	  touchend: function touchend(event, g, context) {
	    DygraphInteraction.endTouch(event, g, context);
	  },

	  // Disable zooming out if panning.
	  dblclick: function dblclick(event, g, context) {
	    if (context.cancelNextDblclick) {
	      context.cancelNextDblclick = false;
	      return;
	    }

	    // Give plugins a chance to grab this event.
	    var e = {
	      canvasx: context.dragEndX,
	      canvasy: context.dragEndY
	    };
	    if (g.cascadeEvents_('dblclick', e)) {
	      return;
	    }

	    if (event.altKey || event.shiftKey) {
	      return;
	    }
	    g.resetZoom();
	  }
	};

	/*
	Dygraph.DEFAULT_ATTRS.interactionModel = DygraphInteraction.defaultModel;

	// old ways of accessing these methods/properties
	Dygraph.defaultInteractionModel = DygraphInteraction.defaultModel;
	Dygraph.endZoom = DygraphInteraction.endZoom;
	Dygraph.moveZoom = DygraphInteraction.moveZoom;
	Dygraph.startZoom = DygraphInteraction.startZoom;
	Dygraph.endPan = DygraphInteraction.endPan;
	Dygraph.movePan = DygraphInteraction.movePan;
	Dygraph.startPan = DygraphInteraction.startPan;
	*/

	DygraphInteraction.nonInteractiveModel_ = {
	  mousedown: function mousedown(event, g, context) {
	    context.initializeMouseDown(event, g, context);
	  },
	  mouseup: DygraphInteraction.maybeTreatMouseOpAsClick
	};

	// Default interaction model when using the range selector.
	DygraphInteraction.dragIsPanInteractionModel = {
	  mousedown: function mousedown(event, g, context) {
	    context.initializeMouseDown(event, g, context);
	    DygraphInteraction.startPan(event, g, context);
	  },
	  mousemove: function mousemove(event, g, context) {
	    if (context.isPanning) {
	      DygraphInteraction.movePan(event, g, context);
	    }
	  },
	  mouseup: function mouseup(event, g, context) {
	    if (context.isPanning) {
	      DygraphInteraction.endPan(event, g, context);
	    }
	  }
	};

	exports["default"] = DygraphInteraction;
	module.exports = exports["default"];

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * @license
	 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var OPTIONS_REFERENCE = null;

	// For "production" code, this gets removed by uglifyjs.
	if (typeof process !== 'undefined') {
	  if (process.env.NODE_ENV != 'production') {

	    // NOTE: in addition to parsing as JS, this snippet is expected to be valid
	    // JSON. This assumption cannot be checked in JS, but it will be checked when
	    // documentation is generated by the generate-documentation.py script. For the
	    // most part, this just means that you should always use double quotes.
	    OPTIONS_REFERENCE = // <JSON>
	    {
	      "xValueParser": {
	        "default": "parseFloat() or Date.parse()*",
	        "labels": ["CSV parsing"],
	        "type": "function(str) -> number",
	        "description": "A function which parses x-values (i.e. the dependent series). Must return a number, even when the values are dates. In this case, millis since epoch are used. This is used primarily for parsing CSV data. *=Dygraphs is slightly more accepting in the dates which it will parse. See code for details."
	      },
	      "stackedGraph": {
	        "default": "false",
	        "labels": ["Data Line display"],
	        "type": "boolean",
	        "description": "If set, stack series on top of one another rather than drawing them independently. The first series specified in the input data will wind up on top of the chart and the last will be on bottom. NaN values are drawn as white areas without a line on top, see stackedGraphNaNFill for details."
	      },
	      "stackedGraphNaNFill": {
	        "default": "all",
	        "labels": ["Data Line display"],
	        "type": "string",
	        "description": "Controls handling of NaN values inside a stacked graph. NaN values are interpolated/extended for stacking purposes, but the actual point value remains NaN in the legend display. Valid option values are \"all\" (interpolate internally, repeat leftmost and rightmost value as needed), \"inside\" (interpolate internally only, use zero outside leftmost and rightmost value), and \"none\" (treat NaN as zero everywhere)."
	      },
	      "pointSize": {
	        "default": "1",
	        "labels": ["Data Line display"],
	        "type": "integer",
	        "description": "The size of the dot to draw on each point in pixels (see drawPoints). A dot is always drawn when a point is \"isolated\", i.e. there is a missing point on either side of it. This also controls the size of those dots."
	      },
	      "drawPoints": {
	        "default": "false",
	        "labels": ["Data Line display"],
	        "type": "boolean",
	        "description": "Draw a small dot at each point, in addition to a line going through the point. This makes the individual data points easier to see, but can increase visual clutter in the chart. The small dot can be replaced with a custom rendering by supplying a <a href='#drawPointCallback'>drawPointCallback</a>."
	      },
	      "drawGapEdgePoints": {
	        "default": "false",
	        "labels": ["Data Line display"],
	        "type": "boolean",
	        "description": "Draw points at the edges of gaps in the data. This improves visibility of small data segments or other data irregularities."
	      },
	      "drawPointCallback": {
	        "default": "null",
	        "labels": ["Data Line display"],
	        "type": "function(g, seriesName, canvasContext, cx, cy, color, pointSize)",
	        "parameters": [["g", "the reference graph"], ["seriesName", "the name of the series"], ["canvasContext", "the canvas to draw on"], ["cx", "center x coordinate"], ["cy", "center y coordinate"], ["color", "series color"], ["pointSize", "the radius of the image."], ["idx", "the row-index of the point in the data."]],
	        "description": "Draw a custom item when drawPoints is enabled. Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy).  Also see <a href='#drawHighlightPointCallback'>drawHighlightPointCallback</a>"
	      },
	      "height": {
	        "default": "320",
	        "labels": ["Overall display"],
	        "type": "integer",
	        "description": "Height, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored."
	      },
	      "zoomCallback": {
	        "default": "null",
	        "labels": ["Callbacks"],
	        "type": "function(minDate, maxDate, yRanges)",
	        "parameters": [["minDate", "milliseconds since epoch"], ["maxDate", "milliseconds since epoch."], ["yRanges", "is an array of [bottom, top] pairs, one for each y-axis."]],
	        "description": "A function to call when the zoom window is changed (either by zooming in or out). When animatedZooms is set, zoomCallback is called once at the end of the transition (it will not be called for intermediate frames)."
	      },
	      "pointClickCallback": {
	        "snippet": "function(e, point){<br>&nbsp;&nbsp;alert(point);<br>}",
	        "default": "null",
	        "labels": ["Callbacks", "Interactive Elements"],
	        "type": "function(e, point)",
	        "parameters": [["e", "the event object for the click"], ["point", "the point that was clicked See <a href='#point_properties'>Point properties</a> for details"]],
	        "description": "A function to call when a data point is clicked. and the point that was clicked."
	      },
	      "color": {
	        "default": "(see description)",
	        "labels": ["Data Series Colors"],
	        "type": "string",
	        "example": "red",
	        "description": "A per-series color definition. Used in conjunction with, and overrides, the colors option."
	      },
	      "colors": {
	        "default": "(see description)",
	        "labels": ["Data Series Colors"],
	        "type": "array<string>",
	        "example": "['red', '#00FF00']",
	        "description": "List of colors for the data series. These can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\", etc. If not specified, equally-spaced points around a color wheel are used. Overridden by the 'color' option."
	      },
	      "connectSeparatedPoints": {
	        "default": "false",
	        "labels": ["Data Line display"],
	        "type": "boolean",
	        "description": "Usually, when Dygraphs encounters a missing value in a data series, it interprets this as a gap and draws it as such. If, instead, the missing values represents an x-value for which only a different series has data, then you'll want to connect the dots by setting this to true. To explicitly include a gap with this option set, use a value of NaN."
	      },
	      "highlightCallback": {
	        "default": "null",
	        "labels": ["Callbacks"],
	        "type": "function(event, x, points, row, seriesName)",
	        "description": "When set, this callback gets called every time a new point is highlighted.",
	        "parameters": [["event", "the JavaScript mousemove event"], ["x", "the x-coordinate of the highlighted points"], ["points", "an array of highlighted points: <code>[ {name: 'series', yval: y-value}, &hellip; ]</code>"], ["row", "integer index of the highlighted row in the data table, starting from 0"], ["seriesName", "name of the highlighted series, only present if highlightSeriesOpts is set."]]
	      },
	      "drawHighlightPointCallback": {
	        "default": "null",
	        "labels": ["Data Line display"],
	        "type": "function(g, seriesName, canvasContext, cx, cy, color, pointSize)",
	        "parameters": [["g", "the reference graph"], ["seriesName", "the name of the series"], ["canvasContext", "the canvas to draw on"], ["cx", "center x coordinate"], ["cy", "center y coordinate"], ["color", "series color"], ["pointSize", "the radius of the image."], ["idx", "the row-index of the point in the data."]],
	        "description": "Draw a custom item when a point is highlighted.  Default is a small dot matching the series color. This method should constrain drawing to within pointSize pixels from (cx, cy) Also see <a href='#drawPointCallback'>drawPointCallback</a>"
	      },
	      "highlightSeriesOpts": {
	        "default": "null",
	        "labels": ["Interactive Elements"],
	        "type": "Object",
	        "description": "When set, the options from this object are applied to the timeseries closest to the mouse pointer for interactive highlighting. See also 'highlightCallback'. Example: highlightSeriesOpts: { strokeWidth: 3 }."
	      },
	      "highlightSeriesBackgroundAlpha": {
	        "default": "0.5",
	        "labels": ["Interactive Elements"],
	        "type": "float",
	        "description": "Fade the background while highlighting series. 1=fully visible background (disable fading), 0=hiddden background (show highlighted series only)."
	      },
	      "highlightSeriesBackgroundColor": {
	        "default": "rgb(255, 255, 255)",
	        "labels": ["Interactive Elements"],
	        "type": "string",
	        "description": "Sets the background color used to fade out the series in conjunction with 'highlightSeriesBackgroundAlpha'."
	      },
	      "includeZero": {
	        "default": "false",
	        "labels": ["Axis display"],
	        "type": "boolean",
	        "description": "Usually, dygraphs will use the range of the data plus some padding to set the range of the y-axis. If this option is set, the y-axis will always include zero, typically as the lowest value. This can be used to avoid exaggerating the variance in the data"
	      },
	      "rollPeriod": {
	        "default": "1",
	        "labels": ["Error Bars", "Rolling Averages"],
	        "type": "integer &gt;= 1",
	        "description": "Number of days over which to average data. Discussed extensively above."
	      },
	      "unhighlightCallback": {
	        "default": "null",
	        "labels": ["Callbacks"],
	        "type": "function(event)",
	        "parameters": [["event", "the mouse event"]],
	        "description": "When set, this callback gets called every time the user stops highlighting any point by mousing out of the graph."
	      },
	      "axisTickSize": {
	        "default": "3.0",
	        "labels": ["Axis display"],
	        "type": "number",
	        "description": "The size of the line to display next to each tick mark on x- or y-axes."
	      },
	      "labelsSeparateLines": {
	        "default": "false",
	        "labels": ["Legend"],
	        "type": "boolean",
	        "description": "Put <code>&lt;br/&gt;</code> between lines in the label string. Often used in conjunction with <strong>labelsDiv</strong>."
	      },
	      "valueFormatter": {
	        "default": "Depends on the type of your data.",
	        "labels": ["Legend", "Value display/formatting"],
	        "type": "function(num or millis, opts, seriesName, dygraph, row, col)",
	        "description": "Function to provide a custom display format for the values displayed on mouseover. This does not affect the values that appear on tick marks next to the axes. To format those, see axisLabelFormatter. This is usually set on a <a href='per-axis.html'>per-axis</a> basis. .",
	        "parameters": [["num_or_millis", "The value to be formatted. This is always a number. For date axes, it's millis since epoch. You can call new Date(millis) to get a Date object."], ["opts", "This is a function you can call to access various options (e.g. opts('labelsKMB')). It returns per-axis values for the option when available."], ["seriesName", "The name of the series from which the point came, e.g. 'X', 'Y', 'A', etc."], ["dygraph", "The dygraph object for which the formatting is being done"], ["row", "The row of the data from which this point comes. g.getValue(row, 0) will return the x-value for this point."], ["col", "The column of the data from which this point comes. g.getValue(row, col) will return the original y-value for this point. This can be used to get the full confidence interval for the point, or access un-rolled values for the point."]]
	      },
	      "annotationMouseOverHandler": {
	        "default": "null",
	        "labels": ["Annotations"],
	        "type": "function(annotation, point, dygraph, event)",
	        "description": "If provided, this function is called whenever the user mouses over an annotation."
	      },
	      "annotationMouseOutHandler": {
	        "default": "null",
	        "labels": ["Annotations"],
	        "type": "function(annotation, point, dygraph, event)",
	        "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
	        "description": "If provided, this function is called whenever the user mouses out of an annotation."
	      },
	      "annotationClickHandler": {
	        "default": "null",
	        "labels": ["Annotations"],
	        "type": "function(annotation, point, dygraph, event)",
	        "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
	        "description": "If provided, this function is called whenever the user clicks on an annotation."
	      },
	      "annotationDblClickHandler": {
	        "default": "null",
	        "labels": ["Annotations"],
	        "type": "function(annotation, point, dygraph, event)",
	        "parameters": [["annotation", "the annotation left"], ["point", "the point associated with the annotation"], ["dygraph", "the reference graph"], ["event", "the mouse event"]],
	        "description": "If provided, this function is called whenever the user double-clicks on an annotation."
	      },
	      "drawCallback": {
	        "default": "null",
	        "labels": ["Callbacks"],
	        "type": "function(dygraph, is_initial)",
	        "parameters": [["dygraph", "The graph being drawn"], ["is_initial", "True if this is the initial draw, false for subsequent draws."]],
	        "description": "When set, this callback gets called every time the dygraph is drawn. This includes the initial draw, after zooming and repeatedly while panning."
	      },
	      "labelsKMG2": {
	        "default": "false",
	        "labels": ["Value display/formatting"],
	        "type": "boolean",
	        "description": "Show k/M/G for kilo/Mega/Giga on y-axis. This is different than <code>labelsKMB</code> in that it uses base 2, not 10."
	      },
	      "delimiter": {
	        "default": ",",
	        "labels": ["CSV parsing"],
	        "type": "string",
	        "description": "The delimiter to look for when separating fields of a CSV file. Setting this to a tab is not usually necessary, since tab-delimited data is auto-detected."
	      },
	      "axisLabelFontSize": {
	        "default": "14",
	        "labels": ["Axis display"],
	        "type": "integer",
	        "description": "Size of the font (in pixels) to use in the axis labels, both x- and y-axis."
	      },
	      "underlayCallback": {
	        "default": "null",
	        "labels": ["Callbacks"],
	        "type": "function(context, area, dygraph)",
	        "parameters": [["context", "the canvas drawing context on which to draw"], ["area", "An object with {x,y,w,h} properties describing the drawing area."], ["dygraph", "the reference graph"]],
	        "description": "When set, this callback gets called before the chart is drawn. It details on how to use this."
	      },
	      "width": {
	        "default": "480",
	        "labels": ["Overall display"],
	        "type": "integer",
	        "description": "Width, in pixels, of the chart. If the container div has been explicitly sized, this will be ignored."
	      },
	      "interactionModel": {
	        "default": "...",
	        "labels": ["Interactive Elements"],
	        "type": "Object",
	        "description": "TODO(konigsberg): document this"
	      },
	      "ticker": {
	        "default": "Dygraph.dateTicker or Dygraph.numericTicks",
	        "labels": ["Axis display"],
	        "type": "function(min, max, pixels, opts, dygraph, vals) -> [{v: ..., label: ...}, ...]",
	        "parameters": [["min", ""], ["max", ""], ["pixels", ""], ["opts", ""], ["dygraph", "the reference graph"], ["vals", ""]],
	        "description": "This lets you specify an arbitrary function to generate tick marks on an axis. The tick marks are an array of (value, label) pairs. The built-in functions go to great lengths to choose good tick marks so, if you set this option, you'll most likely want to call one of them and modify the result. See dygraph-tickers.js for an extensive discussion. This is set on a <a href='per-axis.html'>per-axis</a> basis."
	      },
	      "xAxisHeight": {
	        "default": "(null)",
	        "labels": ["Axis display"],
	        "type": "integer",
	        "description": "Height, in pixels, of the x-axis. If not set explicitly, this is computed based on axisLabelFontSize and axisTickSize."
	      },
	      "showLabelsOnHighlight": {
	        "default": "true",
	        "labels": ["Interactive Elements", "Legend"],
	        "type": "boolean",
	        "description": "Whether to show the legend upon mouseover."
	      },
	      "axis": {
	        "default": "(none)",
	        "labels": ["Axis display"],
	        "type": "string",
	        "description": "Set to either 'y1' or 'y2' to assign a series to a y-axis (primary or secondary). Must be set per-series."
	      },
	      "pixelsPerLabel": {
	        "default": "70 (x-axis) or 30 (y-axes)",
	        "labels": ["Axis display", "Grid"],
	        "type": "integer",
	        "description": "Number of pixels to require between each x- and y-label. Larger values will yield a sparser axis with fewer ticks. This is set on a <a href='per-axis.html'>per-axis</a> basis."
	      },
	      "labelsDiv": {
	        "default": "null",
	        "labels": ["Legend"],
	        "type": "DOM element or string",
	        "example": "<code style='font-size: small'>document.getElementById('foo')</code>or<code>'foo'",
	        "description": "Show data labels in an external div, rather than on the graph.  This value can either be a div element or a div id."
	      },
	      "fractions": {
	        "default": "false",
	        "labels": ["CSV parsing", "Error Bars"],
	        "type": "boolean",
	        "description": "When set, attempt to parse each cell in the CSV file as \"a/b\", where a and b are integers. The ratio will be plotted. This allows computation of Wilson confidence intervals (see below)."
	      },
	      "logscale": {
	        "default": "false",
	        "labels": ["Axis display"],
	        "type": "boolean",
	        "description": "When set for the y-axis or x-axis, the graph shows that axis in log scale. Any values less than or equal to zero are not displayed. Showing log scale with ranges that go below zero will result in an unviewable graph.\n\n Not compatible with showZero. connectSeparatedPoints is ignored. This is ignored for date-based x-axes."
	      },
	      "strokeWidth": {
	        "default": "1.0",
	        "labels": ["Data Line display"],
	        "type": "float",
	        "example": "0.5, 2.0",
	        "description": "The width of the lines connecting data points. This can be used to increase the contrast or some graphs."
	      },
	      "strokePattern": {
	        "default": "null",
	        "labels": ["Data Line display"],
	        "type": "array<integer>",
	        "example": "[10, 2, 5, 2]",
	        "description": "A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed lines."
	      },
	      "strokeBorderWidth": {
	        "default": "null",
	        "labels": ["Data Line display"],
	        "type": "float",
	        "example": "1.0",
	        "description": "Draw a border around graph lines to make crossing lines more easily distinguishable. Useful for graphs with many lines."
	      },
	      "strokeBorderColor": {
	        "default": "white",
	        "labels": ["Data Line display"],
	        "type": "string",
	        "example": "red, #ccffdd",
	        "description": "Color for the line border used if strokeBorderWidth is set."
	      },
	      "wilsonInterval": {
	        "default": "true",
	        "labels": ["Error Bars"],
	        "type": "boolean",
	        "description": "Use in conjunction with the \"fractions\" option. Instead of plotting +/- N standard deviations, dygraphs will compute a Wilson confidence interval and plot that. This has more reasonable behavior for ratios close to 0 or 1."
	      },
	      "fillGraph": {
	        "default": "false",
	        "labels": ["Data Line display"],
	        "type": "boolean",
	        "description": "Should the area underneath the graph be filled? This option is not compatible with error bars. This may be set on a <a href='per-axis.html'>per-series</a> basis."
	      },
	      "highlightCircleSize": {
	        "default": "3",
	        "labels": ["Interactive Elements"],
	        "type": "integer",
	        "description": "The size in pixels of the dot drawn over highlighted points."
	      },
	      "gridLineColor": {
	        "default": "rgb(128,128,128)",
	        "labels": ["Grid"],
	        "type": "red, blue",
	        "description": "The color of the gridlines. This may be set on a per-axis basis to define each axis' grid separately."
	      },
	      "gridLinePattern": {
	        "default": "null",
	        "labels": ["Grid"],
	        "type": "array<integer>",
	        "example": "[10, 2, 5, 2]",
	        "description": "A custom pattern array where the even index is a draw and odd is a space in pixels. If null then it draws a solid line. The array should have a even length as any odd lengthed array could be expressed as a smaller even length array. This is used to create dashed gridlines."
	      },
	      "visibility": {
	        "default": "[true, true, ...]",
	        "labels": ["Data Line display"],
	        "type": "Array of booleans",
	        "description": "Which series should initially be visible? Once the Dygraph has been constructed, you can access and modify the visibility of each series using the <code>visibility</code> and <code>setVisibility</code> methods."
	      },
	      "valueRange": {
	        "default": "Full range of the input is shown",
	        "labels": ["Axis display"],
	        "type": "Array of two numbers",
	        "example": "[10, 110]",
	        "description": "Explicitly set the vertical range of the graph to [low, high]. This may be set on a per-axis basis to define each y-axis separately. If either limit is unspecified, it will be calculated automatically (e.g. [null, 30] to automatically calculate just the lower bound)"
	      },
	      "colorSaturation": {
	        "default": "1.0",
	        "labels": ["Data Series Colors"],
	        "type": "float (0.0 - 1.0)",
	        "description": "If <strong>colors</strong> is not specified, saturation of the automatically-generated data series colors."
	      },
	      "hideOverlayOnMouseOut": {
	        "default": "true",
	        "labels": ["Interactive Elements", "Legend"],
	        "type": "boolean",
	        "description": "Whether to hide the legend when the mouse leaves the chart area."
	      },
	      "legend": {
	        "default": "onmouseover",
	        "labels": ["Legend"],
	        "type": "string",
	        "description": "When to display the legend. By default, it only appears when a user mouses over the chart. Set it to \"always\" to always display a legend of some sort. When set to \"follow\", legend follows highlighted points."
	      },
	      "legendFormatter": {
	        "default": "null",
	        "labels": ["Legend"],
	        "type": "function(data): string",
	        "params": [["data", "An object containing information about the selection (or lack of a selection). This includes formatted values and series information. See <a href=\"https://github.com/danvk/dygraphs/pull/683\">here</a> for sample values."]],
	        "description": "Set this to supply a custom formatter for the legend. See <a href=\"https://github.com/danvk/dygraphs/pull/683\">this comment</a> and the <a href=\"tests/legend-formatter.html\">legendFormatter demo</a> for usage."
	      },
	      "labelsShowZeroValues": {
	        "default": "true",
	        "labels": ["Legend"],
	        "type": "boolean",
	        "description": "Show zero value labels in the labelsDiv."
	      },
	      "stepPlot": {
	        "default": "false",
	        "labels": ["Data Line display"],
	        "type": "boolean",
	        "description": "When set, display the graph as a step plot instead of a line plot. This option may either be set for the whole graph or for single series."
	      },
	      "labelsUTC": {
	        "default": "false",
	        "labels": ["Value display/formatting", "Axis display"],
	        "type": "boolean",
	        "description": "Show date/time labels according to UTC (instead of local time)."
	      },
	      "labelsKMB": {
	        "default": "false",
	        "labels": ["Value display/formatting"],
	        "type": "boolean",
	        "description": "Show K/M/B for thousands/millions/billions on y-axis."
	      },
	      "rightGap": {
	        "default": "5",
	        "labels": ["Overall display"],
	        "type": "integer",
	        "description": "Number of pixels to leave blank at the right edge of the Dygraph. This makes it easier to highlight the right-most data point."
	      },
	      "drawAxesAtZero": {
	        "default": "false",
	        "labels": ["Axis display"],
	        "type": "boolean",
	        "description": "When set, draw the X axis at the Y=0 position and the Y axis at the X=0 position if those positions are inside the graph's visible area. Otherwise, draw the axes at the bottom or left graph edge as usual."
	      },
	      "xRangePad": {
	        "default": "0",
	        "labels": ["Axis display"],
	        "type": "float",
	        "description": "Add the specified amount of extra space (in pixels) around the X-axis value range to ensure points at the edges remain visible."
	      },
	      "yRangePad": {
	        "default": "null",
	        "labels": ["Axis display"],
	        "type": "float",
	        "description": "If set, add the specified amount of extra space (in pixels) around the Y-axis value range to ensure points at the edges remain visible. If unset, use the traditional Y padding algorithm."
	      },
	      "axisLabelFormatter": {
	        "default": "Depends on the data type",
	        "labels": ["Axis display"],
	        "type": "function(number or Date, granularity, opts, dygraph)",
	        "parameters": [["number or date", "Either a number (for a numeric axis) or a Date object (for a date axis)"], ["granularity", "specifies how fine-grained the axis is. For date axes, this is a reference to the time granularity enumeration, defined in dygraph-tickers.js, e.g. Dygraph.WEEKLY."], ["opts", "a function which provides access to various options on the dygraph, e.g. opts('labelsKMB')."], ["dygraph", "the referenced graph"]],
	        "description": "Function to call to format the tick values that appear along an axis. This is usually set on a <a href='per-axis.html'>per-axis</a> basis."
	      },
	      "clickCallback": {
	        "snippet": "function(e, date_millis){<br>&nbsp;&nbsp;alert(new Date(date_millis));<br>}",
	        "default": "null",
	        "labels": ["Callbacks"],
	        "type": "function(e, x, points)",
	        "parameters": [["e", "The event object for the click"], ["x", "The x value that was clicked (for dates, this is milliseconds since epoch)"], ["points", "The closest points along that date. See <a href='#point_properties'>Point properties</a> for details."]],
	        "description": "A function to call when the canvas is clicked."
	      },
	      "labels": {
	        "default": "[\"X\", \"Y1\", \"Y2\", ...]*",
	        "labels": ["Legend"],
	        "type": "array<string>",
	        "description": "A name for each data series, including the independent (X) series. For CSV files and DataTable objections, this is determined by context. For raw data, this must be specified. If it is not, default values are supplied and a warning is logged."
	      },
	      "dateWindow": {
	        "default": "Full range of the input is shown",
	        "labels": ["Axis display"],
	        "type": "Array of two numbers",
	        "example": "[<br>&nbsp;&nbsp;Date.parse('2006-01-01'),<br>&nbsp;&nbsp;(new Date()).valueOf()<br>]",
	        "description": "Initially zoom in on a section of the graph. Is of the form [earliest, latest], where earliest/latest are milliseconds since epoch. If the data for the x-axis is numeric, the values in dateWindow must also be numbers."
	      },
	      "showRoller": {
	        "default": "false",
	        "labels": ["Interactive Elements", "Rolling Averages"],
	        "type": "boolean",
	        "description": "If the rolling average period text box should be shown."
	      },
	      "sigma": {
	        "default": "2.0",
	        "labels": ["Error Bars"],
	        "type": "float",
	        "description": "When errorBars is set, shade this many standard deviations above/below each point."
	      },
	      "customBars": {
	        "default": "false",
	        "labels": ["CSV parsing", "Error Bars"],
	        "type": "boolean",
	        "description": "When set, parse each CSV cell as \"low;middle;high\". Error bars will be drawn for each point between low and high, with the series itself going through middle."
	      },
	      "colorValue": {
	        "default": "1.0",
	        "labels": ["Data Series Colors"],
	        "type": "float (0.0 - 1.0)",
	        "description": "If colors is not specified, value of the data series colors, as in hue/saturation/value. (0.0-1.0, default 0.5)"
	      },
	      "errorBars": {
	        "default": "false",
	        "labels": ["CSV parsing", "Error Bars"],
	        "type": "boolean",
	        "description": "Does the data contain standard deviations? Setting this to true alters the input format (see above)."
	      },
	      "displayAnnotations": {
	        "default": "false",
	        "labels": ["Annotations"],
	        "type": "boolean",
	        "description": "Only applies when Dygraphs is used as a GViz chart. Causes string columns following a data series to be interpreted as annotations on points in that series. This is the same format used by Google's AnnotatedTimeLine chart."
	      },
	      "panEdgeFraction": {
	        "default": "null",
	        "labels": ["Axis display", "Interactive Elements"],
	        "type": "float",
	        "description": "A value representing the farthest a graph may be panned, in percent of the display. For example, a value of 0.1 means that the graph can only be panned 10% pased the edges of the displayed values. null means no bounds."
	      },
	      "title": {
	        "labels": ["Chart labels"],
	        "type": "string",
	        "default": "null",
	        "description": "Text to display above the chart. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-title' classes."
	      },
	      "titleHeight": {
	        "default": "18",
	        "labels": ["Chart labels"],
	        "type": "integer",
	        "description": "Height of the chart title, in pixels. This also controls the default font size of the title. If you style the title on your own, this controls how much space is set aside above the chart for the title's div."
	      },
	      "xlabel": {
	        "labels": ["Chart labels"],
	        "type": "string",
	        "default": "null",
	        "description": "Text to display below the chart's x-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-xlabel' classes."
	      },
	      "xLabelHeight": {
	        "labels": ["Chart labels"],
	        "type": "integer",
	        "default": "18",
	        "description": "Height of the x-axis label, in pixels. This also controls the default font size of the x-axis label. If you style the label on your own, this controls how much space is set aside below the chart for the x-axis label's div."
	      },
	      "ylabel": {
	        "labels": ["Chart labels"],
	        "type": "string",
	        "default": "null",
	        "description": "Text to display to the left of the chart's y-axis. You can supply any HTML for this value, not just text. If you wish to style it using CSS, use the 'dygraph-label' or 'dygraph-ylabel' classes. The text will be rotated 90 degrees by default, so CSS rules may behave in unintuitive ways. No additional space is set aside for a y-axis label. If you need more space, increase the width of the y-axis tick labels using the yAxisLabelWidth option. If you need a wider div for the y-axis label, either style it that way with CSS (but remember that it's rotated, so width is controlled by the 'height' property) or set the yLabelWidth option."
	      },
	      "y2label": {
	        "labels": ["Chart labels"],
	        "type": "string",
	        "default": "null",
	        "description": "Text to display to the right of the chart's secondary y-axis. This label is only displayed if a secondary y-axis is present. See <a href='http://dygraphs.com/tests/two-axes.html'>this test</a> for an example of how to do this. The comments for the 'ylabel' option generally apply here as well. This label gets a 'dygraph-y2label' instead of a 'dygraph-ylabel' class."
	      },
	      "yLabelWidth": {
	        "labels": ["Chart labels"],
	        "type": "integer",
	        "default": "18",
	        "description": "Width of the div which contains the y-axis label. Since the y-axis label appears rotated 90 degrees, this actually affects the height of its div."
	      },
	      "drawGrid": {
	        "default": "true for x and y, false for y2",
	        "labels": ["Grid"],
	        "type": "boolean",
	        "description": "Whether to display gridlines in the chart. This may be set on a per-axis basis to define the visibility of each axis' grid separately."
	      },
	      "independentTicks": {
	        "default": "true for y, false for y2",
	        "labels": ["Axis display", "Grid"],
	        "type": "boolean",
	        "description": "Only valid for y and y2, has no effect on x: This option defines whether the y axes should align their ticks or if they should be independent. Possible combinations: 1.) y=true, y2=false (default): y is the primary axis and the y2 ticks are aligned to the the ones of y. (only 1 grid) 2.) y=false, y2=true: y2 is the primary axis and the y ticks are aligned to the the ones of y2. (only 1 grid) 3.) y=true, y2=true: Both axis are independent and have their own ticks. (2 grids) 4.) y=false, y2=false: Invalid configuration causes an error."
	      },
	      "drawAxis": {
	        "default": "true for x and y, false for y2",
	        "labels": ["Axis display"],
	        "type": "boolean",
	        "description": "Whether to draw the specified axis. This may be set on a per-axis basis to define the visibility of each axis separately. Setting this to false also prevents axis ticks from being drawn and reclaims the space for the chart grid/lines."
	      },
	      "gridLineWidth": {
	        "default": "0.3",
	        "labels": ["Grid"],
	        "type": "float",
	        "description": "Thickness (in pixels) of the gridlines drawn under the chart. The vertical/horizontal gridlines can be turned off entirely by using the drawGrid option. This may be set on a per-axis basis to define each axis' grid separately."
	      },
	      "axisLineWidth": {
	        "default": "0.3",
	        "labels": ["Axis display"],
	        "type": "float",
	        "description": "Thickness (in pixels) of the x- and y-axis lines."
	      },
	      "axisLineColor": {
	        "default": "black",
	        "labels": ["Axis display"],
	        "type": "string",
	        "description": "Color of the x- and y-axis lines. Accepts any value which the HTML canvas strokeStyle attribute understands, e.g. 'black' or 'rgb(0, 100, 255)'."
	      },
	      "fillAlpha": {
	        "default": "0.15",
	        "labels": ["Error Bars", "Data Series Colors"],
	        "type": "float (0.0 - 1.0)",
	        "description": "Error bars (or custom bars) for each series are drawn in the same color as the series, but with partial transparency. This sets the transparency. A value of 0.0 means that the error bars will not be drawn, whereas a value of 1.0 means that the error bars will be as dark as the line for the series itself. This can be used to produce chart lines whose thickness varies at each point."
	      },
	      "axisLabelWidth": {
	        "default": "50 (y-axis), 60 (x-axis)",
	        "labels": ["Axis display", "Chart labels"],
	        "type": "integer",
	        "description": "Width (in pixels) of the containing divs for x- and y-axis labels. For the y-axis, this also controls the width of the y-axis. Note that for the x-axis, this is independent from pixelsPerLabel, which controls the spacing between labels."
	      },
	      "sigFigs": {
	        "default": "null",
	        "labels": ["Value display/formatting"],
	        "type": "integer",
	        "description": "By default, dygraphs displays numbers with a fixed number of digits after the decimal point. If you'd prefer to have a fixed number of significant figures, set this option to that number of sig figs. A value of 2, for instance, would cause 1 to be display as 1.0 and 1234 to be displayed as 1.23e+3."
	      },
	      "digitsAfterDecimal": {
	        "default": "2",
	        "labels": ["Value display/formatting"],
	        "type": "integer",
	        "description": "Unless it's run in scientific mode (see the <code>sigFigs</code> option), dygraphs displays numbers with <code>digitsAfterDecimal</code> digits after the decimal point. Trailing zeros are not displayed, so with a value of 2 you'll get '0', '0.1', '0.12', '123.45' but not '123.456' (it will be rounded to '123.46'). Numbers with absolute value less than 0.1^digitsAfterDecimal (i.e. those which would show up as '0.00') will be displayed in scientific notation."
	      },
	      "maxNumberWidth": {
	        "default": "6",
	        "labels": ["Value display/formatting"],
	        "type": "integer",
	        "description": "When displaying numbers in normal (not scientific) mode, large numbers will be displayed with many trailing zeros (e.g. 100000000 instead of 1e9). This can lead to unwieldy y-axis labels. If there are more than <code>maxNumberWidth</code> digits to the left of the decimal in a number, dygraphs will switch to scientific notation, even when not operating in scientific mode. If you'd like to see all those digits, set this to something large, like 20 or 30."
	      },
	      "file": {
	        "default": "(set when constructed)",
	        "labels": ["Data"],
	        "type": "string (URL of CSV or CSV), GViz DataTable or 2D Array",
	        "description": "Sets the data being displayed in the chart. This can only be set when calling updateOptions; it cannot be set from the constructor. For a full description of valid data formats, see the <a href='http://dygraphs.com/data.html'>Data Formats</a> page."
	      },
	      "timingName": {
	        "default": "null",
	        "labels": ["Debugging", "Deprecated"],
	        "type": "string",
	        "description": "Set this option to log timing information. The value of the option will be logged along with the timimg, so that you can distinguish multiple dygraphs on the same page."
	      },
	      "showRangeSelector": {
	        "default": "false",
	        "labels": ["Range Selector"],
	        "type": "boolean",
	        "description": "Show or hide the range selector widget."
	      },
	      "rangeSelectorHeight": {
	        "default": "40",
	        "labels": ["Range Selector"],
	        "type": "integer",
	        "description": "Height, in pixels, of the range selector widget. This option can only be specified at Dygraph creation time."
	      },
	      "rangeSelectorPlotStrokeColor": {
	        "default": "#808FAB",
	        "labels": ["Range Selector"],
	        "type": "string",
	        "description": "The range selector mini plot stroke color. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\". You can also specify null or \"\" to turn off stroke."
	      },
	      "rangeSelectorPlotFillColor": {
	        "default": "#A7B1C4",
	        "labels": ["Range Selector"],
	        "type": "string",
	        "description": "The range selector mini plot fill color. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\". You can also specify null or \"\" to turn off fill."
	      },
	      "rangeSelectorPlotFillGradientColor": {
	        "default": "white",
	        "labels": ["Range Selector"],
	        "type": "string",
	        "description": "The top color for the range selector mini plot fill color gradient. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"rgba(255,100,200,42)\" or \"yellow\". You can also specify null or \"\" to disable the gradient and fill with one single color."
	      },
	      "rangeSelectorBackgroundStrokeColor": {
	        "default": "gray",
	        "labels": ["Range Selector"],
	        "type": "string",
	        "description": "The color of the lines below and on both sides of the range selector mini plot. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\"."
	      },
	      "rangeSelectorBackgroundLineWidth": {
	        "default": "1",
	        "labels": ["Range Selector"],
	        "type": "float",
	        "description": "The width of the lines below and on both sides of the range selector mini plot."
	      },
	      "rangeSelectorPlotLineWidth": {
	        "default": "1.5",
	        "labels": ["Range Selector"],
	        "type": "float",
	        "description": "The width of the range selector mini plot line."
	      },
	      "rangeSelectorForegroundStrokeColor": {
	        "default": "black",
	        "labels": ["Range Selector"],
	        "type": "string",
	        "description": "The color of the lines in the interactive layer of the range selector. This can be of the form \"#AABBCC\" or \"rgb(255,100,200)\" or \"yellow\"."
	      },
	      "rangeSelectorForegroundLineWidth": {
	        "default": "1",
	        "labels": ["Range Selector"],
	        "type": "float",
	        "description": "The width the lines in the interactive layer of the range selector."
	      },
	      "rangeSelectorAlpha": {
	        "default": "0.6",
	        "labels": ["Range Selector"],
	        "type": "float (0.0 - 1.0)",
	        "description": "The transparency of the veil that is drawn over the unselected portions of the range selector mini plot. A value of 0 represents full transparency and the unselected portions of the mini plot will appear as normal. A value of 1 represents full opacity and the unselected portions of the mini plot will be hidden."
	      },
	      "showInRangeSelector": {
	        "default": "null",
	        "labels": ["Range Selector"],
	        "type": "boolean",
	        "description": "Mark this series for inclusion in the range selector. The mini plot curve will be an average of all such series. If this is not specified for any series, the default behavior is to average all the visible series. Setting it for one series will result in that series being charted alone in the range selector. Once it's set for a single series, it needs to be set for all series which should be included (regardless of visibility)."
	      },
	      "animatedZooms": {
	        "default": "false",
	        "labels": ["Interactive Elements"],
	        "type": "boolean",
	        "description": "Set this option to animate the transition between zoom windows. Applies to programmatic and interactive zooms. Note that if you also set a drawCallback, it will be called several times on each zoom. If you set a zoomCallback, it will only be called after the animation is complete."
	      },
	      "plotter": {
	        "default": "[DygraphCanvasRenderer.Plotters.fillPlotter, DygraphCanvasRenderer.Plotters.errorPlotter, DygraphCanvasRenderer.Plotters.linePlotter]",
	        "labels": ["Data Line display"],
	        "type": "array or function",
	        "description": "A function (or array of functions) which plot each data series on the chart. TODO(danvk): more details! May be set per-series."
	      },
	      "axes": {
	        "default": "null",
	        "labels": ["Configuration"],
	        "type": "Object",
	        "description": "Defines per-axis options. Valid keys are 'x', 'y' and 'y2'. Only some options may be set on a per-axis basis. If an option may be set in this way, it will be noted on this page. See also documentation on <a href='http://dygraphs.com/per-axis.html'>per-series and per-axis options</a>."
	      },
	      "series": {
	        "default": "null",
	        "labels": ["Series"],
	        "type": "Object",
	        "description": "Defines per-series options. Its keys match the y-axis label names, and the values are dictionaries themselves that contain options specific to that series."
	      },
	      "plugins": {
	        "default": "[]",
	        "labels": ["Configuration"],
	        "type": "Array<plugin>",
	        "description": "Defines per-graph plugins. Useful for per-graph customization"
	      },
	      "dataHandler": {
	        "default": "(depends on data)",
	        "labels": ["Data"],
	        "type": "Dygraph.DataHandler",
	        "description": "Custom DataHandler. This is an advanced customization. See http://bit.ly/151E7Aq."
	      }
	    }; // </JSON>
	    // NOTE: in addition to parsing as JS, this snippet is expected to be valid
	    // JSON. This assumption cannot be checked in JS, but it will be checked when
	    // documentation is generated by the generate-documentation.py script. For the
	    // most part, this just means that you should always use double quotes.

	    // Do a quick sanity check on the options reference.
	    var warn = function warn(msg) {
	      if (window.console) window.console.warn(msg);
	    };
	    var flds = ['type', 'default', 'description'];
	    var valid_cats = ['Annotations', 'Axis display', 'Chart labels', 'CSV parsing', 'Callbacks', 'Data', 'Data Line display', 'Data Series Colors', 'Error Bars', 'Grid', 'Interactive Elements', 'Range Selector', 'Legend', 'Overall display', 'Rolling Averages', 'Series', 'Value display/formatting', 'Zooming', 'Debugging', 'Configuration', 'Deprecated'];
	    var i;
	    var cats = {};
	    for (i = 0; i < valid_cats.length; i++) cats[valid_cats[i]] = true;

	    for (var k in OPTIONS_REFERENCE) {
	      if (!OPTIONS_REFERENCE.hasOwnProperty(k)) continue;
	      var op = OPTIONS_REFERENCE[k];
	      for (i = 0; i < flds.length; i++) {
	        if (!op.hasOwnProperty(flds[i])) {
	          warn('Option ' + k + ' missing "' + flds[i] + '" property');
	        } else if (typeof op[flds[i]] != 'string') {
	          warn(k + '.' + flds[i] + ' must be of type string');
	        }
	      }
	      var labels = op.labels;
	      if (typeof labels !== 'object') {
	        warn('Option "' + k + '" is missing a "labels": [...] option');
	      } else {
	        for (i = 0; i < labels.length; i++) {
	          if (!cats.hasOwnProperty(labels[i])) {
	            warn('Option "' + k + '" has label "' + labels[i] + '", which is invalid.');
	          }
	        }
	      }
	    }
	  }
	}

	exports['default'] = OPTIONS_REFERENCE;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * To create a "drag" interaction, you typically register a mousedown event
	 * handler on the element where the drag begins. In that handler, you register a
	 * mouseup handler on the window to determine when the mouse is released,
	 * wherever that release happens. This works well, except when the user releases
	 * the mouse over an off-domain iframe. In that case, the mouseup event is
	 * handled by the iframe and never bubbles up to the window handler.
	 *
	 * To deal with this issue, we cover iframes with high z-index divs to make sure
	 * they don't capture mouseup.
	 *
	 * Usage:
	 * element.addEventListener('mousedown', function() {
	 *   var tarper = new IFrameTarp();
	 *   tarper.cover();
	 *   var mouseUpHandler = function() {
	 *     ...
	 *     window.removeEventListener(mouseUpHandler);
	 *     tarper.uncover();
	 *   };
	 *   window.addEventListener('mouseup', mouseUpHandler);
	 * };
	 *
	 * @constructor
	 */
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	function IFrameTarp() {
	  /** @type {Array.<!HTMLDivElement>} */
	  this.tarps = [];
	};

	/**
	 * Find all the iframes in the document and cover them with high z-index
	 * transparent divs.
	 */
	IFrameTarp.prototype.cover = function () {
	  var iframes = document.getElementsByTagName("iframe");
	  for (var i = 0; i < iframes.length; i++) {
	    var iframe = iframes[i];
	    var pos = utils.findPos(iframe),
	        x = pos.x,
	        y = pos.y,
	        width = iframe.offsetWidth,
	        height = iframe.offsetHeight;

	    var div = document.createElement("div");
	    div.style.position = "absolute";
	    div.style.left = x + 'px';
	    div.style.top = y + 'px';
	    div.style.width = width + 'px';
	    div.style.height = height + 'px';
	    div.style.zIndex = 999;
	    document.body.appendChild(div);
	    this.tarps.push(div);
	  }
	};

	/**
	 * Remove all the iframe covers. You should call this in a mouseup handler.
	 */
	IFrameTarp.prototype.uncover = function () {
	  for (var i = 0; i < this.tarps.length; i++) {
	    this.tarps[i].parentNode.removeChild(this.tarps[i]);
	  }
	  this.tarps = [];
	};

	exports["default"] = IFrameTarp;
	module.exports = exports["default"];

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview DataHandler default implementation used for simple line charts.
	 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _datahandler = __webpack_require__(175);

	var _datahandler2 = _interopRequireDefault(_datahandler);

	/**
	 * @constructor
	 * @extends Dygraph.DataHandler
	 */
	var DefaultHandler = function DefaultHandler() {};

	DefaultHandler.prototype = new _datahandler2['default']();

	/** @inheritDoc */
	DefaultHandler.prototype.extractSeries = function (rawData, i, options) {
	  // TODO(danvk): pre-allocate series here.
	  var series = [];
	  var logScale = options.get('logscale');
	  for (var j = 0; j < rawData.length; j++) {
	    var x = rawData[j][0];
	    var point = rawData[j][i];
	    if (logScale) {
	      // On the log scale, points less than zero do not exist.
	      // This will create a gap in the chart.
	      if (point <= 0) {
	        point = null;
	      }
	    }
	    series.push([x, point]);
	  }
	  return series;
	};

	/** @inheritDoc */
	DefaultHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
	  rollPeriod = Math.min(rollPeriod, originalData.length);
	  var rollingData = [];

	  var i, j, y, sum, num_ok;
	  // Calculate the rolling average for the first rollPeriod - 1 points
	  // where
	  // there is not enough data to roll over the full number of points
	  if (rollPeriod == 1) {
	    return originalData;
	  }
	  for (i = 0; i < originalData.length; i++) {
	    sum = 0;
	    num_ok = 0;
	    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {
	      y = originalData[j][1];
	      if (y === null || isNaN(y)) continue;
	      num_ok++;
	      sum += originalData[j][1];
	    }
	    if (num_ok) {
	      rollingData[i] = [originalData[i][0], sum / num_ok];
	    } else {
	      rollingData[i] = [originalData[i][0], null];
	    }
	  }

	  return rollingData;
	};

	/** @inheritDoc */
	DefaultHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {
	  var minY = null,
	      maxY = null,
	      y;
	  var firstIdx = 0,
	      lastIdx = series.length - 1;

	  for (var j = firstIdx; j <= lastIdx; j++) {
	    y = series[j][1];
	    if (y === null || isNaN(y)) continue;
	    if (maxY === null || y > maxY) {
	      maxY = y;
	    }
	    if (minY === null || y < minY) {
	      minY = y;
	    }
	  }
	  return [minY, maxY];
	};

	exports['default'] = DefaultHandler;
	module.exports = exports['default'];

/***/ }),
/* 175 */
/***/ (function(module, exports) {

	/**
	 * @license
	 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview This file contains the managment of data handlers
	 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
	 *
	 * The idea is to define a common, generic data format that works for all data
	 * structures supported by dygraphs. To make this possible, the DataHandler
	 * interface is introduced. This makes it possible, that dygraph itself can work
	 * with the same logic for every data type independent of the actual format and
	 * the DataHandler takes care of the data format specific jobs.
	 * DataHandlers are implemented for all data types supported by Dygraphs and
	 * return Dygraphs compliant formats.
	 * By default the correct DataHandler is chosen based on the options set.
	 * Optionally the user may use his own DataHandler (similar to the plugin
	 * system).
	 *
	 *
	 * The unified data format returend by each handler is defined as so:
	 * series[n][point] = [x,y,(extras)]
	 *
	 * This format contains the common basis that is needed to draw a simple line
	 * series extended by optional extras for more complex graphing types. It
	 * contains a primitive x value as first array entry, a primitive y value as
	 * second array entry and an optional extras object for additional data needed.
	 *
	 * x must always be a number.
	 * y must always be a number, NaN of type number or null.
	 * extras is optional and must be interpreted by the DataHandler. It may be of
	 * any type.
	 *
	 * In practice this might look something like this:
	 * default: [x, yVal]
	 * errorBar / customBar: [x, yVal, [yTopVariance, yBottomVariance] ]
	 *
	 */
	/*global Dygraph:false */
	/*global DygraphLayout:false */

	"use strict";

	/**
	 *
	 * The data handler is responsible for all data specific operations. All of the
	 * series data it receives and returns is always in the unified data format.
	 * Initially the unified data is created by the extractSeries method
	 * @constructor
	 */
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var DygraphDataHandler = function DygraphDataHandler() {};

	var handler = DygraphDataHandler;

	/**
	 * X-value array index constant for unified data samples.
	 * @const
	 * @type {number}
	 */
	handler.X = 0;

	/**
	 * Y-value array index constant for unified data samples.
	 * @const
	 * @type {number}
	 */
	handler.Y = 1;

	/**
	 * Extras-value array index constant for unified data samples.
	 * @const
	 * @type {number}
	 */
	handler.EXTRAS = 2;

	/**
	 * Extracts one series from the raw data (a 2D array) into an array of the
	 * unified data format.
	 * This is where undesirable points (i.e. negative values on log scales and
	 * missing values through which we wish to connect lines) are dropped.
	 * TODO(danvk): the "missing values" bit above doesn't seem right.
	 *
	 * @param {!Array.<Array>} rawData The raw data passed into dygraphs where
	 *     rawData[i] = [x,ySeries1,...,ySeriesN].
	 * @param {!number} seriesIndex Index of the series to extract. All other
	 *     series should be ignored.
	 * @param {!DygraphOptions} options Dygraph options.
	 * @return {Array.<[!number,?number,?]>} The series in the unified data format
	 *     where series[i] = [x,y,{extras}].
	 */
	handler.prototype.extractSeries = function (rawData, seriesIndex, options) {};

	/**
	 * Converts a series to a Point array.  The resulting point array must be
	 * returned in increasing order of idx property.
	 *
	 * @param {!Array.<[!number,?number,?]>} series The series in the unified
	 *          data format where series[i] = [x,y,{extras}].
	 * @param {!string} setName Name of the series.
	 * @param {!number} boundaryIdStart Index offset of the first point, equal to the
	 *          number of skipped points left of the date window minimum (if any).
	 * @return {!Array.<Dygraph.PointType>} List of points for this series.
	 */
	handler.prototype.seriesToPoints = function (series, setName, boundaryIdStart) {
	  // TODO(bhs): these loops are a hot-spot for high-point-count charts. In
	  // fact,
	  // on chrome+linux, they are 6 times more expensive than iterating through
	  // the
	  // points and drawing the lines. The brunt of the cost comes from allocating
	  // the |point| structures.
	  var points = [];
	  for (var i = 0; i < series.length; ++i) {
	    var item = series[i];
	    var yraw = item[1];
	    var yval = yraw === null ? null : handler.parseFloat(yraw);
	    var point = {
	      x: NaN,
	      y: NaN,
	      xval: handler.parseFloat(item[0]),
	      yval: yval,
	      name: setName, // TODO(danvk): is this really necessary?
	      idx: i + boundaryIdStart
	    };
	    points.push(point);
	  }
	  this.onPointsCreated_(series, points);
	  return points;
	};

	/**
	 * Callback called for each series after the series points have been generated
	 * which will later be used by the plotters to draw the graph.
	 * Here data may be added to the seriesPoints which is needed by the plotters.
	 * The indexes of series and points are in sync meaning the original data
	 * sample for series[i] is points[i].
	 *
	 * @param {!Array.<[!number,?number,?]>} series The series in the unified
	 *     data format where series[i] = [x,y,{extras}].
	 * @param {!Array.<Dygraph.PointType>} points The corresponding points passed
	 *     to the plotter.
	 * @protected
	 */
	handler.prototype.onPointsCreated_ = function (series, points) {};

	/**
	 * Calculates the rolling average of a data set.
	 *
	 * @param {!Array.<[!number,?number,?]>} series The series in the unified
	 *          data format where series[i] = [x,y,{extras}].
	 * @param {!number} rollPeriod The number of points over which to average the data
	 * @param {!DygraphOptions} options The dygraph options.
	 * @return {!Array.<[!number,?number,?]>} the rolled series.
	 */
	handler.prototype.rollingAverage = function (series, rollPeriod, options) {};

	/**
	 * Computes the range of the data series (including confidence intervals).
	 *
	 * @param {!Array.<[!number,?number,?]>} series The series in the unified
	 *     data format where series[i] = [x, y, {extras}].
	 * @param {!Array.<number>} dateWindow The x-value range to display with
	 *     the format: [min, max].
	 * @param {!DygraphOptions} options The dygraph options.
	 * @return {Array.<number>} The low and high extremes of the series in the
	 *     given window with the format: [low, high].
	 */
	handler.prototype.getExtremeYValues = function (series, dateWindow, options) {};

	/**
	 * Callback called for each series after the layouting data has been
	 * calculated before the series is drawn. Here normalized positioning data
	 * should be calculated for the extras of each point.
	 *
	 * @param {!Array.<Dygraph.PointType>} points The points passed to
	 *          the plotter.
	 * @param {!Object} axis The axis on which the series will be plotted.
	 * @param {!boolean} logscale Weather or not to use a logscale.
	 */
	handler.prototype.onLineEvaluated = function (points, axis, logscale) {};

	/**
	 * Optimized replacement for parseFloat, which was way too slow when almost
	 * all values were type number, with few edge cases, none of which were strings.
	 * @param {?number} val
	 * @return {number}
	 * @protected
	 */
	handler.parseFloat = function (val) {
	  // parseFloat(null) is NaN
	  if (val === null) {
	    return NaN;
	  }

	  // Assume it's a number or NaN. If it's something else, I'll be shocked.
	  return val;
	};

	exports["default"] = DygraphDataHandler;
	module.exports = exports["default"];

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview DataHandler implementation for the error bars option.
	 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var _bars = __webpack_require__(177);

	var _bars2 = _interopRequireDefault(_bars);

	/**
	 * @constructor
	 * @extends BarsHandler
	 */
	var ErrorBarsHandler = function ErrorBarsHandler() {};

	ErrorBarsHandler.prototype = new _bars2["default"]();

	/** @inheritDoc */
	ErrorBarsHandler.prototype.extractSeries = function (rawData, i, options) {
	  // TODO(danvk): pre-allocate series here.
	  var series = [];
	  var x, y, variance, point;
	  var sigma = options.get("sigma");
	  var logScale = options.get('logscale');
	  for (var j = 0; j < rawData.length; j++) {
	    x = rawData[j][0];
	    point = rawData[j][i];
	    if (logScale && point !== null) {
	      // On the log scale, points less than zero do not exist.
	      // This will create a gap in the chart.
	      if (point[0] <= 0 || point[0] - sigma * point[1] <= 0) {
	        point = null;
	      }
	    }
	    // Extract to the unified data format.
	    if (point !== null) {
	      y = point[0];
	      if (y !== null && !isNaN(y)) {
	        variance = sigma * point[1];
	        // preserve original error value in extras for further
	        // filtering
	        series.push([x, y, [y - variance, y + variance, point[1]]]);
	      } else {
	        series.push([x, y, [y, y, y]]);
	      }
	    } else {
	      series.push([x, null, [null, null, null]]);
	    }
	  }
	  return series;
	};

	/** @inheritDoc */
	ErrorBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
	  rollPeriod = Math.min(rollPeriod, originalData.length);
	  var rollingData = [];
	  var sigma = options.get("sigma");

	  var i, j, y, v, sum, num_ok, stddev, variance, value;

	  // Calculate the rolling average for the first rollPeriod - 1 points
	  // where there is not enough data to roll over the full number of points
	  for (i = 0; i < originalData.length; i++) {
	    sum = 0;
	    variance = 0;
	    num_ok = 0;
	    for (j = Math.max(0, i - rollPeriod + 1); j < i + 1; j++) {
	      y = originalData[j][1];
	      if (y === null || isNaN(y)) continue;
	      num_ok++;
	      sum += y;
	      variance += Math.pow(originalData[j][2][2], 2);
	    }
	    if (num_ok) {
	      stddev = Math.sqrt(variance) / num_ok;
	      value = sum / num_ok;
	      rollingData[i] = [originalData[i][0], value, [value - sigma * stddev, value + sigma * stddev]];
	    } else {
	      // This explicitly preserves NaNs to aid with "independent
	      // series".
	      // See testRollingAveragePreservesNaNs.
	      v = rollPeriod == 1 ? originalData[i][1] : null;
	      rollingData[i] = [originalData[i][0], v, [v, v]];
	    }
	  }

	  return rollingData;
	};

	exports["default"] = ErrorBarsHandler;
	module.exports = exports["default"];

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview DataHandler base implementation for the "bar" 
	 * data formats. This implementation must be extended and the
	 * extractSeries and rollingAverage must be implemented.
	 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
	 */

	/*global Dygraph:false */
	/*global DygraphLayout:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _datahandler = __webpack_require__(175);

	var _datahandler2 = _interopRequireDefault(_datahandler);

	var _dygraphLayout = __webpack_require__(165);

	var _dygraphLayout2 = _interopRequireDefault(_dygraphLayout);

	/**
	 * @constructor
	 * @extends {Dygraph.DataHandler}
	 */
	var BarsHandler = function BarsHandler() {
	  _datahandler2['default'].call(this);
	};
	BarsHandler.prototype = new _datahandler2['default']();

	// TODO(danvk): figure out why the jsdoc has to be copy/pasted from superclass.
	//   (I get closure compiler errors if this isn't here.)
	/**
	 * @override
	 * @param {!Array.<Array>} rawData The raw data passed into dygraphs where 
	 *     rawData[i] = [x,ySeries1,...,ySeriesN].
	 * @param {!number} seriesIndex Index of the series to extract. All other
	 *     series should be ignored.
	 * @param {!DygraphOptions} options Dygraph options.
	 * @return {Array.<[!number,?number,?]>} The series in the unified data format
	 *     where series[i] = [x,y,{extras}]. 
	 */
	BarsHandler.prototype.extractSeries = function (rawData, seriesIndex, options) {
	  // Not implemented here must be extended
	};

	/**
	 * @override
	 * @param {!Array.<[!number,?number,?]>} series The series in the unified 
	 *          data format where series[i] = [x,y,{extras}].
	 * @param {!number} rollPeriod The number of points over which to average the data
	 * @param {!DygraphOptions} options The dygraph options.
	 * TODO(danvk): be more specific than "Array" here.
	 * @return {!Array.<[!number,?number,?]>} the rolled series.
	 */
	BarsHandler.prototype.rollingAverage = function (series, rollPeriod, options) {
	  // Not implemented here, must be extended.
	};

	/** @inheritDoc */
	BarsHandler.prototype.onPointsCreated_ = function (series, points) {
	  for (var i = 0; i < series.length; ++i) {
	    var item = series[i];
	    var point = points[i];
	    point.y_top = NaN;
	    point.y_bottom = NaN;
	    point.yval_minus = _datahandler2['default'].parseFloat(item[2][0]);
	    point.yval_plus = _datahandler2['default'].parseFloat(item[2][1]);
	  }
	};

	/** @inheritDoc */
	BarsHandler.prototype.getExtremeYValues = function (series, dateWindow, options) {
	  var minY = null,
	      maxY = null,
	      y;

	  var firstIdx = 0;
	  var lastIdx = series.length - 1;

	  for (var j = firstIdx; j <= lastIdx; j++) {
	    y = series[j][1];
	    if (y === null || isNaN(y)) continue;

	    var low = series[j][2][0];
	    var high = series[j][2][1];

	    if (low > y) low = y; // this can happen with custom bars,
	    if (high < y) high = y; // e.g. in tests/custom-bars.html

	    if (maxY === null || high > maxY) maxY = high;
	    if (minY === null || low < minY) minY = low;
	  }

	  return [minY, maxY];
	};

	/** @inheritDoc */
	BarsHandler.prototype.onLineEvaluated = function (points, axis, logscale) {
	  var point;
	  for (var j = 0; j < points.length; j++) {
	    // Copy over the error terms
	    point = points[j];
	    point.y_top = _dygraphLayout2['default'].calcYNormal_(axis, point.yval_minus, logscale);
	    point.y_bottom = _dygraphLayout2['default'].calcYNormal_(axis, point.yval_plus, logscale);
	  }
	};

	exports['default'] = BarsHandler;
	module.exports = exports['default'];

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview DataHandler implementation for the custom bars option.
	 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _bars = __webpack_require__(177);

	var _bars2 = _interopRequireDefault(_bars);

	/**
	 * @constructor
	 * @extends Dygraph.DataHandlers.BarsHandler
	 */
	var CustomBarsHandler = function CustomBarsHandler() {};

	CustomBarsHandler.prototype = new _bars2['default']();

	/** @inheritDoc */
	CustomBarsHandler.prototype.extractSeries = function (rawData, i, options) {
	  // TODO(danvk): pre-allocate series here.
	  var series = [];
	  var x, y, point;
	  var logScale = options.get('logscale');
	  for (var j = 0; j < rawData.length; j++) {
	    x = rawData[j][0];
	    point = rawData[j][i];
	    if (logScale && point !== null) {
	      // On the log scale, points less than zero do not exist.
	      // This will create a gap in the chart.
	      if (point[0] <= 0 || point[1] <= 0 || point[2] <= 0) {
	        point = null;
	      }
	    }
	    // Extract to the unified data format.
	    if (point !== null) {
	      y = point[1];
	      if (y !== null && !isNaN(y)) {
	        series.push([x, y, [point[0], point[2]]]);
	      } else {
	        series.push([x, y, [y, y]]);
	      }
	    } else {
	      series.push([x, null, [null, null]]);
	    }
	  }
	  return series;
	};

	/** @inheritDoc */
	CustomBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
	  rollPeriod = Math.min(rollPeriod, originalData.length);
	  var rollingData = [];
	  var y, low, high, mid, count, i, extremes;

	  low = 0;
	  mid = 0;
	  high = 0;
	  count = 0;
	  for (i = 0; i < originalData.length; i++) {
	    y = originalData[i][1];
	    extremes = originalData[i][2];
	    rollingData[i] = originalData[i];

	    if (y !== null && !isNaN(y)) {
	      low += extremes[0];
	      mid += y;
	      high += extremes[1];
	      count += 1;
	    }
	    if (i - rollPeriod >= 0) {
	      var prev = originalData[i - rollPeriod];
	      if (prev[1] !== null && !isNaN(prev[1])) {
	        low -= prev[2][0];
	        mid -= prev[1];
	        high -= prev[2][1];
	        count -= 1;
	      }
	    }
	    if (count) {
	      rollingData[i] = [originalData[i][0], 1.0 * mid / count, [1.0 * low / count, 1.0 * high / count]];
	    } else {
	      rollingData[i] = [originalData[i][0], null, [null, null]];
	    }
	  }

	  return rollingData;
	};

	exports['default'] = CustomBarsHandler;
	module.exports = exports['default'];

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview DataHandler implementation for the fractions option.
	 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _datahandler = __webpack_require__(175);

	var _datahandler2 = _interopRequireDefault(_datahandler);

	var _default = __webpack_require__(174);

	var _default2 = _interopRequireDefault(_default);

	/**
	 * @extends DefaultHandler
	 * @constructor
	 */
	var DefaultFractionHandler = function DefaultFractionHandler() {};

	DefaultFractionHandler.prototype = new _default2['default']();

	DefaultFractionHandler.prototype.extractSeries = function (rawData, i, options) {
	  // TODO(danvk): pre-allocate series here.
	  var series = [];
	  var x, y, point, num, den, value;
	  var mult = 100.0;
	  var logScale = options.get('logscale');
	  for (var j = 0; j < rawData.length; j++) {
	    x = rawData[j][0];
	    point = rawData[j][i];
	    if (logScale && point !== null) {
	      // On the log scale, points less than zero do not exist.
	      // This will create a gap in the chart.
	      if (point[0] <= 0 || point[1] <= 0) {
	        point = null;
	      }
	    }
	    // Extract to the unified data format.
	    if (point !== null) {
	      num = point[0];
	      den = point[1];
	      if (num !== null && !isNaN(num)) {
	        value = den ? num / den : 0.0;
	        y = mult * value;
	        // preserve original values in extras for further filtering
	        series.push([x, y, [num, den]]);
	      } else {
	        series.push([x, num, [num, den]]);
	      }
	    } else {
	      series.push([x, null, [null, null]]);
	    }
	  }
	  return series;
	};

	DefaultFractionHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
	  rollPeriod = Math.min(rollPeriod, originalData.length);
	  var rollingData = [];

	  var i;
	  var num = 0;
	  var den = 0; // numerator/denominator
	  var mult = 100.0;
	  for (i = 0; i < originalData.length; i++) {
	    num += originalData[i][2][0];
	    den += originalData[i][2][1];
	    if (i - rollPeriod >= 0) {
	      num -= originalData[i - rollPeriod][2][0];
	      den -= originalData[i - rollPeriod][2][1];
	    }

	    var date = originalData[i][0];
	    var value = den ? num / den : 0.0;
	    rollingData[i] = [date, mult * value];
	  }

	  return rollingData;
	};

	exports['default'] = DefaultFractionHandler;
	module.exports = exports['default'];

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2013 David Eberlein (david.eberlein@ch.sauter-bc.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview DataHandler implementation for the combination 
	 * of error bars and fractions options.
	 * @author David Eberlein (david.eberlein@ch.sauter-bc.com)
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	var _bars = __webpack_require__(177);

	var _bars2 = _interopRequireDefault(_bars);

	/**
	 * @constructor
	 * @extends Dygraph.DataHandlers.BarsHandler
	 */
	var FractionsBarsHandler = function FractionsBarsHandler() {};

	FractionsBarsHandler.prototype = new _bars2["default"]();

	/** @inheritDoc */
	FractionsBarsHandler.prototype.extractSeries = function (rawData, i, options) {
	  // TODO(danvk): pre-allocate series here.
	  var series = [];
	  var x, y, point, num, den, value, stddev, variance;
	  var mult = 100.0;
	  var sigma = options.get("sigma");
	  var logScale = options.get('logscale');
	  for (var j = 0; j < rawData.length; j++) {
	    x = rawData[j][0];
	    point = rawData[j][i];
	    if (logScale && point !== null) {
	      // On the log scale, points less than zero do not exist.
	      // This will create a gap in the chart.
	      if (point[0] <= 0 || point[1] <= 0) {
	        point = null;
	      }
	    }
	    // Extract to the unified data format.
	    if (point !== null) {
	      num = point[0];
	      den = point[1];
	      if (num !== null && !isNaN(num)) {
	        value = den ? num / den : 0.0;
	        stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;
	        variance = mult * stddev;
	        y = mult * value;
	        // preserve original values in extras for further filtering
	        series.push([x, y, [y - variance, y + variance, num, den]]);
	      } else {
	        series.push([x, num, [num, num, num, den]]);
	      }
	    } else {
	      series.push([x, null, [null, null, null, null]]);
	    }
	  }
	  return series;
	};

	/** @inheritDoc */
	FractionsBarsHandler.prototype.rollingAverage = function (originalData, rollPeriod, options) {
	  rollPeriod = Math.min(rollPeriod, originalData.length);
	  var rollingData = [];
	  var sigma = options.get("sigma");
	  var wilsonInterval = options.get("wilsonInterval");

	  var low, high, i, stddev;
	  var num = 0;
	  var den = 0; // numerator/denominator
	  var mult = 100.0;
	  for (i = 0; i < originalData.length; i++) {
	    num += originalData[i][2][2];
	    den += originalData[i][2][3];
	    if (i - rollPeriod >= 0) {
	      num -= originalData[i - rollPeriod][2][2];
	      den -= originalData[i - rollPeriod][2][3];
	    }

	    var date = originalData[i][0];
	    var value = den ? num / den : 0.0;
	    if (wilsonInterval) {
	      // For more details on this confidence interval, see:
	      // http://en.wikipedia.org/wiki/Binomial_confidence_interval
	      if (den) {
	        var p = value < 0 ? 0 : value,
	            n = den;
	        var pm = sigma * Math.sqrt(p * (1 - p) / n + sigma * sigma / (4 * n * n));
	        var denom = 1 + sigma * sigma / den;
	        low = (p + sigma * sigma / (2 * den) - pm) / denom;
	        high = (p + sigma * sigma / (2 * den) + pm) / denom;
	        rollingData[i] = [date, p * mult, [low * mult, high * mult]];
	      } else {
	        rollingData[i] = [date, 0, [0, 0]];
	      }
	    } else {
	      stddev = den ? sigma * Math.sqrt(value * (1 - value) / den) : 1.0;
	      rollingData[i] = [date, mult * value, [mult * (value - stddev), mult * (value + stddev)]];
	    }
	  }

	  return rollingData;
	};

	exports["default"] = FractionsBarsHandler;
	module.exports = exports["default"];

/***/ }),
/* 181 */
/***/ (function(module, exports) {

	/**
	 * @license
	 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/*global Dygraph:false */

	"use strict";

	/**
	Current bits of jankiness:
	- Uses dygraph.layout_ to get the parsed annotations.
	- Uses dygraph.plotter_.area

	It would be nice if the plugin didn't require so much special support inside
	the core dygraphs classes, but annotations involve quite a bit of parsing and
	layout.

	TODO(danvk): cache DOM elements.
	*/

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var annotations = function annotations() {
	  this.annotations_ = [];
	};

	annotations.prototype.toString = function () {
	  return "Annotations Plugin";
	};

	annotations.prototype.activate = function (g) {
	  return {
	    clearChart: this.clearChart,
	    didDrawChart: this.didDrawChart
	  };
	};

	annotations.prototype.detachLabels = function () {
	  for (var i = 0; i < this.annotations_.length; i++) {
	    var a = this.annotations_[i];
	    if (a.parentNode) a.parentNode.removeChild(a);
	    this.annotations_[i] = null;
	  }
	  this.annotations_ = [];
	};

	annotations.prototype.clearChart = function (e) {
	  this.detachLabels();
	};

	annotations.prototype.didDrawChart = function (e) {
	  var g = e.dygraph;

	  // Early out in the (common) case of zero annotations.
	  var points = g.layout_.annotated_points;
	  if (!points || points.length === 0) return;

	  var containerDiv = e.canvas.parentNode;

	  var bindEvt = function bindEvt(eventName, classEventName, pt) {
	    return function (annotation_event) {
	      var a = pt.annotation;
	      if (a.hasOwnProperty(eventName)) {
	        a[eventName](a, pt, g, annotation_event);
	      } else if (g.getOption(classEventName)) {
	        g.getOption(classEventName)(a, pt, g, annotation_event);
	      }
	    };
	  };

	  // Add the annotations one-by-one.
	  var area = e.dygraph.getArea();

	  // x-coord to sum of previous annotation's heights (used for stacking).
	  var xToUsedHeight = {};

	  for (var i = 0; i < points.length; i++) {
	    var p = points[i];
	    if (p.canvasx < area.x || p.canvasx > area.x + area.w || p.canvasy < area.y || p.canvasy > area.y + area.h) {
	      continue;
	    }

	    var a = p.annotation;
	    var tick_height = 6;
	    if (a.hasOwnProperty("tickHeight")) {
	      tick_height = a.tickHeight;
	    }

	    // TODO: deprecate axisLabelFontSize in favor of CSS
	    var div = document.createElement("div");
	    div.style['fontSize'] = g.getOption('axisLabelFontSize') + "px";
	    var className = 'dygraph-annotation';
	    if (!a.hasOwnProperty('icon')) {
	      // camelCase class names are deprecated.
	      className += ' dygraphDefaultAnnotation dygraph-default-annotation';
	    }
	    if (a.hasOwnProperty('cssClass')) {
	      className += " " + a.cssClass;
	    }
	    div.className = className;

	    var width = a.hasOwnProperty('width') ? a.width : 16;
	    var height = a.hasOwnProperty('height') ? a.height : 16;
	    if (a.hasOwnProperty('icon')) {
	      var img = document.createElement("img");
	      img.src = a.icon;
	      img.width = width;
	      img.height = height;
	      div.appendChild(img);
	    } else if (p.annotation.hasOwnProperty('shortText')) {
	      div.appendChild(document.createTextNode(p.annotation.shortText));
	    }
	    var left = p.canvasx - width / 2;
	    div.style.left = left + "px";
	    var divTop = 0;
	    if (a.attachAtBottom) {
	      var y = area.y + area.h - height - tick_height;
	      if (xToUsedHeight[left]) {
	        y -= xToUsedHeight[left];
	      } else {
	        xToUsedHeight[left] = 0;
	      }
	      xToUsedHeight[left] += tick_height + height;
	      divTop = y;
	    } else {
	      divTop = p.canvasy - height - tick_height;
	    }
	    div.style.top = divTop + "px";
	    div.style.width = width + "px";
	    div.style.height = height + "px";
	    div.title = p.annotation.text;
	    div.style.color = g.colorsMap_[p.name];
	    div.style.borderColor = g.colorsMap_[p.name];
	    a.div = div;

	    g.addAndTrackEvent(div, 'click', bindEvt('clickHandler', 'annotationClickHandler', p, this));
	    g.addAndTrackEvent(div, 'mouseover', bindEvt('mouseOverHandler', 'annotationMouseOverHandler', p, this));
	    g.addAndTrackEvent(div, 'mouseout', bindEvt('mouseOutHandler', 'annotationMouseOutHandler', p, this));
	    g.addAndTrackEvent(div, 'dblclick', bindEvt('dblClickHandler', 'annotationDblClickHandler', p, this));

	    containerDiv.appendChild(div);
	    this.annotations_.push(div);

	    var ctx = e.drawingContext;
	    ctx.save();
	    ctx.strokeStyle = a.hasOwnProperty('tickColor') ? a.tickColor : g.colorsMap_[p.name];
	    ctx.lineWidth = a.hasOwnProperty('tickWidth') ? a.tickWidth : g.getOption('strokeWidth');
	    ctx.beginPath();
	    if (!a.attachAtBottom) {
	      ctx.moveTo(p.canvasx, p.canvasy);
	      ctx.lineTo(p.canvasx, p.canvasy - 2 - tick_height);
	    } else {
	      var y = divTop + height;
	      ctx.moveTo(p.canvasx, y);
	      ctx.lineTo(p.canvasx, y + tick_height);
	    }
	    ctx.closePath();
	    ctx.stroke();
	    ctx.restore();
	  }
	};

	annotations.prototype.destroy = function () {
	  this.detachLabels();
	};

	exports["default"] = annotations;
	module.exports = exports["default"];

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/*global Dygraph:false */

	'use strict';

	/*
	Bits of jankiness:
	- Direct layout access
	- Direct area access
	- Should include calculation of ticks, not just the drawing.

	Options left to make axis-friendly.
	  ('drawAxesAtZero')
	  ('xAxisHeight')
	*/

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	/**
	 * Draws the axes. This includes the labels on the x- and y-axes, as well
	 * as the tick marks on the axes.
	 * It does _not_ draw the grid lines which span the entire chart.
	 */
	var axes = function axes() {
	  this.xlabels_ = [];
	  this.ylabels_ = [];
	};

	axes.prototype.toString = function () {
	  return 'Axes Plugin';
	};

	axes.prototype.activate = function (g) {
	  return {
	    layout: this.layout,
	    clearChart: this.clearChart,
	    willDrawChart: this.willDrawChart
	  };
	};

	axes.prototype.layout = function (e) {
	  var g = e.dygraph;

	  if (g.getOptionForAxis('drawAxis', 'y')) {
	    var w = g.getOptionForAxis('axisLabelWidth', 'y') + 2 * g.getOptionForAxis('axisTickSize', 'y');
	    e.reserveSpaceLeft(w);
	  }

	  if (g.getOptionForAxis('drawAxis', 'x')) {
	    var h;
	    // NOTE: I think this is probably broken now, since g.getOption() now
	    // hits the dictionary. (That is, g.getOption('xAxisHeight') now always
	    // has a value.)
	    if (g.getOption('xAxisHeight')) {
	      h = g.getOption('xAxisHeight');
	    } else {
	      h = g.getOptionForAxis('axisLabelFontSize', 'x') + 2 * g.getOptionForAxis('axisTickSize', 'x');
	    }
	    e.reserveSpaceBottom(h);
	  }

	  if (g.numAxes() == 2) {
	    if (g.getOptionForAxis('drawAxis', 'y2')) {
	      var w = g.getOptionForAxis('axisLabelWidth', 'y2') + 2 * g.getOptionForAxis('axisTickSize', 'y2');
	      e.reserveSpaceRight(w);
	    }
	  } else if (g.numAxes() > 2) {
	    g.error('Only two y-axes are supported at this time. (Trying ' + 'to use ' + g.numAxes() + ')');
	  }
	};

	axes.prototype.detachLabels = function () {
	  function removeArray(ary) {
	    for (var i = 0; i < ary.length; i++) {
	      var el = ary[i];
	      if (el.parentNode) el.parentNode.removeChild(el);
	    }
	  }

	  removeArray(this.xlabels_);
	  removeArray(this.ylabels_);
	  this.xlabels_ = [];
	  this.ylabels_ = [];
	};

	axes.prototype.clearChart = function (e) {
	  this.detachLabels();
	};

	axes.prototype.willDrawChart = function (e) {
	  var _this = this;

	  var g = e.dygraph;

	  if (!g.getOptionForAxis('drawAxis', 'x') && !g.getOptionForAxis('drawAxis', 'y') && !g.getOptionForAxis('drawAxis', 'y2')) {
	    return;
	  }

	  // Round pixels to half-integer boundaries for crisper drawing.
	  function halfUp(x) {
	    return Math.round(x) + 0.5;
	  }
	  function halfDown(y) {
	    return Math.round(y) - 0.5;
	  }

	  var context = e.drawingContext;
	  var containerDiv = e.canvas.parentNode;
	  var canvasWidth = g.width_; // e.canvas.width is affected by pixel ratio.
	  var canvasHeight = g.height_;

	  var label, x, y, tick, i;

	  var makeLabelStyle = function makeLabelStyle(axis) {
	    return {
	      position: 'absolute',
	      fontSize: g.getOptionForAxis('axisLabelFontSize', axis) + 'px',
	      width: g.getOptionForAxis('axisLabelWidth', axis) + 'px'
	    };
	  };

	  var labelStyles = {
	    x: makeLabelStyle('x'),
	    y: makeLabelStyle('y'),
	    y2: makeLabelStyle('y2')
	  };

	  var makeDiv = function makeDiv(txt, axis, prec_axis) {
	    /*
	     * This seems to be called with the following three sets of axis/prec_axis:
	     * x: undefined
	     * y: y1
	     * y: y2
	     */
	    var div = document.createElement('div');
	    var labelStyle = labelStyles[prec_axis == 'y2' ? 'y2' : axis];
	    utils.update(div.style, labelStyle);
	    // TODO: combine outer & inner divs
	    var inner_div = document.createElement('div');
	    inner_div.className = 'dygraph-axis-label' + ' dygraph-axis-label-' + axis + (prec_axis ? ' dygraph-axis-label-' + prec_axis : '');
	    inner_div.innerHTML = txt;
	    div.appendChild(inner_div);
	    return div;
	  };

	  // axis lines
	  context.save();

	  var layout = g.layout_;
	  var area = e.dygraph.plotter_.area;

	  // Helper for repeated axis-option accesses.
	  var makeOptionGetter = function makeOptionGetter(axis) {
	    return function (option) {
	      return g.getOptionForAxis(option, axis);
	    };
	  };

	  if (g.getOptionForAxis('drawAxis', 'y')) {
	    if (layout.yticks && layout.yticks.length > 0) {
	      var num_axes = g.numAxes();
	      var getOptions = [makeOptionGetter('y'), makeOptionGetter('y2')];
	      layout.yticks.forEach(function (tick) {
	        if (tick.label === undefined) return; // this tick only has a grid line.
	        x = area.x;
	        var sgn = 1;
	        var prec_axis = 'y1';
	        var getAxisOption = getOptions[0];
	        if (tick.axis == 1) {
	          // right-side y-axis
	          x = area.x + area.w;
	          sgn = -1;
	          prec_axis = 'y2';
	          getAxisOption = getOptions[1];
	        }
	        var fontSize = getAxisOption('axisLabelFontSize');
	        y = area.y + tick.pos * area.h;

	        /* Tick marks are currently clipped, so don't bother drawing them.
	        context.beginPath();
	        context.moveTo(halfUp(x), halfDown(y));
	        context.lineTo(halfUp(x - sgn * this.attr_('axisTickSize')), halfDown(y));
	        context.closePath();
	        context.stroke();
	        */

	        label = makeDiv(tick.label, 'y', num_axes == 2 ? prec_axis : null);
	        var top = y - fontSize / 2;
	        if (top < 0) top = 0;

	        if (top + fontSize + 3 > canvasHeight) {
	          label.style.bottom = '0';
	        } else {
	          label.style.top = top + 'px';
	        }
	        // TODO: replace these with css classes?
	        if (tick.axis === 0) {
	          label.style.left = area.x - getAxisOption('axisLabelWidth') - getAxisOption('axisTickSize') + 'px';
	          label.style.textAlign = 'right';
	        } else if (tick.axis == 1) {
	          label.style.left = area.x + area.w + getAxisOption('axisTickSize') + 'px';
	          label.style.textAlign = 'left';
	        }
	        label.style.width = getAxisOption('axisLabelWidth') + 'px';
	        containerDiv.appendChild(label);
	        _this.ylabels_.push(label);
	      });

	      // The lowest tick on the y-axis often overlaps with the leftmost
	      // tick on the x-axis. Shift the bottom tick up a little bit to
	      // compensate if necessary.
	      var bottomTick = this.ylabels_[0];
	      // Interested in the y2 axis also?
	      var fontSize = g.getOptionForAxis('axisLabelFontSize', 'y');
	      var bottom = parseInt(bottomTick.style.top, 10) + fontSize;
	      if (bottom > canvasHeight - fontSize) {
	        bottomTick.style.top = parseInt(bottomTick.style.top, 10) - fontSize / 2 + 'px';
	      }
	    }

	    // draw a vertical line on the left to separate the chart from the labels.
	    var axisX;
	    if (g.getOption('drawAxesAtZero')) {
	      var r = g.toPercentXCoord(0);
	      if (r > 1 || r < 0 || isNaN(r)) r = 0;
	      axisX = halfUp(area.x + r * area.w);
	    } else {
	      axisX = halfUp(area.x);
	    }

	    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y');
	    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y');

	    context.beginPath();
	    context.moveTo(axisX, halfDown(area.y));
	    context.lineTo(axisX, halfDown(area.y + area.h));
	    context.closePath();
	    context.stroke();

	    // if there's a secondary y-axis, draw a vertical line for that, too.
	    if (g.numAxes() == 2) {
	      context.strokeStyle = g.getOptionForAxis('axisLineColor', 'y2');
	      context.lineWidth = g.getOptionForAxis('axisLineWidth', 'y2');
	      context.beginPath();
	      context.moveTo(halfDown(area.x + area.w), halfDown(area.y));
	      context.lineTo(halfDown(area.x + area.w), halfDown(area.y + area.h));
	      context.closePath();
	      context.stroke();
	    }
	  }

	  if (g.getOptionForAxis('drawAxis', 'x')) {
	    if (layout.xticks) {
	      var getAxisOption = makeOptionGetter('x');
	      layout.xticks.forEach(function (tick) {
	        if (tick.label === undefined) return; // this tick only has a grid line.
	        x = area.x + tick.pos * area.w;
	        y = area.y + area.h;

	        /* Tick marks are currently clipped, so don't bother drawing them.
	        context.beginPath();
	        context.moveTo(halfUp(x), halfDown(y));
	        context.lineTo(halfUp(x), halfDown(y + this.attr_('axisTickSize')));
	        context.closePath();
	        context.stroke();
	        */

	        label = makeDiv(tick.label, 'x');
	        label.style.textAlign = 'center';
	        label.style.top = y + getAxisOption('axisTickSize') + 'px';

	        var left = x - getAxisOption('axisLabelWidth') / 2;
	        if (left + getAxisOption('axisLabelWidth') > canvasWidth) {
	          left = canvasWidth - getAxisOption('axisLabelWidth');
	          label.style.textAlign = 'right';
	        }
	        if (left < 0) {
	          left = 0;
	          label.style.textAlign = 'left';
	        }

	        label.style.left = left + 'px';
	        label.style.width = getAxisOption('axisLabelWidth') + 'px';
	        containerDiv.appendChild(label);
	        _this.xlabels_.push(label);
	      });
	    }

	    context.strokeStyle = g.getOptionForAxis('axisLineColor', 'x');
	    context.lineWidth = g.getOptionForAxis('axisLineWidth', 'x');
	    context.beginPath();
	    var axisY;
	    if (g.getOption('drawAxesAtZero')) {
	      var r = g.toPercentYCoord(0, 0);
	      if (r > 1 || r < 0) r = 1;
	      axisY = halfDown(area.y + r * area.h);
	    } else {
	      axisY = halfDown(area.y + area.h);
	    }
	    context.moveTo(halfUp(area.x), axisY);
	    context.lineTo(halfUp(area.x + area.w), axisY);
	    context.closePath();
	    context.stroke();
	  }

	  context.restore();
	};

	exports['default'] = axes;
	module.exports = exports['default'];

/***/ }),
/* 183 */
/***/ (function(module, exports) {

	/**
	 * @license
	 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */
	/*global Dygraph:false */

	"use strict";

	// TODO(danvk): move chart label options out of dygraphs and into the plugin.
	// TODO(danvk): only tear down & rebuild the DIVs when it's necessary.

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var chart_labels = function chart_labels() {
	  this.title_div_ = null;
	  this.xlabel_div_ = null;
	  this.ylabel_div_ = null;
	  this.y2label_div_ = null;
	};

	chart_labels.prototype.toString = function () {
	  return "ChartLabels Plugin";
	};

	chart_labels.prototype.activate = function (g) {
	  return {
	    layout: this.layout,
	    // clearChart: this.clearChart,
	    didDrawChart: this.didDrawChart
	  };
	};

	// QUESTION: should there be a plugin-utils.js?
	var createDivInRect = function createDivInRect(r) {
	  var div = document.createElement('div');
	  div.style.position = 'absolute';
	  div.style.left = r.x + 'px';
	  div.style.top = r.y + 'px';
	  div.style.width = r.w + 'px';
	  div.style.height = r.h + 'px';
	  return div;
	};

	// Detach and null out any existing nodes.
	chart_labels.prototype.detachLabels_ = function () {
	  var els = [this.title_div_, this.xlabel_div_, this.ylabel_div_, this.y2label_div_];
	  for (var i = 0; i < els.length; i++) {
	    var el = els[i];
	    if (!el) continue;
	    if (el.parentNode) el.parentNode.removeChild(el);
	  }

	  this.title_div_ = null;
	  this.xlabel_div_ = null;
	  this.ylabel_div_ = null;
	  this.y2label_div_ = null;
	};

	var createRotatedDiv = function createRotatedDiv(g, box, axis, classes, html) {
	  // TODO(danvk): is this outer div actually necessary?
	  var div = document.createElement("div");
	  div.style.position = 'absolute';
	  if (axis == 1) {
	    // NOTE: this is cheating. Should be positioned relative to the box.
	    div.style.left = '0px';
	  } else {
	    div.style.left = box.x + 'px';
	  }
	  div.style.top = box.y + 'px';
	  div.style.width = box.w + 'px';
	  div.style.height = box.h + 'px';
	  div.style.fontSize = g.getOption('yLabelWidth') - 2 + 'px';

	  var inner_div = document.createElement("div");
	  inner_div.style.position = 'absolute';
	  inner_div.style.width = box.h + 'px';
	  inner_div.style.height = box.w + 'px';
	  inner_div.style.top = box.h / 2 - box.w / 2 + 'px';
	  inner_div.style.left = box.w / 2 - box.h / 2 + 'px';
	  // TODO: combine inner_div and class_div.
	  inner_div.className = 'dygraph-label-rotate-' + (axis == 1 ? 'right' : 'left');

	  var class_div = document.createElement("div");
	  class_div.className = classes;
	  class_div.innerHTML = html;

	  inner_div.appendChild(class_div);
	  div.appendChild(inner_div);
	  return div;
	};

	chart_labels.prototype.layout = function (e) {
	  this.detachLabels_();

	  var g = e.dygraph;
	  var div = e.chart_div;
	  if (g.getOption('title')) {
	    // QUESTION: should this return an absolutely-positioned div instead?
	    var title_rect = e.reserveSpaceTop(g.getOption('titleHeight'));
	    this.title_div_ = createDivInRect(title_rect);
	    this.title_div_.style.fontSize = g.getOption('titleHeight') - 8 + 'px';

	    var class_div = document.createElement("div");
	    class_div.className = 'dygraph-label dygraph-title';
	    class_div.innerHTML = g.getOption('title');
	    this.title_div_.appendChild(class_div);
	    div.appendChild(this.title_div_);
	  }

	  if (g.getOption('xlabel')) {
	    var x_rect = e.reserveSpaceBottom(g.getOption('xLabelHeight'));
	    this.xlabel_div_ = createDivInRect(x_rect);
	    this.xlabel_div_.style.fontSize = g.getOption('xLabelHeight') - 2 + 'px';

	    var class_div = document.createElement("div");
	    class_div.className = 'dygraph-label dygraph-xlabel';
	    class_div.innerHTML = g.getOption('xlabel');
	    this.xlabel_div_.appendChild(class_div);
	    div.appendChild(this.xlabel_div_);
	  }

	  if (g.getOption('ylabel')) {
	    // It would make sense to shift the chart here to make room for the y-axis
	    // label, but the default yAxisLabelWidth is large enough that this results
	    // in overly-padded charts. The y-axis label should fit fine. If it
	    // doesn't, the yAxisLabelWidth option can be increased.
	    var y_rect = e.reserveSpaceLeft(0);

	    this.ylabel_div_ = createRotatedDiv(g, y_rect, 1, // primary (left) y-axis
	    'dygraph-label dygraph-ylabel', g.getOption('ylabel'));
	    div.appendChild(this.ylabel_div_);
	  }

	  if (g.getOption('y2label') && g.numAxes() == 2) {
	    // same logic applies here as for ylabel.
	    var y2_rect = e.reserveSpaceRight(0);
	    this.y2label_div_ = createRotatedDiv(g, y2_rect, 2, // secondary (right) y-axis
	    'dygraph-label dygraph-y2label', g.getOption('y2label'));
	    div.appendChild(this.y2label_div_);
	  }
	};

	chart_labels.prototype.didDrawChart = function (e) {
	  var g = e.dygraph;
	  if (this.title_div_) {
	    this.title_div_.children[0].innerHTML = g.getOption('title');
	  }
	  if (this.xlabel_div_) {
	    this.xlabel_div_.children[0].innerHTML = g.getOption('xlabel');
	  }
	  if (this.ylabel_div_) {
	    this.ylabel_div_.children[0].children[0].innerHTML = g.getOption('ylabel');
	  }
	  if (this.y2label_div_) {
	    this.y2label_div_.children[0].children[0].innerHTML = g.getOption('y2label');
	  }
	};

	chart_labels.prototype.clearChart = function () {};

	chart_labels.prototype.destroy = function () {
	  this.detachLabels_();
	};

	exports["default"] = chart_labels;
	module.exports = exports["default"];

/***/ }),
/* 184 */
/***/ (function(module, exports) {

	/**
	 * @license
	 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */
	/*global Dygraph:false */

	/*

	Current bits of jankiness:
	- Direct layout access
	- Direct area access

	*/

	"use strict";

	/**
	 * Draws the gridlines, i.e. the gray horizontal & vertical lines running the
	 * length of the chart.
	 *
	 * @constructor
	 */
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var grid = function grid() {};

	grid.prototype.toString = function () {
	  return "Gridline Plugin";
	};

	grid.prototype.activate = function (g) {
	  return {
	    willDrawChart: this.willDrawChart
	  };
	};

	grid.prototype.willDrawChart = function (e) {
	  // Draw the new X/Y grid. Lines appear crisper when pixels are rounded to
	  // half-integers. This prevents them from drawing in two rows/cols.
	  var g = e.dygraph;
	  var ctx = e.drawingContext;
	  var layout = g.layout_;
	  var area = e.dygraph.plotter_.area;

	  function halfUp(x) {
	    return Math.round(x) + 0.5;
	  }
	  function halfDown(y) {
	    return Math.round(y) - 0.5;
	  }

	  var x, y, i, ticks;
	  if (g.getOptionForAxis('drawGrid', 'y')) {
	    var axes = ["y", "y2"];
	    var strokeStyles = [],
	        lineWidths = [],
	        drawGrid = [],
	        stroking = [],
	        strokePattern = [];
	    for (var i = 0; i < axes.length; i++) {
	      drawGrid[i] = g.getOptionForAxis('drawGrid', axes[i]);
	      if (drawGrid[i]) {
	        strokeStyles[i] = g.getOptionForAxis('gridLineColor', axes[i]);
	        lineWidths[i] = g.getOptionForAxis('gridLineWidth', axes[i]);
	        strokePattern[i] = g.getOptionForAxis('gridLinePattern', axes[i]);
	        stroking[i] = strokePattern[i] && strokePattern[i].length >= 2;
	      }
	    }
	    ticks = layout.yticks;
	    ctx.save();
	    // draw grids for the different y axes
	    ticks.forEach(function (tick) {
	      if (!tick.has_tick) return;
	      var axis = tick.axis;
	      if (drawGrid[axis]) {
	        ctx.save();
	        if (stroking[axis]) {
	          if (ctx.setLineDash) ctx.setLineDash(strokePattern[axis]);
	        }
	        ctx.strokeStyle = strokeStyles[axis];
	        ctx.lineWidth = lineWidths[axis];

	        x = halfUp(area.x);
	        y = halfDown(area.y + tick.pos * area.h);
	        ctx.beginPath();
	        ctx.moveTo(x, y);
	        ctx.lineTo(x + area.w, y);
	        ctx.stroke();

	        ctx.restore();
	      }
	    });
	    ctx.restore();
	  }

	  // draw grid for x axis
	  if (g.getOptionForAxis('drawGrid', 'x')) {
	    ticks = layout.xticks;
	    ctx.save();
	    var strokePattern = g.getOptionForAxis('gridLinePattern', 'x');
	    var stroking = strokePattern && strokePattern.length >= 2;
	    if (stroking) {
	      if (ctx.setLineDash) ctx.setLineDash(strokePattern);
	    }
	    ctx.strokeStyle = g.getOptionForAxis('gridLineColor', 'x');
	    ctx.lineWidth = g.getOptionForAxis('gridLineWidth', 'x');
	    ticks.forEach(function (tick) {
	      if (!tick.has_tick) return;
	      x = halfUp(area.x + tick.pos * area.w);
	      y = halfDown(area.y + area.h);
	      ctx.beginPath();
	      ctx.moveTo(x, y);
	      ctx.lineTo(x, area.y);
	      ctx.closePath();
	      ctx.stroke();
	    });
	    if (stroking) {
	      if (ctx.setLineDash) ctx.setLineDash([]);
	    }
	    ctx.restore();
	  }
	};

	grid.prototype.destroy = function () {};

	exports["default"] = grid;
	module.exports = exports["default"];

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2012 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */
	/*global Dygraph:false */

	/*
	Current bits of jankiness:
	- Uses two private APIs:
	    1. Dygraph.optionsViewForAxis_
	    2. dygraph.plotter_.area
	- Registers for a "predraw" event, which should be renamed.
	- I call calculateEmWidthInDiv more often than needed.
	*/

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	/**
	 * Creates the legend, which appears when the user hovers over the chart.
	 * The legend can be either a user-specified or generated div.
	 *
	 * @constructor
	 */
	var Legend = function Legend() {
	  this.legend_div_ = null;
	  this.is_generated_div_ = false; // do we own this div, or was it user-specified?
	};

	Legend.prototype.toString = function () {
	  return "Legend Plugin";
	};

	/**
	 * This is called during the dygraph constructor, after options have been set
	 * but before the data is available.
	 *
	 * Proper tasks to do here include:
	 * - Reading your own options
	 * - DOM manipulation
	 * - Registering event listeners
	 *
	 * @param {Dygraph} g Graph instance.
	 * @return {object.<string, function(ev)>} Mapping of event names to callbacks.
	 */
	Legend.prototype.activate = function (g) {
	  var div;

	  var userLabelsDiv = g.getOption('labelsDiv');
	  if (userLabelsDiv && null !== userLabelsDiv) {
	    if (typeof userLabelsDiv == "string" || userLabelsDiv instanceof String) {
	      div = document.getElementById(userLabelsDiv);
	    } else {
	      div = userLabelsDiv;
	    }
	  } else {
	    div = document.createElement("div");
	    div.className = "dygraph-legend";
	    // TODO(danvk): come up with a cleaner way to expose this.
	    g.graphDiv.appendChild(div);
	    this.is_generated_div_ = true;
	  }

	  this.legend_div_ = div;
	  this.one_em_width_ = 10; // just a guess, will be updated.

	  return {
	    select: this.select,
	    deselect: this.deselect,
	    // TODO(danvk): rethink the name "predraw" before we commit to it in any API.
	    predraw: this.predraw,
	    didDrawChart: this.didDrawChart
	  };
	};

	// Needed for dashed lines.
	var calculateEmWidthInDiv = function calculateEmWidthInDiv(div) {
	  var sizeSpan = document.createElement('span');
	  sizeSpan.setAttribute('style', 'margin: 0; padding: 0 0 0 1em; border: 0;');
	  div.appendChild(sizeSpan);
	  var oneEmWidth = sizeSpan.offsetWidth;
	  div.removeChild(sizeSpan);
	  return oneEmWidth;
	};

	var escapeHTML = function escapeHTML(str) {
	  return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
	};

	Legend.prototype.select = function (e) {
	  var xValue = e.selectedX;
	  var points = e.selectedPoints;
	  var row = e.selectedRow;

	  var legendMode = e.dygraph.getOption('legend');
	  if (legendMode === 'never') {
	    this.legend_div_.style.display = 'none';
	    return;
	  }

	  if (legendMode === 'follow') {
	    // create floating legend div
	    var area = e.dygraph.plotter_.area;
	    var labelsDivWidth = this.legend_div_.offsetWidth;
	    var yAxisLabelWidth = e.dygraph.getOptionForAxis('axisLabelWidth', 'y');
	    // determine floating [left, top] coordinates of the legend div
	    // within the plotter_ area
	    // offset 50 px to the right and down from the first selection point
	    // 50 px is guess based on mouse cursor size
	    var leftLegend = points[0].x * area.w + 50;
	    var topLegend = points[0].y * area.h - 50;

	    // if legend floats to end of the chart area, it flips to the other
	    // side of the selection point
	    if (leftLegend + labelsDivWidth + 1 > area.w) {
	      leftLegend = leftLegend - 2 * 50 - labelsDivWidth - (yAxisLabelWidth - area.x);
	    }

	    e.dygraph.graphDiv.appendChild(this.legend_div_);
	    this.legend_div_.style.left = yAxisLabelWidth + leftLegend + "px";
	    this.legend_div_.style.top = topLegend + "px";
	  }

	  var html = Legend.generateLegendHTML(e.dygraph, xValue, points, this.one_em_width_, row);
	  this.legend_div_.innerHTML = html;
	  this.legend_div_.style.display = '';
	};

	Legend.prototype.deselect = function (e) {
	  var legendMode = e.dygraph.getOption('legend');
	  if (legendMode !== 'always') {
	    this.legend_div_.style.display = "none";
	  }

	  // Have to do this every time, since styles might have changed.
	  var oneEmWidth = calculateEmWidthInDiv(this.legend_div_);
	  this.one_em_width_ = oneEmWidth;

	  var html = Legend.generateLegendHTML(e.dygraph, undefined, undefined, oneEmWidth, null);
	  this.legend_div_.innerHTML = html;
	};

	Legend.prototype.didDrawChart = function (e) {
	  this.deselect(e);
	};

	// Right edge should be flush with the right edge of the charting area (which
	// may not be the same as the right edge of the div, if we have two y-axes.
	// TODO(danvk): is any of this really necessary? Could just set "right" in "activate".
	/**
	 * Position the labels div so that:
	 * - its right edge is flush with the right edge of the charting area
	 * - its top edge is flush with the top edge of the charting area
	 * @private
	 */
	Legend.prototype.predraw = function (e) {
	  // Don't touch a user-specified labelsDiv.
	  if (!this.is_generated_div_) return;

	  // TODO(danvk): only use real APIs for this.
	  e.dygraph.graphDiv.appendChild(this.legend_div_);
	  var area = e.dygraph.getArea();
	  var labelsDivWidth = this.legend_div_.offsetWidth;
	  this.legend_div_.style.left = area.x + area.w - labelsDivWidth - 1 + "px";
	  this.legend_div_.style.top = area.y + "px";
	};

	/**
	 * Called when dygraph.destroy() is called.
	 * You should null out any references and detach any DOM elements.
	 */
	Legend.prototype.destroy = function () {
	  this.legend_div_ = null;
	};

	/**
	 * Generates HTML for the legend which is displayed when hovering over the
	 * chart. If no selected points are specified, a default legend is returned
	 * (this may just be the empty string).
	 * @param {number} x The x-value of the selected points.
	 * @param {Object} sel_points List of selected points for the given
	 *   x-value. Should have properties like 'name', 'yval' and 'canvasy'.
	 * @param {number} oneEmWidth The pixel width for 1em in the legend. Only
	 *   relevant when displaying a legend with no selection (i.e. {legend:
	 *   'always'}) and with dashed lines.
	 * @param {number} row The selected row index.
	 * @private
	 */
	Legend.generateLegendHTML = function (g, x, sel_points, oneEmWidth, row) {
	  // Data about the selection to pass to legendFormatter
	  var data = {
	    dygraph: g,
	    x: x,
	    series: []
	  };

	  var labelToSeries = {};
	  var labels = g.getLabels();
	  if (labels) {
	    for (var i = 1; i < labels.length; i++) {
	      var series = g.getPropertiesForSeries(labels[i]);
	      var strokePattern = g.getOption('strokePattern', labels[i]);
	      var seriesData = {
	        dashHTML: generateLegendDashHTML(strokePattern, series.color, oneEmWidth),
	        label: labels[i],
	        labelHTML: escapeHTML(labels[i]),
	        isVisible: series.visible,
	        color: series.color
	      };

	      data.series.push(seriesData);
	      labelToSeries[labels[i]] = seriesData;
	    }
	  }

	  if (typeof x !== 'undefined') {
	    var xOptView = g.optionsViewForAxis_('x');
	    var xvf = xOptView('valueFormatter');
	    data.xHTML = xvf.call(g, x, xOptView, labels[0], g, row, 0);

	    var yOptViews = [];
	    var num_axes = g.numAxes();
	    for (var i = 0; i < num_axes; i++) {
	      // TODO(danvk): remove this use of a private API
	      yOptViews[i] = g.optionsViewForAxis_('y' + (i ? 1 + i : ''));
	    }

	    var showZeros = g.getOption('labelsShowZeroValues');
	    var highlightSeries = g.getHighlightSeries();
	    for (i = 0; i < sel_points.length; i++) {
	      var pt = sel_points[i];
	      var seriesData = labelToSeries[pt.name];
	      seriesData.y = pt.yval;

	      if (pt.yval === 0 && !showZeros || isNaN(pt.canvasy)) {
	        seriesData.isVisible = false;
	        continue;
	      }

	      var series = g.getPropertiesForSeries(pt.name);
	      var yOptView = yOptViews[series.axis - 1];
	      var fmtFunc = yOptView('valueFormatter');
	      var yHTML = fmtFunc.call(g, pt.yval, yOptView, pt.name, g, row, labels.indexOf(pt.name));

	      utils.update(seriesData, { yHTML: yHTML });

	      if (pt.name == highlightSeries) {
	        seriesData.isHighlighted = true;
	      }
	    }
	  }

	  var formatter = g.getOption('legendFormatter') || Legend.defaultFormatter;
	  return formatter.call(g, data);
	};

	Legend.defaultFormatter = function (data) {
	  var g = data.dygraph;

	  // TODO(danvk): deprecate this option in place of {legend: 'never'}
	  // XXX should this logic be in the formatter?
	  if (g.getOption('showLabelsOnHighlight') !== true) return '';

	  var sepLines = g.getOption('labelsSeparateLines');
	  var html;

	  if (typeof data.x === 'undefined') {
	    // TODO: this check is duplicated in generateLegendHTML. Put it in one place.
	    if (g.getOption('legend') != 'always') {
	      return '';
	    }

	    html = '';
	    for (var i = 0; i < data.series.length; i++) {
	      var series = data.series[i];
	      if (!series.isVisible) continue;

	      if (html !== '') html += sepLines ? '<br/>' : ' ';
	      html += "<span style='font-weight: bold; color: " + series.color + ";'>" + series.dashHTML + " " + series.labelHTML + "</span>";
	    }
	    return html;
	  }

	  html = data.xHTML + ':';
	  for (var i = 0; i < data.series.length; i++) {
	    var series = data.series[i];
	    if (!series.isVisible) continue;
	    if (sepLines) html += '<br>';
	    var cls = series.isHighlighted ? ' class="highlight"' : '';
	    html += "<span" + cls + "> <b><span style='color: " + series.color + ";'>" + series.labelHTML + "</span></b>:&#160;" + series.yHTML + "</span>";
	  }
	  return html;
	};

	/**
	 * Generates html for the "dash" displayed on the legend when using "legend: always".
	 * In particular, this works for dashed lines with any stroke pattern. It will
	 * try to scale the pattern to fit in 1em width. Or if small enough repeat the
	 * pattern for 1em width.
	 *
	 * @param strokePattern The pattern
	 * @param color The color of the series.
	 * @param oneEmWidth The width in pixels of 1em in the legend.
	 * @private
	 */
	// TODO(danvk): cache the results of this
	function generateLegendDashHTML(strokePattern, color, oneEmWidth) {
	  // Easy, common case: a solid line
	  if (!strokePattern || strokePattern.length <= 1) {
	    return "<div class=\"dygraph-legend-line\" style=\"border-bottom-color: " + color + ";\"></div>";
	  }

	  var i, j, paddingLeft, marginRight;
	  var strokePixelLength = 0,
	      segmentLoop = 0;
	  var normalizedPattern = [];
	  var loop;

	  // Compute the length of the pixels including the first segment twice,
	  // since we repeat it.
	  for (i = 0; i <= strokePattern.length; i++) {
	    strokePixelLength += strokePattern[i % strokePattern.length];
	  }

	  // See if we can loop the pattern by itself at least twice.
	  loop = Math.floor(oneEmWidth / (strokePixelLength - strokePattern[0]));
	  if (loop > 1) {
	    // This pattern fits at least two times, no scaling just convert to em;
	    for (i = 0; i < strokePattern.length; i++) {
	      normalizedPattern[i] = strokePattern[i] / oneEmWidth;
	    }
	    // Since we are repeating the pattern, we don't worry about repeating the
	    // first segment in one draw.
	    segmentLoop = normalizedPattern.length;
	  } else {
	    // If the pattern doesn't fit in the legend we scale it to fit.
	    loop = 1;
	    for (i = 0; i < strokePattern.length; i++) {
	      normalizedPattern[i] = strokePattern[i] / strokePixelLength;
	    }
	    // For the scaled patterns we do redraw the first segment.
	    segmentLoop = normalizedPattern.length + 1;
	  }

	  // Now make the pattern.
	  var dash = "";
	  for (j = 0; j < loop; j++) {
	    for (i = 0; i < segmentLoop; i += 2) {
	      // The padding is the drawn segment.
	      paddingLeft = normalizedPattern[i % normalizedPattern.length];
	      if (i < strokePattern.length) {
	        // The margin is the space segment.
	        marginRight = normalizedPattern[(i + 1) % normalizedPattern.length];
	      } else {
	        // The repeated first segment has no right margin.
	        marginRight = 0;
	      }
	      dash += "<div class=\"dygraph-legend-dash\" style=\"margin-right: " + marginRight + "em; padding-left: " + paddingLeft + "em;\"></div>";
	    }
	  }
	  return dash;
	};

	exports["default"] = Legend;
	module.exports = exports["default"];

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2011 Paul Felix (paul.eric.felix@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */
	/*global Dygraph:false,TouchEvent:false */

	/**
	 * @fileoverview This file contains the RangeSelector plugin used to provide
	 * a timeline range selector widget for dygraphs.
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

	var _dygraphUtils = __webpack_require__(166);

	var utils = _interopRequireWildcard(_dygraphUtils);

	var _dygraphInteractionModel = __webpack_require__(171);

	var _dygraphInteractionModel2 = _interopRequireDefault(_dygraphInteractionModel);

	var _iframeTarp = __webpack_require__(173);

	var _iframeTarp2 = _interopRequireDefault(_iframeTarp);

	var rangeSelector = function rangeSelector() {
	  this.hasTouchInterface_ = typeof TouchEvent != 'undefined';
	  this.isMobileDevice_ = /mobile|android/gi.test(navigator.appVersion);
	  this.interfaceCreated_ = false;
	};

	rangeSelector.prototype.toString = function () {
	  return "RangeSelector Plugin";
	};

	rangeSelector.prototype.activate = function (dygraph) {
	  this.dygraph_ = dygraph;
	  if (this.getOption_('showRangeSelector')) {
	    this.createInterface_();
	  }
	  return {
	    layout: this.reserveSpace_,
	    predraw: this.renderStaticLayer_,
	    didDrawChart: this.renderInteractiveLayer_
	  };
	};

	rangeSelector.prototype.destroy = function () {
	  this.bgcanvas_ = null;
	  this.fgcanvas_ = null;
	  this.leftZoomHandle_ = null;
	  this.rightZoomHandle_ = null;
	};

	//------------------------------------------------------------------
	// Private methods
	//------------------------------------------------------------------

	rangeSelector.prototype.getOption_ = function (name, opt_series) {
	  return this.dygraph_.getOption(name, opt_series);
	};

	rangeSelector.prototype.setDefaultOption_ = function (name, value) {
	  this.dygraph_.attrs_[name] = value;
	};

	/**
	 * @private
	 * Creates the range selector elements and adds them to the graph.
	 */
	rangeSelector.prototype.createInterface_ = function () {
	  this.createCanvases_();
	  this.createZoomHandles_();
	  this.initInteraction_();

	  // Range selector and animatedZooms have a bad interaction. See issue 359.
	  if (this.getOption_('animatedZooms')) {
	    console.warn('Animated zooms and range selector are not compatible; disabling animatedZooms.');
	    this.dygraph_.updateOptions({ animatedZooms: false }, true);
	  }

	  this.interfaceCreated_ = true;
	  this.addToGraph_();
	};

	/**
	 * @private
	 * Adds the range selector to the graph.
	 */
	rangeSelector.prototype.addToGraph_ = function () {
	  var graphDiv = this.graphDiv_ = this.dygraph_.graphDiv;
	  graphDiv.appendChild(this.bgcanvas_);
	  graphDiv.appendChild(this.fgcanvas_);
	  graphDiv.appendChild(this.leftZoomHandle_);
	  graphDiv.appendChild(this.rightZoomHandle_);
	};

	/**
	 * @private
	 * Removes the range selector from the graph.
	 */
	rangeSelector.prototype.removeFromGraph_ = function () {
	  var graphDiv = this.graphDiv_;
	  graphDiv.removeChild(this.bgcanvas_);
	  graphDiv.removeChild(this.fgcanvas_);
	  graphDiv.removeChild(this.leftZoomHandle_);
	  graphDiv.removeChild(this.rightZoomHandle_);
	  this.graphDiv_ = null;
	};

	/**
	 * @private
	 * Called by Layout to allow range selector to reserve its space.
	 */
	rangeSelector.prototype.reserveSpace_ = function (e) {
	  if (this.getOption_('showRangeSelector')) {
	    e.reserveSpaceBottom(this.getOption_('rangeSelectorHeight') + 4);
	  }
	};

	/**
	 * @private
	 * Renders the static portion of the range selector at the predraw stage.
	 */
	rangeSelector.prototype.renderStaticLayer_ = function () {
	  if (!this.updateVisibility_()) {
	    return;
	  }
	  this.resize_();
	  this.drawStaticLayer_();
	};

	/**
	 * @private
	 * Renders the interactive portion of the range selector after the chart has been drawn.
	 */
	rangeSelector.prototype.renderInteractiveLayer_ = function () {
	  if (!this.updateVisibility_() || this.isChangingRange_) {
	    return;
	  }
	  this.placeZoomHandles_();
	  this.drawInteractiveLayer_();
	};

	/**
	 * @private
	 * Check to see if the range selector is enabled/disabled and update visibility accordingly.
	 */
	rangeSelector.prototype.updateVisibility_ = function () {
	  var enabled = this.getOption_('showRangeSelector');
	  if (enabled) {
	    if (!this.interfaceCreated_) {
	      this.createInterface_();
	    } else if (!this.graphDiv_ || !this.graphDiv_.parentNode) {
	      this.addToGraph_();
	    }
	  } else if (this.graphDiv_) {
	    this.removeFromGraph_();
	    var dygraph = this.dygraph_;
	    setTimeout(function () {
	      dygraph.width_ = 0;dygraph.resize();
	    }, 1);
	  }
	  return enabled;
	};

	/**
	 * @private
	 * Resizes the range selector.
	 */
	rangeSelector.prototype.resize_ = function () {
	  function setElementRect(canvas, context, rect) {
	    var canvasScale = utils.getContextPixelRatio(context);

	    canvas.style.top = rect.y + 'px';
	    canvas.style.left = rect.x + 'px';
	    canvas.width = rect.w * canvasScale;
	    canvas.height = rect.h * canvasScale;
	    canvas.style.width = rect.w + 'px';
	    canvas.style.height = rect.h + 'px';

	    if (canvasScale != 1) {
	      context.scale(canvasScale, canvasScale);
	    }
	  }

	  var plotArea = this.dygraph_.layout_.getPlotArea();

	  var xAxisLabelHeight = 0;
	  if (this.dygraph_.getOptionForAxis('drawAxis', 'x')) {
	    xAxisLabelHeight = this.getOption_('xAxisHeight') || this.getOption_('axisLabelFontSize') + 2 * this.getOption_('axisTickSize');
	  }
	  this.canvasRect_ = {
	    x: plotArea.x,
	    y: plotArea.y + plotArea.h + xAxisLabelHeight + 4,
	    w: plotArea.w,
	    h: this.getOption_('rangeSelectorHeight')
	  };

	  setElementRect(this.bgcanvas_, this.bgcanvas_ctx_, this.canvasRect_);
	  setElementRect(this.fgcanvas_, this.fgcanvas_ctx_, this.canvasRect_);
	};

	/**
	 * @private
	 * Creates the background and foreground canvases.
	 */
	rangeSelector.prototype.createCanvases_ = function () {
	  this.bgcanvas_ = utils.createCanvas();
	  this.bgcanvas_.className = 'dygraph-rangesel-bgcanvas';
	  this.bgcanvas_.style.position = 'absolute';
	  this.bgcanvas_.style.zIndex = 9;
	  this.bgcanvas_ctx_ = utils.getContext(this.bgcanvas_);

	  this.fgcanvas_ = utils.createCanvas();
	  this.fgcanvas_.className = 'dygraph-rangesel-fgcanvas';
	  this.fgcanvas_.style.position = 'absolute';
	  this.fgcanvas_.style.zIndex = 9;
	  this.fgcanvas_.style.cursor = 'default';
	  this.fgcanvas_ctx_ = utils.getContext(this.fgcanvas_);
	};

	/**
	 * @private
	 * Creates the zoom handle elements.
	 */
	rangeSelector.prototype.createZoomHandles_ = function () {
	  var img = new Image();
	  img.className = 'dygraph-rangesel-zoomhandle';
	  img.style.position = 'absolute';
	  img.style.zIndex = 10;
	  img.style.visibility = 'hidden'; // Initially hidden so they don't show up in the wrong place.
	  img.style.cursor = 'col-resize';
	  // TODO: change image to more options
	  img.width = 9;
	  img.height = 16;
	  img.src = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAAAkAAAAQCAYAAADESFVDAAAAAXNSR0IArs4c6QAAAAZiS0dEANAA' + 'zwDP4Z7KegAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB9sHGw0cMqdt1UwAAAAZdEVYdENv' + 'bW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAaElEQVQoz+3SsRFAQBCF4Z9WJM8KCDVwownl' + '6YXsTmCUsyKGkZzcl7zkz3YLkypgAnreFmDEpHkIwVOMfpdi9CEEN2nGpFdwD03yEqDtOgCaun7s' + 'qSTDH32I1pQA2Pb9sZecAxc5r3IAb21d6878xsAAAAAASUVORK5CYII=';

	  if (this.isMobileDevice_) {
	    img.width *= 2;
	    img.height *= 2;
	  }

	  this.leftZoomHandle_ = img;
	  this.rightZoomHandle_ = img.cloneNode(false);
	};

	/**
	 * @private
	 * Sets up the interaction for the range selector.
	 */
	rangeSelector.prototype.initInteraction_ = function () {
	  var self = this;
	  var topElem = document;
	  var clientXLast = 0;
	  var handle = null;
	  var isZooming = false;
	  var isPanning = false;
	  var dynamic = !this.isMobileDevice_;

	  // We cover iframes during mouse interactions. See comments in
	  // dygraph-utils.js for more info on why this is a good idea.
	  var tarp = new _iframeTarp2['default']();

	  // functions, defined below.  Defining them this way (rather than with
	  // "function foo() {...}" makes JSHint happy.
	  var toXDataWindow, onZoomStart, onZoom, onZoomEnd, doZoom, isMouseInPanZone, onPanStart, onPan, onPanEnd, doPan, onCanvasHover;

	  // Touch event functions
	  var onZoomHandleTouchEvent, onCanvasTouchEvent, addTouchEvents;

	  toXDataWindow = function (zoomHandleStatus) {
	    var xDataLimits = self.dygraph_.xAxisExtremes();
	    var fact = (xDataLimits[1] - xDataLimits[0]) / self.canvasRect_.w;
	    var xDataMin = xDataLimits[0] + (zoomHandleStatus.leftHandlePos - self.canvasRect_.x) * fact;
	    var xDataMax = xDataLimits[0] + (zoomHandleStatus.rightHandlePos - self.canvasRect_.x) * fact;
	    return [xDataMin, xDataMax];
	  };

	  onZoomStart = function (e) {
	    utils.cancelEvent(e);
	    isZooming = true;
	    clientXLast = e.clientX;
	    handle = e.target ? e.target : e.srcElement;
	    if (e.type === 'mousedown' || e.type === 'dragstart') {
	      // These events are removed manually.
	      utils.addEvent(topElem, 'mousemove', onZoom);
	      utils.addEvent(topElem, 'mouseup', onZoomEnd);
	    }
	    self.fgcanvas_.style.cursor = 'col-resize';
	    tarp.cover();
	    return true;
	  };

	  onZoom = function (e) {
	    if (!isZooming) {
	      return false;
	    }
	    utils.cancelEvent(e);

	    var delX = e.clientX - clientXLast;
	    if (Math.abs(delX) < 4) {
	      return true;
	    }
	    clientXLast = e.clientX;

	    // Move handle.
	    var zoomHandleStatus = self.getZoomHandleStatus_();
	    var newPos;
	    if (handle == self.leftZoomHandle_) {
	      newPos = zoomHandleStatus.leftHandlePos + delX;
	      newPos = Math.min(newPos, zoomHandleStatus.rightHandlePos - handle.width - 3);
	      newPos = Math.max(newPos, self.canvasRect_.x);
	    } else {
	      newPos = zoomHandleStatus.rightHandlePos + delX;
	      newPos = Math.min(newPos, self.canvasRect_.x + self.canvasRect_.w);
	      newPos = Math.max(newPos, zoomHandleStatus.leftHandlePos + handle.width + 3);
	    }
	    var halfHandleWidth = handle.width / 2;
	    handle.style.left = newPos - halfHandleWidth + 'px';
	    self.drawInteractiveLayer_();

	    // Zoom on the fly.
	    if (dynamic) {
	      doZoom();
	    }
	    return true;
	  };

	  onZoomEnd = function (e) {
	    if (!isZooming) {
	      return false;
	    }
	    isZooming = false;
	    tarp.uncover();
	    utils.removeEvent(topElem, 'mousemove', onZoom);
	    utils.removeEvent(topElem, 'mouseup', onZoomEnd);
	    self.fgcanvas_.style.cursor = 'default';

	    // If on a slower device, zoom now.
	    if (!dynamic) {
	      doZoom();
	    }
	    return true;
	  };

	  doZoom = function () {
	    try {
	      var zoomHandleStatus = self.getZoomHandleStatus_();
	      self.isChangingRange_ = true;
	      if (!zoomHandleStatus.isZoomed) {
	        self.dygraph_.resetZoom();
	      } else {
	        var xDataWindow = toXDataWindow(zoomHandleStatus);
	        self.dygraph_.doZoomXDates_(xDataWindow[0], xDataWindow[1]);
	      }
	    } finally {
	      self.isChangingRange_ = false;
	    }
	  };

	  isMouseInPanZone = function (e) {
	    var rect = self.leftZoomHandle_.getBoundingClientRect();
	    var leftHandleClientX = rect.left + rect.width / 2;
	    rect = self.rightZoomHandle_.getBoundingClientRect();
	    var rightHandleClientX = rect.left + rect.width / 2;
	    return e.clientX > leftHandleClientX && e.clientX < rightHandleClientX;
	  };

	  onPanStart = function (e) {
	    if (!isPanning && isMouseInPanZone(e) && self.getZoomHandleStatus_().isZoomed) {
	      utils.cancelEvent(e);
	      isPanning = true;
	      clientXLast = e.clientX;
	      if (e.type === 'mousedown') {
	        // These events are removed manually.
	        utils.addEvent(topElem, 'mousemove', onPan);
	        utils.addEvent(topElem, 'mouseup', onPanEnd);
	      }
	      return true;
	    }
	    return false;
	  };

	  onPan = function (e) {
	    if (!isPanning) {
	      return false;
	    }
	    utils.cancelEvent(e);

	    var delX = e.clientX - clientXLast;
	    if (Math.abs(delX) < 4) {
	      return true;
	    }
	    clientXLast = e.clientX;

	    // Move range view
	    var zoomHandleStatus = self.getZoomHandleStatus_();
	    var leftHandlePos = zoomHandleStatus.leftHandlePos;
	    var rightHandlePos = zoomHandleStatus.rightHandlePos;
	    var rangeSize = rightHandlePos - leftHandlePos;
	    if (leftHandlePos + delX <= self.canvasRect_.x) {
	      leftHandlePos = self.canvasRect_.x;
	      rightHandlePos = leftHandlePos + rangeSize;
	    } else if (rightHandlePos + delX >= self.canvasRect_.x + self.canvasRect_.w) {
	      rightHandlePos = self.canvasRect_.x + self.canvasRect_.w;
	      leftHandlePos = rightHandlePos - rangeSize;
	    } else {
	      leftHandlePos += delX;
	      rightHandlePos += delX;
	    }
	    var halfHandleWidth = self.leftZoomHandle_.width / 2;
	    self.leftZoomHandle_.style.left = leftHandlePos - halfHandleWidth + 'px';
	    self.rightZoomHandle_.style.left = rightHandlePos - halfHandleWidth + 'px';
	    self.drawInteractiveLayer_();

	    // Do pan on the fly.
	    if (dynamic) {
	      doPan();
	    }
	    return true;
	  };

	  onPanEnd = function (e) {
	    if (!isPanning) {
	      return false;
	    }
	    isPanning = false;
	    utils.removeEvent(topElem, 'mousemove', onPan);
	    utils.removeEvent(topElem, 'mouseup', onPanEnd);
	    // If on a slower device, do pan now.
	    if (!dynamic) {
	      doPan();
	    }
	    return true;
	  };

	  doPan = function () {
	    try {
	      self.isChangingRange_ = true;
	      self.dygraph_.dateWindow_ = toXDataWindow(self.getZoomHandleStatus_());
	      self.dygraph_.drawGraph_(false);
	    } finally {
	      self.isChangingRange_ = false;
	    }
	  };

	  onCanvasHover = function (e) {
	    if (isZooming || isPanning) {
	      return;
	    }
	    var cursor = isMouseInPanZone(e) ? 'move' : 'default';
	    if (cursor != self.fgcanvas_.style.cursor) {
	      self.fgcanvas_.style.cursor = cursor;
	    }
	  };

	  onZoomHandleTouchEvent = function (e) {
	    if (e.type == 'touchstart' && e.targetTouches.length == 1) {
	      if (onZoomStart(e.targetTouches[0])) {
	        utils.cancelEvent(e);
	      }
	    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {
	      if (onZoom(e.targetTouches[0])) {
	        utils.cancelEvent(e);
	      }
	    } else {
	      onZoomEnd(e);
	    }
	  };

	  onCanvasTouchEvent = function (e) {
	    if (e.type == 'touchstart' && e.targetTouches.length == 1) {
	      if (onPanStart(e.targetTouches[0])) {
	        utils.cancelEvent(e);
	      }
	    } else if (e.type == 'touchmove' && e.targetTouches.length == 1) {
	      if (onPan(e.targetTouches[0])) {
	        utils.cancelEvent(e);
	      }
	    } else {
	      onPanEnd(e);
	    }
	  };

	  addTouchEvents = function (elem, fn) {
	    var types = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];
	    for (var i = 0; i < types.length; i++) {
	      self.dygraph_.addAndTrackEvent(elem, types[i], fn);
	    }
	  };

	  this.setDefaultOption_('interactionModel', _dygraphInteractionModel2['default'].dragIsPanInteractionModel);
	  this.setDefaultOption_('panEdgeFraction', 0.0001);

	  var dragStartEvent = window.opera ? 'mousedown' : 'dragstart';
	  this.dygraph_.addAndTrackEvent(this.leftZoomHandle_, dragStartEvent, onZoomStart);
	  this.dygraph_.addAndTrackEvent(this.rightZoomHandle_, dragStartEvent, onZoomStart);

	  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousedown', onPanStart);
	  this.dygraph_.addAndTrackEvent(this.fgcanvas_, 'mousemove', onCanvasHover);

	  // Touch events
	  if (this.hasTouchInterface_) {
	    addTouchEvents(this.leftZoomHandle_, onZoomHandleTouchEvent);
	    addTouchEvents(this.rightZoomHandle_, onZoomHandleTouchEvent);
	    addTouchEvents(this.fgcanvas_, onCanvasTouchEvent);
	  }
	};

	/**
	 * @private
	 * Draws the static layer in the background canvas.
	 */
	rangeSelector.prototype.drawStaticLayer_ = function () {
	  var ctx = this.bgcanvas_ctx_;
	  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);
	  try {
	    this.drawMiniPlot_();
	  } catch (ex) {
	    console.warn(ex);
	  }

	  var margin = 0.5;
	  this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorBackgroundLineWidth');
	  ctx.strokeStyle = this.getOption_('rangeSelectorBackgroundStrokeColor');
	  ctx.beginPath();
	  ctx.moveTo(margin, margin);
	  ctx.lineTo(margin, this.canvasRect_.h - margin);
	  ctx.lineTo(this.canvasRect_.w - margin, this.canvasRect_.h - margin);
	  ctx.lineTo(this.canvasRect_.w - margin, margin);
	  ctx.stroke();
	};

	/**
	 * @private
	 * Draws the mini plot in the background canvas.
	 */
	rangeSelector.prototype.drawMiniPlot_ = function () {
	  var fillStyle = this.getOption_('rangeSelectorPlotFillColor');
	  var fillGradientStyle = this.getOption_('rangeSelectorPlotFillGradientColor');
	  var strokeStyle = this.getOption_('rangeSelectorPlotStrokeColor');
	  if (!fillStyle && !strokeStyle) {
	    return;
	  }

	  var stepPlot = this.getOption_('stepPlot');

	  var combinedSeriesData = this.computeCombinedSeriesAndLimits_();
	  var yRange = combinedSeriesData.yMax - combinedSeriesData.yMin;

	  // Draw the mini plot.
	  var ctx = this.bgcanvas_ctx_;
	  var margin = 0.5;

	  var xExtremes = this.dygraph_.xAxisExtremes();
	  var xRange = Math.max(xExtremes[1] - xExtremes[0], 1.e-30);
	  var xFact = (this.canvasRect_.w - margin) / xRange;
	  var yFact = (this.canvasRect_.h - margin) / yRange;
	  var canvasWidth = this.canvasRect_.w - margin;
	  var canvasHeight = this.canvasRect_.h - margin;

	  var prevX = null,
	      prevY = null;

	  ctx.beginPath();
	  ctx.moveTo(margin, canvasHeight);
	  for (var i = 0; i < combinedSeriesData.data.length; i++) {
	    var dataPoint = combinedSeriesData.data[i];
	    var x = dataPoint[0] !== null ? (dataPoint[0] - xExtremes[0]) * xFact : NaN;
	    var y = dataPoint[1] !== null ? canvasHeight - (dataPoint[1] - combinedSeriesData.yMin) * yFact : NaN;

	    // Skip points that don't change the x-value. Overly fine-grained points
	    // can cause major slowdowns with the ctx.fill() call below.
	    if (!stepPlot && prevX !== null && Math.round(x) == Math.round(prevX)) {
	      continue;
	    }

	    if (isFinite(x) && isFinite(y)) {
	      if (prevX === null) {
	        ctx.lineTo(x, canvasHeight);
	      } else if (stepPlot) {
	        ctx.lineTo(x, prevY);
	      }
	      ctx.lineTo(x, y);
	      prevX = x;
	      prevY = y;
	    } else {
	      if (prevX !== null) {
	        if (stepPlot) {
	          ctx.lineTo(x, prevY);
	          ctx.lineTo(x, canvasHeight);
	        } else {
	          ctx.lineTo(prevX, canvasHeight);
	        }
	      }
	      prevX = prevY = null;
	    }
	  }
	  ctx.lineTo(canvasWidth, canvasHeight);
	  ctx.closePath();

	  if (fillStyle) {
	    var lingrad = this.bgcanvas_ctx_.createLinearGradient(0, 0, 0, canvasHeight);
	    if (fillGradientStyle) {
	      lingrad.addColorStop(0, fillGradientStyle);
	    }
	    lingrad.addColorStop(1, fillStyle);
	    this.bgcanvas_ctx_.fillStyle = lingrad;
	    ctx.fill();
	  }

	  if (strokeStyle) {
	    this.bgcanvas_ctx_.strokeStyle = strokeStyle;
	    this.bgcanvas_ctx_.lineWidth = this.getOption_('rangeSelectorPlotLineWidth');
	    ctx.stroke();
	  }
	};

	/**
	 * @private
	 * Computes and returns the combined series data along with min/max for the mini plot.
	 * The combined series consists of averaged values for all series.
	 * When series have error bars, the error bars are ignored.
	 * @return {Object} An object containing combined series array, ymin, ymax.
	 */
	rangeSelector.prototype.computeCombinedSeriesAndLimits_ = function () {
	  var g = this.dygraph_;
	  var logscale = this.getOption_('logscale');
	  var i;

	  // Select series to combine. By default, all series are combined.
	  var numColumns = g.numColumns();
	  var labels = g.getLabels();
	  var includeSeries = new Array(numColumns);
	  var anySet = false;
	  var visibility = g.visibility();
	  var inclusion = [];

	  for (i = 1; i < numColumns; i++) {
	    var include = this.getOption_('showInRangeSelector', labels[i]);
	    inclusion.push(include);
	    if (include !== null) anySet = true; // it's set explicitly for this series
	  }

	  if (anySet) {
	    for (i = 1; i < numColumns; i++) {
	      includeSeries[i] = inclusion[i - 1];
	    }
	  } else {
	    for (i = 1; i < numColumns; i++) {
	      includeSeries[i] = visibility[i - 1];
	    }
	  }

	  // Create a combined series (average of selected series values).
	  // TODO(danvk): short-circuit if there's only one series.
	  var rolledSeries = [];
	  var dataHandler = g.dataHandler_;
	  var options = g.attributes_;
	  for (i = 1; i < g.numColumns(); i++) {
	    if (!includeSeries[i]) continue;
	    var series = dataHandler.extractSeries(g.rawData_, i, options);
	    if (g.rollPeriod() > 1) {
	      series = dataHandler.rollingAverage(series, g.rollPeriod(), options);
	    }

	    rolledSeries.push(series);
	  }

	  var combinedSeries = [];
	  for (i = 0; i < rolledSeries[0].length; i++) {
	    var sum = 0;
	    var count = 0;
	    for (var j = 0; j < rolledSeries.length; j++) {
	      var y = rolledSeries[j][i][1];
	      if (y === null || isNaN(y)) continue;
	      count++;
	      sum += y;
	    }
	    combinedSeries.push([rolledSeries[0][i][0], sum / count]);
	  }

	  // Compute the y range.
	  var yMin = Number.MAX_VALUE;
	  var yMax = -Number.MAX_VALUE;
	  for (i = 0; i < combinedSeries.length; i++) {
	    var yVal = combinedSeries[i][1];
	    if (yVal !== null && isFinite(yVal) && (!logscale || yVal > 0)) {
	      yMin = Math.min(yMin, yVal);
	      yMax = Math.max(yMax, yVal);
	    }
	  }

	  // Convert Y data to log scale if needed.
	  // Also, expand the Y range to compress the mini plot a little.
	  var extraPercent = 0.25;
	  if (logscale) {
	    yMax = utils.log10(yMax);
	    yMax += yMax * extraPercent;
	    yMin = utils.log10(yMin);
	    for (i = 0; i < combinedSeries.length; i++) {
	      combinedSeries[i][1] = utils.log10(combinedSeries[i][1]);
	    }
	  } else {
	    var yExtra;
	    var yRange = yMax - yMin;
	    if (yRange <= Number.MIN_VALUE) {
	      yExtra = yMax * extraPercent;
	    } else {
	      yExtra = yRange * extraPercent;
	    }
	    yMax += yExtra;
	    yMin -= yExtra;
	  }

	  return { data: combinedSeries, yMin: yMin, yMax: yMax };
	};

	/**
	 * @private
	 * Places the zoom handles in the proper position based on the current X data window.
	 */
	rangeSelector.prototype.placeZoomHandles_ = function () {
	  var xExtremes = this.dygraph_.xAxisExtremes();
	  var xWindowLimits = this.dygraph_.xAxisRange();
	  var xRange = xExtremes[1] - xExtremes[0];
	  var leftPercent = Math.max(0, (xWindowLimits[0] - xExtremes[0]) / xRange);
	  var rightPercent = Math.max(0, (xExtremes[1] - xWindowLimits[1]) / xRange);
	  var leftCoord = this.canvasRect_.x + this.canvasRect_.w * leftPercent;
	  var rightCoord = this.canvasRect_.x + this.canvasRect_.w * (1 - rightPercent);
	  var handleTop = Math.max(this.canvasRect_.y, this.canvasRect_.y + (this.canvasRect_.h - this.leftZoomHandle_.height) / 2);
	  var halfHandleWidth = this.leftZoomHandle_.width / 2;
	  this.leftZoomHandle_.style.left = leftCoord - halfHandleWidth + 'px';
	  this.leftZoomHandle_.style.top = handleTop + 'px';
	  this.rightZoomHandle_.style.left = rightCoord - halfHandleWidth + 'px';
	  this.rightZoomHandle_.style.top = this.leftZoomHandle_.style.top;

	  this.leftZoomHandle_.style.visibility = 'visible';
	  this.rightZoomHandle_.style.visibility = 'visible';
	};

	/**
	 * @private
	 * Draws the interactive layer in the foreground canvas.
	 */
	rangeSelector.prototype.drawInteractiveLayer_ = function () {
	  var ctx = this.fgcanvas_ctx_;
	  ctx.clearRect(0, 0, this.canvasRect_.w, this.canvasRect_.h);
	  var margin = 1;
	  var width = this.canvasRect_.w - margin;
	  var height = this.canvasRect_.h - margin;
	  var zoomHandleStatus = this.getZoomHandleStatus_();

	  ctx.strokeStyle = this.getOption_('rangeSelectorForegroundStrokeColor');
	  ctx.lineWidth = this.getOption_('rangeSelectorForegroundLineWidth');
	  if (!zoomHandleStatus.isZoomed) {
	    ctx.beginPath();
	    ctx.moveTo(margin, margin);
	    ctx.lineTo(margin, height);
	    ctx.lineTo(width, height);
	    ctx.lineTo(width, margin);
	    ctx.stroke();
	  } else {
	    var leftHandleCanvasPos = Math.max(margin, zoomHandleStatus.leftHandlePos - this.canvasRect_.x);
	    var rightHandleCanvasPos = Math.min(width, zoomHandleStatus.rightHandlePos - this.canvasRect_.x);

	    ctx.fillStyle = 'rgba(240, 240, 240, ' + this.getOption_('rangeSelectorAlpha').toString() + ')';
	    ctx.fillRect(0, 0, leftHandleCanvasPos, this.canvasRect_.h);
	    ctx.fillRect(rightHandleCanvasPos, 0, this.canvasRect_.w - rightHandleCanvasPos, this.canvasRect_.h);

	    ctx.beginPath();
	    ctx.moveTo(margin, margin);
	    ctx.lineTo(leftHandleCanvasPos, margin);
	    ctx.lineTo(leftHandleCanvasPos, height);
	    ctx.lineTo(rightHandleCanvasPos, height);
	    ctx.lineTo(rightHandleCanvasPos, margin);
	    ctx.lineTo(width, margin);
	    ctx.stroke();
	  }
	};

	/**
	 * @private
	 * Returns the current zoom handle position information.
	 * @return {Object} The zoom handle status.
	 */
	rangeSelector.prototype.getZoomHandleStatus_ = function () {
	  var halfHandleWidth = this.leftZoomHandle_.width / 2;
	  var leftHandlePos = parseFloat(this.leftZoomHandle_.style.left) + halfHandleWidth;
	  var rightHandlePos = parseFloat(this.rightZoomHandle_.style.left) + halfHandleWidth;
	  return {
	    leftHandlePos: leftHandlePos,
	    rightHandlePos: rightHandlePos,
	    isZoomed: leftHandlePos - 1 > this.canvasRect_.x || rightHandlePos + 1 < this.canvasRect_.x + this.canvasRect_.w
	  };
	};

	exports['default'] = rangeSelector;
	module.exports = exports['default'];

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * @license
	 * Copyright 2011 Dan Vanderkam (danvdk@gmail.com)
	 * MIT-licensed (http://opensource.org/licenses/MIT)
	 */

	/**
	 * @fileoverview A wrapper around the Dygraph class which implements the
	 * interface for a GViz (aka Google Visualization API) visualization.
	 * It is designed to be a drop-in replacement for Google's AnnotatedTimeline,
	 * so the documentation at
	 * http://code.google.com/apis/chart/interactive/docs/gallery/annotatedtimeline.html
	 * translates over directly.
	 *
	 * For a full demo, see:
	 * - http://dygraphs.com/tests/gviz.html
	 * - http://dygraphs.com/tests/annotation-gviz.html
	 */

	/*global Dygraph:false */
	"use strict";

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _dygraph = __webpack_require__(164);

	var _dygraph2 = _interopRequireDefault(_dygraph);

	/**
	 * A wrapper around Dygraph that implements the gviz API.
	 * @param {!HTMLDivElement} container The DOM object the visualization should
	 *     live in.
	 * @constructor
	 */
	var GVizChart = function GVizChart(container) {
	  this.container = container;
	};

	/**
	 * @param {GVizDataTable} data
	 * @param {Object.<*>} options
	 */
	GVizChart.prototype.draw = function (data, options) {
	  // Clear out any existing dygraph.
	  // TODO(danvk): would it make more sense to simply redraw using the current
	  // date_graph object?
	  this.container.innerHTML = '';
	  if (typeof this.date_graph != 'undefined') {
	    this.date_graph.destroy();
	  }

	  this.date_graph = new _dygraph2['default'](this.container, data, options);
	};

	/**
	 * Google charts compatible setSelection
	 * Only row selection is supported, all points in the row will be highlighted
	 * @param {Array.<{row:number}>} selection_array array of the selected cells
	 * @public
	 */
	GVizChart.prototype.setSelection = function (selection_array) {
	  var row = false;
	  if (selection_array.length) {
	    row = selection_array[0].row;
	  }
	  this.date_graph.setSelection(row);
	};

	/**
	 * Google charts compatible getSelection implementation
	 * @return {Array.<{row:number,column:number}>} array of the selected cells
	 * @public
	 */
	GVizChart.prototype.getSelection = function () {
	  var selection = [];

	  var row = this.date_graph.getSelection();

	  if (row < 0) return selection;

	  var points = this.date_graph.layout_.points;
	  for (var setIdx = 0; setIdx < points.length; ++setIdx) {
	    selection.push({ row: row, column: setIdx + 1 });
	  }

	  return selection;
	};

	exports['default'] = GVizChart;
	module.exports = exports['default'];

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ScriptNotification = exports.ScriptSelect = exports.ScriptLoadButton = exports.ScriptLoadModal = exports.ScriptExecCtrl = exports.ScriptEditor = exports.Scripts = undefined;

	var _codemirror = __webpack_require__(189);

	var CodeMirror = _interopRequireWildcard(_codemirror);

	var _map = __webpack_require__(146);

	var _map2 = _interopRequireDefault(_map);

	var _merge = __webpack_require__(190);

	var _merge2 = _interopRequireDefault(_merge);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	/**
	 * Multi-select input box that displays scripts provided by the backend REST
	 * API. When the user selects a value in the select box the component updates
	 * the ScriptSelectionData.selected attribute with the selected value.
	 */
	var ScriptSelect = {
	    scripts: [],
	    _filter_val: '',

	    oninit: function oninit(vnode) {
	        var _this = this;

	        m.request('/scripts').then(function (data) {
	            data = data.sort(function (a, b) {
	                if (a.indexOf('/') !== -1 && b.indexOf('/') !== -1) {
	                    return a < b ? -1 : 1;
	                } else if (a.indexOf('/') !== -1) {
	                    return -1;
	                } else if (b.indexOf('/') !== -1) {
	                    return 1;
	                }
	            });

	            _this.scripts = (0, _map2.default)(data, function (value, index) {
	                return m('option', { value: value, key: index }, value);
	            });
	        });
	    },
	    oncreate: function oncreate(vnode) {
	        var _this2 = this;

	        bliss.events.on('script:loaded', function () {
	            _this2._filter_val = '';
	            vnode.dom.elements['script-filter'].value = '';
	            vnode.dom.elements['script-select'].value = '';
	        });
	    },
	    view: function view(vnode) {
	        var _this3 = this;

	        var scriptDisplayList = this.scripts;
	        if (this._filter_val !== '') {
	            scriptDisplayList = this.scripts.filter(function (e) {
	                return e.attrs.value.indexOf(_this3._filter_val) !== -1;
	            });
	        }

	        var filterInputGroup = m('div', { class: 'form-group' }, [m('label', 'Filter Scripts'), m('div', {
	            class: 'input-group'
	        }, [m('input', {
	            class: 'form-control',
	            placeholder: 'Filter list ...',
	            name: 'script-filter',
	            oninput: function oninput(e) {
	                _this3._filter_val = e.currentTarget.value;
	            }
	        }, this._filter_val), m('div', { class: 'input-group-btn' }, m('button', {
	            class: 'btn btn-default',
	            type: 'button',
	            onmousedown: function onmousedown(e) {
	                var cur = e.currentTarget;
	                while (cur.parentElement && !cur.elements) {
	                    cur = cur.parentElement;
	                }
	                cur.elements['script-filter'].value = '';
	                _this3._filter_val = '';
	            }
	        }, m('span', { class: 'glyphicon glyphicon-remove-circle' })))])]);

	        var select = m('select', {
	            class: 'form-control',
	            name: 'script-select',
	            multiple: 'true',
	            onchange: function onchange(e) {
	                vnode.attrs.ScriptSelectionData.selected = e.currentTarget.value;
	                document.activeElement.blur();
	            }
	        }, scriptDisplayList);

	        return m('form', {
	            onsubmit: function onsubmit(e) {
	                e.preventDefault();
	                return false;
	            }
	        }, [filterInputGroup, select]);
	    }
	};

	/**
	 * Button component that handles user selected script loading.
	 *
	 * When the user clicks this button the script specified in the attribute
	 * `ScriptSelectionData.selected` is passed to the BLISS REST API for loading.
	 * The text returned from the loaded script is saved into the attribute
	 * `ScriptSelectionData.script_text`.
	 *
	 * The button is marked as disabled when `ScriptSelectionData.selected` is
	 * null.
	 */
	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	var ScriptLoadButton = {
	    view: function view(vnode) {
	        var btnAttrs = {
	            class: 'btn btn-success',
	            onclick: function onclick(e) {
	                var scriptName = encodeURIComponent(vnode.attrs.ScriptSelectionData.selected);
	                m.request('/scripts/load/' + encodeURIComponent(scriptName)).then(function (data) {
	                    vnode.attrs.ScriptSelectionData.scriptText = data.script_text;
	                    bliss.events.emit('script:loaded', null);
	                });
	            }
	        };

	        (0, _merge2.default)(btnAttrs, vnode.attrs);

	        if (vnode.attrs.ScriptSelectionData.selected === null) {
	            btnAttrs.disabled = 'disabled';
	        }

	        return m('bliss-scriptloadbutton', m('button', btnAttrs, 'Load'));
	    }
	};

	/**
	 * A modal that allows the user to view scripts and select one to load.
	 *
	 * This modal uses the ScriptSelect and ScriptLoadButton components.
	 *
	 * Script selection and text data is passed through this component via the
	 * `ScriptSelectionData` dictionary attribute. The `selected` and `script_text`
	 * elements store the relevant information for passing between the ScriptSelect
	 * and ScriptLoadButton components.
	 */
	var ScriptLoadModal = {
	    view: function view(vnode) {
	        var modalHeader = m('div', { class: 'modal-header' }, [m('button', {
	            class: 'close',
	            'data-dismiss': 'modal'
	        }, m('span', '\xD7')), m('h4', { class: 'modal-title' }, 'Load Sequence / Script')]);

	        var modalBody = m('div', { class: 'modal-body' }, m(ScriptSelect, { ScriptSelectionData: vnode.attrs.ScriptSelectionData }));

	        var modalFooter = m('div', { class: 'modal-footer' }, m(ScriptLoadButton, {
	            ScriptSelectionData: vnode.attrs.ScriptSelectionData,
	            'data-dismiss': 'modal'
	        }));

	        var scriptModal = m('div', {
	            class: 'modal fade',
	            tabindex: '-1',
	            role: 'dialog'
	        }, m('div', {
	            class: 'modal-dialog modal-lg',
	            role: 'document'
	        }, m('div', { class: 'modal-content' }, [modalHeader, modalBody, modalFooter])));

	        return m('bliss-scriptloadmodal', scriptModal);
	    }
	};

	/**
	 * Script execution control dashboard.
	 *
	 * This component allows the user to run a script that they've selected
	 * and loaded via the BLISS REST API. The script that the user has selected
	 * to run is passed into the component via the `ScriptSelectionData.selected`
	 * attribute. The function that the load button should perform when clicked is
	 * expected to be provided as the attribute `loadButtonAction`.
	 *
	 */
	var ScriptExecCtrl = {
	    oninit: function oninit(vnode) {
	        this._script_state = vnode.attrs.scriptState;
	    },
	    view: function view(vnode) {
	        var _this4 = this;

	        this._script_state = vnode.attrs.scriptState;

	        // Invert the script execution state to give us the button display
	        // classes / states
	        var btnDisplayState = vnode.attrs.scriptState === 'running' ? 'pause' : 'play';

	        var runBtnAttrs = {
	            class: 'btn glyphicon glyphicon-' + btnDisplayState,
	            onclick: function onclick(e) {
	                if (_this4._script_state === 'running') {
	                    m.request({
	                        method: 'PUT',
	                        url: '/script/pause'
	                    });
	                } else if (_this4._script_state === 'paused') {
	                    m.request({
	                        method: 'PUT',
	                        url: '/script/run'
	                    });
	                } else {
	                    if (vnode.attrs.ScriptSelectionData.selected !== null) {
	                        var data = new FormData();
	                        data.append('scriptPath', vnode.attrs.ScriptSelectionData.selected);
	                        m.request({
	                            method: 'POST',
	                            url: '/script/run',
	                            data: data
	                        });
	                    }
	                }
	            }

	            // The Run button should be disabled in situations where running doesn't
	            // make sense (init) or where it wouldn't be possible (error). When
	            // a script is running / paused we update the display to color it
	            // appropriately (default is black).
	        };if (vnode.attrs.scriptState === 'init' || vnode.attrs.scriptState === 'error') {
	            runBtnAttrs.disabled = 'disabled';
	        } else {
	            runBtnAttrs.class += ' .' + btnDisplayState;
	        }

	        var runButton = m('button', runBtnAttrs);

	        var stepForwardAttrs = {
	            class: 'btn glyphicon glyphicon-step-forward',
	            onclick: function onclick(e) {
	                e.target.setAttribute('disabled', 'disabled');
	                m.request({
	                    method: 'PUT',
	                    url: '/script/step'
	                }).then(function () {
	                    e.target.removeAttribute('disabled');
	                });
	            }
	        };

	        if (this._script_state !== 'paused') {
	            stepForwardAttrs['disabled'] = 'disabled';
	        }

	        var stepForwardButton = m('button', stepForwardAttrs);

	        var loadButton = m('button', {
	            class: 'btn glyphicon glyphicon-download-alt',
	            onclick: vnode.attrs.loadButtonAction
	        });

	        var abortAttrs = {
	            class: 'btn glyphicon glyphicon-ban-circle',
	            onclick: function onclick(e) {
	                e.target.setAttribute('disabled', 'disabled');
	                m.request({
	                    method: 'DELETE',
	                    url: '/script/abort'
	                }).then(function () {
	                    e.target.removeAttribute('disabled');
	                });
	            }
	        };

	        if (vnode.attrs.scriptState === 'init' || vnode.attrs.scriptState === 'stopped') {
	            abortAttrs['disabled'] = 'disabled';
	        }

	        var abortButton = m('button', abortAttrs);

	        var buttonDashboard = m('div', [runButton, stepForwardButton, abortButton, loadButton]);

	        return m('bliss-scriptexecctrl', buttonDashboard);
	    }
	};

	/**
	 * Handle loaded script display and realtime execution status
	 *
	 * Displays a loaded script via the CodeMirror library and displays
	 * current script line execution data along with execution state
	 * information. The current line marker provides information on
	 * the script execution state via color changes while pointing at the
	 * current line of the script that is executing.
	 *
	 * black arrow: Indicates the script is loaded and prepared to
	 *                execute at the marked line.
	 * green arrow: Indicates the script is running at the marked line
	 * red arrow:   Indicates an error occurred at the marked line. See
	 *              the log messages for information on the encountered
	 *              error.
	 */
	var ScriptEditor = {
	    _scrollState: null,

	    oninit: function oninit(vnode) {
	        this._marker = document.createElement('span');
	    },
	    oncreate: function oncreate(vnode) {
	        this._cm = CodeMirror.fromTextArea(vnode.dom.children[0].elements['scriptview'], {
	            lineNumbers: true,
	            lineWrapping: true,
	            readOnly: true,
	            gutters: ['codeMirrorExecGutter', 'CodeMirror-linenumbers']
	        });
	    },
	    onbeforeupdate: function onbeforeupdate(vnode) {
	        if (this._cm !== undefined) {
	            this._scrollState = this._cm.getScrollInfo();
	        }
	    },
	    view: function view(vnode) {
	        if (this._cm !== undefined) {
	            // Display the loaded script text in the editor
	            if (vnode.attrs.ScriptSelectionData.scriptText !== null) {
	                this._cm.setValue(vnode.attrs.ScriptSelectionData.scriptText);
	            }

	            // Handle the gutter marker display parameters once we have a script
	            // loaded (AKA, when we're out of the init state).
	            if (vnode.attrs.scriptState !== 'init') {
	                if (vnode.attrs.scriptState === 'paused') {
	                    this._marker.className = "glyphicon glyphicon-pause " + vnode.attrs.scriptState;
	                } else {
	                    this._marker.className = "glyphicon glyphicon-play " + vnode.attrs.scriptState;
	                }
	                this._cm.setGutterMarker(vnode.attrs.currentLine, 'codeMirrorExecGutter', this._marker);
	            }

	            if (vnode.attrs.scriptState === 'running') {
	                this._cm.scrollIntoView(vnode.attrs.currentLine);
	            } else {
	                this._cm.scrollTo(this._scrollState.left, this._scrollState.top);
	            }

	            this._cm.refresh();
	        }

	        var initHelpText = 'To load a script, click the Load Script button above.';
	        return m('bliss-scripteditor', m('form', m('textarea', { name: 'scriptview' }, initHelpText)));
	    }
	};

	var ScriptsState = {
	    execState: 'init',
	    scriptSelectData: {
	        selected: null,
	        scriptText: null
	    },
	    currentLine: 0
	};

	var ScriptNotification = {
	    oninit: function oninit(vnode) {
	        var _this5 = this;

	        this._state = 'none', this._script = '', bliss.events.on('script:loaded', function () {
	            _this5._state = 'loaded';
	            _this5._script = vnode.attrs.ScriptSelectionData.selected;
	            m.redraw();
	        });

	        bliss.events.on('script:start', function () {
	            _this5._state = 'loaded';
	            m.redraw();
	        });

	        bliss.events.on('script:done', function () {
	            _this5._state = 'done';
	            m.redraw();
	        });

	        bliss.events.on('script:error', function () {
	            _this5._state = 'error';
	            m.redraw();
	        });

	        bliss.events.on('script:aborted', function () {
	            _this5._state = 'aborted';
	            m.redraw();
	        });
	    },
	    view: function view(vnode) {
	        var msg = '';
	        var attrs = { role: 'alert' };

	        if (this._state === 'loaded') {
	            msg = ' loaded';
	        } else if (this._state === 'done') {
	            attrs['class'] = 'alert alert-success';
	            msg = ' finished execution';
	        } else if (this._state === 'error') {
	            attrs['class'] = 'alert alert-danger';
	            msg = ' encountered an error';
	        } else if (this._state === 'aborted') {
	            attrs['class'] = 'alert alert-warning';
	            msg = ' execution aborted';
	        }

	        if (msg !== '' && this._script) {
	            return m('bliss-scriptnotification', [m('div', attrs, [m('strong', 'Status: '), this._script + msg])]);
	        }
	    }
	};

	/**
	 * Manages global script states and component layout
	 */
	var Scripts = {
	    oninit: function oninit(vnode) {
	        var _this6 = this;

	        this._marker = document.createElement('span');
	        this._script_load_toggle = true;

	        bliss.events.on('script:start', function () {
	            ScriptsState.execState = 'running';
	        });

	        bliss.events.on('script:error', function (e) {
	            ScriptsState.execState = 'error';
	        });

	        bliss.events.on('script:pause', function (e) {
	            ScriptsState.execState = 'paused';
	        });

	        bliss.events.on('script:resume', function (e) {
	            ScriptsState.execState = 'running';
	        });

	        bliss.events.on('script:loaded', function (e) {
	            ScriptsState.execState = 'stopped';
	            _this6._script_load_toggle = !_this6._script_load_toggle;
	            ScriptsState.currentLine = 0;
	        });

	        bliss.events.on('script:step', function (lineNum) {
	            ScriptsState.currentLine = lineNum - 1;
	        });

	        bliss.events.on('script:done', function () {
	            ScriptsState.execState = 'stopped';
	            ScriptsState.currentLine = 0;
	        });

	        bliss.events.on('script:aborted', function () {
	            ScriptsState.execState = 'stopped';
	            ScriptsState.currentLine = 0;
	        });
	    },
	    view: function view(vnode) {
	        var _this7 = this;

	        var scriptLoad = m(ScriptSelect, { ScriptSelectionData: ScriptsState.scriptSelectData });

	        var scriptCtrl = m('div', { class: 'col-lg-12' }, m(ScriptExecCtrl, {
	            ScriptSelectionData: ScriptsState.scriptSelectData,
	            scriptState: ScriptsState.execState,
	            loadButtonAction: function loadButtonAction() {
	                _this7._script_load_toggle = !_this7._script_load_toggle;
	            }
	        }));
	        var notifications = m('div', { class: 'col-lg-12' }, m(ScriptNotification, {
	            ScriptSelectionData: ScriptsState.scriptSelectData
	        }));

	        var scriptEditor = m('div', { class: 'col-lg-12' }, m(ScriptEditor, {
	            ScriptSelectionData: ScriptsState.scriptSelectData,
	            scriptState: ScriptsState.execState,
	            currentLine: ScriptsState.currentLine
	        }));

	        var loadBlockAttrs = {};
	        if (this._script_load_toggle) {
	            loadBlockAttrs['class'] = 'load_dialog--hidden';
	        }

	        return m('bliss-script', m('div', [m('div', { class: 'row' }, scriptCtrl), m('div', { class: 'row' }, notifications), m('div', loadBlockAttrs, [m('div', { class: 'row' }, m('br')), m('div', { class: 'row' }, m('div', { class: 'col-lg-12' }, scriptLoad)), m('div', { class: 'row' }, m('div', { class: 'col-lg-1 col-lg-offset-11' }, [m('br'), m(ScriptLoadButton, {
	            ScriptSelectionData: ScriptsState.scriptSelectData
	        })])), m('div', { class: 'row' }, m('br'))]), m('div', { class: 'row' }, scriptEditor)]));
	    }
	};

	exports.default = { Scripts: Scripts, ScriptEditor: ScriptEditor, ScriptExecCtrl: ScriptExecCtrl, ScriptLoadModal: ScriptLoadModal, ScriptLoadButton: ScriptLoadButton, ScriptSelect: ScriptSelect, ScriptNotification: ScriptNotification };
	exports.Scripts = Scripts;
	exports.ScriptEditor = ScriptEditor;
	exports.ScriptExecCtrl = ScriptExecCtrl;
	exports.ScriptLoadModal = ScriptLoadModal;
	exports.ScriptLoadButton = ScriptLoadButton;
	exports.ScriptSelect = ScriptSelect;
	exports.ScriptNotification = ScriptNotification;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE

	// This is CodeMirror (http://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.CodeMirror = factory());
	}(this, (function () { 'use strict';

	// Kludges for bugs and behavior differences that can't be feature
	// detected are enabled based on userAgent etc sniffing.
	var userAgent = navigator.userAgent;
	var platform = navigator.platform;

	var gecko = /gecko\/\d/i.test(userAgent);
	var ie_upto10 = /MSIE \d/.test(userAgent);
	var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	var edge = /Edge\/(\d+)/.exec(userAgent);
	var ie = ie_upto10 || ie_11up || edge;
	var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
	var webkit = !edge && /WebKit\//.test(userAgent);
	var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	var chrome = !edge && /Chrome\//.test(userAgent);
	var presto = /Opera\//.test(userAgent);
	var safari = /Apple Computer/.test(navigator.vendor);
	var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	var phantom = /PhantomJS/.test(userAgent);

	var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
	var android = /Android/.test(userAgent);
	// This is woefully incomplete. Suggestions for alternative methods welcome.
	var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	var mac = ios || /Mac/.test(platform);
	var chromeOS = /\bCrOS\b/.test(userAgent);
	var windows = /win/i.test(platform);

	var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
	if (presto_version) { presto_version = Number(presto_version[1]); }
	if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	var captureRightClick = gecko || (ie && ie_version >= 9);

	function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

	var rmClass = function(node, cls) {
	  var current = node.className;
	  var match = classTest(cls).exec(current);
	  if (match) {
	    var after = current.slice(match.index + match[0].length);
	    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	  }
	};

	function removeChildren(e) {
	  for (var count = e.childNodes.length; count > 0; --count)
	    { e.removeChild(e.firstChild); }
	  return e
	}

	function removeChildrenAndAdd(parent, e) {
	  return removeChildren(parent).appendChild(e)
	}

	function elt(tag, content, className, style) {
	  var e = document.createElement(tag);
	  if (className) { e.className = className; }
	  if (style) { e.style.cssText = style; }
	  if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
	  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
	  return e
	}
	// wrapper for elt, which removes the elt from the accessibility tree
	function eltP(tag, content, className, style) {
	  var e = elt(tag, content, className, style);
	  e.setAttribute("role", "presentation");
	  return e
	}

	var range;
	if (document.createRange) { range = function(node, start, end, endNode) {
	  var r = document.createRange();
	  r.setEnd(endNode || node, end);
	  r.setStart(node, start);
	  return r
	}; }
	else { range = function(node, start, end) {
	  var r = document.body.createTextRange();
	  try { r.moveToElementText(node.parentNode); }
	  catch(e) { return r }
	  r.collapse(true);
	  r.moveEnd("character", end);
	  r.moveStart("character", start);
	  return r
	}; }

	function contains(parent, child) {
	  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	    { child = child.parentNode; }
	  if (parent.contains)
	    { return parent.contains(child) }
	  do {
	    if (child.nodeType == 11) { child = child.host; }
	    if (child == parent) { return true }
	  } while (child = child.parentNode)
	}

	function activeElt() {
	  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
	  // IE < 10 will throw when accessed while the page is loading or in an iframe.
	  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
	  var activeElement;
	  try {
	    activeElement = document.activeElement;
	  } catch(e) {
	    activeElement = document.body || null;
	  }
	  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
	    { activeElement = activeElement.shadowRoot.activeElement; }
	  return activeElement
	}

	function addClass(node, cls) {
	  var current = node.className;
	  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
	}
	function joinClasses(a, b) {
	  var as = a.split(" ");
	  for (var i = 0; i < as.length; i++)
	    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
	  return b
	}

	var selectInput = function(node) { node.select(); };
	if (ios) // Mobile Safari apparently has a bug where select() is broken.
	  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
	else if (ie) // Suppress mysterious IE10 errors
	  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

	function bind(f) {
	  var args = Array.prototype.slice.call(arguments, 1);
	  return function(){return f.apply(null, args)}
	}

	function copyObj(obj, target, overwrite) {
	  if (!target) { target = {}; }
	  for (var prop in obj)
	    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	      { target[prop] = obj[prop]; } }
	  return target
	}

	// Counts the column offset in a string, taking tabs into account.
	// Used mostly to find indentation.
	function countColumn(string, end, tabSize, startIndex, startValue) {
	  if (end == null) {
	    end = string.search(/[^\s\u00a0]/);
	    if (end == -1) { end = string.length; }
	  }
	  for (var i = startIndex || 0, n = startValue || 0;;) {
	    var nextTab = string.indexOf("\t", i);
	    if (nextTab < 0 || nextTab >= end)
	      { return n + (end - i) }
	    n += nextTab - i;
	    n += tabSize - (n % tabSize);
	    i = nextTab + 1;
	  }
	}

	var Delayed = function() {this.id = null;};
	Delayed.prototype.set = function (ms, f) {
	  clearTimeout(this.id);
	  this.id = setTimeout(f, ms);
	};

	function indexOf(array, elt) {
	  for (var i = 0; i < array.length; ++i)
	    { if (array[i] == elt) { return i } }
	  return -1
	}

	// Number of pixels added to scroller and sizer to hide scrollbar
	var scrollerGap = 30;

	// Returned or thrown by various protocols to signal 'I'm not
	// handling this'.
	var Pass = {toString: function(){return "CodeMirror.Pass"}};

	// Reused option objects for setSelection & friends
	var sel_dontScroll = {scroll: false};
	var sel_mouse = {origin: "*mouse"};
	var sel_move = {origin: "+move"};

	// The inverse of countColumn -- find the offset that corresponds to
	// a particular column.
	function findColumn(string, goal, tabSize) {
	  for (var pos = 0, col = 0;;) {
	    var nextTab = string.indexOf("\t", pos);
	    if (nextTab == -1) { nextTab = string.length; }
	    var skipped = nextTab - pos;
	    if (nextTab == string.length || col + skipped >= goal)
	      { return pos + Math.min(skipped, goal - col) }
	    col += nextTab - pos;
	    col += tabSize - (col % tabSize);
	    pos = nextTab + 1;
	    if (col >= goal) { return pos }
	  }
	}

	var spaceStrs = [""];
	function spaceStr(n) {
	  while (spaceStrs.length <= n)
	    { spaceStrs.push(lst(spaceStrs) + " "); }
	  return spaceStrs[n]
	}

	function lst(arr) { return arr[arr.length-1] }

	function map(array, f) {
	  var out = [];
	  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
	  return out
	}

	function insertSorted(array, value, score) {
	  var pos = 0, priority = score(value);
	  while (pos < array.length && score(array[pos]) <= priority) { pos++; }
	  array.splice(pos, 0, value);
	}

	function nothing() {}

	function createObj(base, props) {
	  var inst;
	  if (Object.create) {
	    inst = Object.create(base);
	  } else {
	    nothing.prototype = base;
	    inst = new nothing();
	  }
	  if (props) { copyObj(props, inst); }
	  return inst
	}

	var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	function isWordCharBasic(ch) {
	  return /\w/.test(ch) || ch > "\x80" &&
	    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
	}
	function isWordChar(ch, helper) {
	  if (!helper) { return isWordCharBasic(ch) }
	  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
	  return helper.test(ch)
	}

	function isEmpty(obj) {
	  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
	  return true
	}

	// Extending unicode characters. A series of a non-extending char +
	// any number of extending chars is treated as a single unit as far
	// as editing and measuring is concerned. This is not fully correct,
	// since some scripts/fonts/browsers also treat other configurations
	// of code points as a group.
	var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

	// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
	function skipExtendingChars(str, pos, dir) {
	  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
	  return pos
	}

	// Returns the value from the range [`from`; `to`] that satisfies
	// `pred` and is closest to `from`. Assumes that at least `to`
	// satisfies `pred`. Supports `from` being greater than `to`.
	function findFirst(pred, from, to) {
	  // At any point we are certain `to` satisfies `pred`, don't know
	  // whether `from` does.
	  var dir = from > to ? -1 : 1;
	  for (;;) {
	    if (from == to) { return from }
	    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
	    if (mid == from) { return pred(mid) ? from : to }
	    if (pred(mid)) { to = mid; }
	    else { from = mid + dir; }
	  }
	}

	// The display handles the DOM integration, both for input reading
	// and content drawing. It holds references to DOM nodes and
	// display-related state.

	function Display(place, doc, input) {
	  var d = this;
	  this.input = input;

	  // Covers bottom-right square when both scrollbars are present.
	  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	  d.scrollbarFiller.setAttribute("cm-not-content", "true");
	  // Covers bottom of gutter when coverGutterNextToScrollbar is on
	  // and h scrollbar is present.
	  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	  d.gutterFiller.setAttribute("cm-not-content", "true");
	  // Will contain the actual code, positioned to cover the viewport.
	  d.lineDiv = eltP("div", null, "CodeMirror-code");
	  // Elements are added to these to represent selection and cursors.
	  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	  d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	  // A visibility: hidden element used to find the size of things.
	  d.measure = elt("div", null, "CodeMirror-measure");
	  // When lines outside of the viewport are measured, they are drawn in this.
	  d.lineMeasure = elt("div", null, "CodeMirror-measure");
	  // Wraps everything that needs to exist inside the vertically-padded coordinate system
	  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                    null, "position: relative; outline: none");
	  var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
	  // Moved around its parent to cover visible view.
	  d.mover = elt("div", [lines], null, "position: relative");
	  // Set to the height of the document, allowing scrolling.
	  d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	  d.sizerWidth = null;
	  // Behavior of elts with overflow: auto and padding is
	  // inconsistent across browsers. This is used to ensure the
	  // scrollable area is big enough.
	  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	  // Will contain the gutters, if any.
	  d.gutters = elt("div", null, "CodeMirror-gutters");
	  d.lineGutter = null;
	  // Actual scrollable element.
	  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	  d.scroller.setAttribute("tabIndex", "-1");
	  // The element in which the editor lives.
	  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

	  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

	  if (place) {
	    if (place.appendChild) { place.appendChild(d.wrapper); }
	    else { place(d.wrapper); }
	  }

	  // Current rendered range (may be bigger than the view window).
	  d.viewFrom = d.viewTo = doc.first;
	  d.reportedViewFrom = d.reportedViewTo = doc.first;
	  // Information about the rendered lines.
	  d.view = [];
	  d.renderedView = null;
	  // Holds info about a single rendered line when it was rendered
	  // for measurement, while not in view.
	  d.externalMeasured = null;
	  // Empty space (in pixels) above the view
	  d.viewOffset = 0;
	  d.lastWrapHeight = d.lastWrapWidth = 0;
	  d.updateLineNumbers = null;

	  d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	  d.scrollbarsClipped = false;

	  // Used to only resize the line number gutter when necessary (when
	  // the amount of lines crosses a boundary that makes its width change)
	  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	  // Set to true when a non-horizontal-scrolling line widget is
	  // added. As an optimization, line widget aligning is skipped when
	  // this is false.
	  d.alignWidgets = false;

	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

	  // Tracks the maximum line length so that the horizontal scrollbar
	  // can be kept static when scrolling.
	  d.maxLine = null;
	  d.maxLineLength = 0;
	  d.maxLineChanged = false;

	  // Used for measuring wheel scrolling granularity
	  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

	  // True when shift is held down.
	  d.shift = false;

	  // Used to track whether anything happened since the context menu
	  // was opened.
	  d.selForContextMenu = null;

	  d.activeTouch = null;

	  input.init(d);
	}

	// Find the line object corresponding to the given line number.
	function getLine(doc, n) {
	  n -= doc.first;
	  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
	  var chunk = doc;
	  while (!chunk.lines) {
	    for (var i = 0;; ++i) {
	      var child = chunk.children[i], sz = child.chunkSize();
	      if (n < sz) { chunk = child; break }
	      n -= sz;
	    }
	  }
	  return chunk.lines[n]
	}

	// Get the part of a document between two positions, as an array of
	// strings.
	function getBetween(doc, start, end) {
	  var out = [], n = start.line;
	  doc.iter(start.line, end.line + 1, function (line) {
	    var text = line.text;
	    if (n == end.line) { text = text.slice(0, end.ch); }
	    if (n == start.line) { text = text.slice(start.ch); }
	    out.push(text);
	    ++n;
	  });
	  return out
	}
	// Get the lines between from and to, as array of strings.
	function getLines(doc, from, to) {
	  var out = [];
	  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
	  return out
	}

	// Update the height of a line, propagating the height change
	// upwards to parent nodes.
	function updateLineHeight(line, height) {
	  var diff = height - line.height;
	  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
	}

	// Given a line object, find its line number by walking up through
	// its parent links.
	function lineNo(line) {
	  if (line.parent == null) { return null }
	  var cur = line.parent, no = indexOf(cur.lines, line);
	  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	    for (var i = 0;; ++i) {
	      if (chunk.children[i] == cur) { break }
	      no += chunk.children[i].chunkSize();
	    }
	  }
	  return no + cur.first
	}

	// Find the line at the given vertical position, using the height
	// information in the document tree.
	function lineAtHeight(chunk, h) {
	  var n = chunk.first;
	  outer: do {
	    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
	      var child = chunk.children[i$1], ch = child.height;
	      if (h < ch) { chunk = child; continue outer }
	      h -= ch;
	      n += child.chunkSize();
	    }
	    return n
	  } while (!chunk.lines)
	  var i = 0;
	  for (; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i], lh = line.height;
	    if (h < lh) { break }
	    h -= lh;
	  }
	  return n + i
	}

	function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

	function lineNumberFor(options, i) {
	  return String(options.lineNumberFormatter(i + options.firstLineNumber))
	}

	// A Pos instance represents a position within the text.
	function Pos(line, ch, sticky) {
	  if ( sticky === void 0 ) sticky = null;

	  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
	  this.line = line;
	  this.ch = ch;
	  this.sticky = sticky;
	}

	// Compare two positions, return 0 if they are the same, a negative
	// number when a is less, and a positive number otherwise.
	function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

	function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

	function copyPos(x) {return Pos(x.line, x.ch)}
	function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
	function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

	// Most of the external API clips given positions to make sure they
	// actually exist within the document.
	function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
	function clipPos(doc, pos) {
	  if (pos.line < doc.first) { return Pos(doc.first, 0) }
	  var last = doc.first + doc.size - 1;
	  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
	  return clipToLen(pos, getLine(doc, pos.line).text.length)
	}
	function clipToLen(pos, linelen) {
	  var ch = pos.ch;
	  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
	  else if (ch < 0) { return Pos(pos.line, 0) }
	  else { return pos }
	}
	function clipPosArray(doc, array) {
	  var out = [];
	  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
	  return out
	}

	// Optimize some code when these features are not used.
	var sawReadOnlySpans = false;
	var sawCollapsedSpans = false;

	function seeReadOnlySpans() {
	  sawReadOnlySpans = true;
	}

	function seeCollapsedSpans() {
	  sawCollapsedSpans = true;
	}

	// TEXTMARKER SPANS

	function MarkedSpan(marker, from, to) {
	  this.marker = marker;
	  this.from = from; this.to = to;
	}

	// Search an array of spans for a span matching the given marker.
	function getMarkedSpanFor(spans, marker) {
	  if (spans) { for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i];
	    if (span.marker == marker) { return span }
	  } }
	}
	// Remove a span from an array, returning undefined if no spans are
	// left (we don't store arrays for lines without spans).
	function removeMarkedSpan(spans, span) {
	  var r;
	  for (var i = 0; i < spans.length; ++i)
	    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
	  return r
	}
	// Add a span to a line.
	function addMarkedSpan(line, span) {
	  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	  span.marker.attachLine(line);
	}

	// Used for the algorithm that adjusts markers for a change in the
	// document. These functions cut an array of spans at a given
	// character position, returning an array of remaining chunks (or
	// undefined if nothing remains).
	function markedSpansBefore(old, startCh, isInsert) {
	  var nw;
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker;
	    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	    }
	  } }
	  return nw
	}
	function markedSpansAfter(old, endCh, isInsert) {
	  var nw;
	  if (old) { for (var i = 0; i < old.length; ++i) {
	    var span = old[i], marker = span.marker;
	    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                            span.to == null ? null : span.to - endCh));
	    }
	  } }
	  return nw
	}

	// Given a change object, compute the new set of marker spans that
	// cover the line in which the change took place. Removes spans
	// entirely within the change, reconnects spans belonging to the
	// same marker that appear on both sides of the change, and cuts off
	// spans partially within the change. Returns an array of span
	// arrays with one element for each line in (after) the change.
	function stretchSpansOverChange(doc, change) {
	  if (change.full) { return null }
	  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	  if (!oldFirst && !oldLast) { return null }

	  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	  // Get the spans that 'stick out' on both sides
	  var first = markedSpansBefore(oldFirst, startCh, isInsert);
	  var last = markedSpansAfter(oldLast, endCh, isInsert);

	  // Next, merge those two ends
	  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	  if (first) {
	    // Fix up .to properties of first
	    for (var i = 0; i < first.length; ++i) {
	      var span = first[i];
	      if (span.to == null) {
	        var found = getMarkedSpanFor(last, span.marker);
	        if (!found) { span.to = startCh; }
	        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
	      }
	    }
	  }
	  if (last) {
	    // Fix up .from in last (or move them into first in case of sameLine)
	    for (var i$1 = 0; i$1 < last.length; ++i$1) {
	      var span$1 = last[i$1];
	      if (span$1.to != null) { span$1.to += offset; }
	      if (span$1.from == null) {
	        var found$1 = getMarkedSpanFor(first, span$1.marker);
	        if (!found$1) {
	          span$1.from = offset;
	          if (sameLine) { (first || (first = [])).push(span$1); }
	        }
	      } else {
	        span$1.from += offset;
	        if (sameLine) { (first || (first = [])).push(span$1); }
	      }
	    }
	  }
	  // Make sure we didn't create any zero-length spans
	  if (first) { first = clearEmptySpans(first); }
	  if (last && last != first) { last = clearEmptySpans(last); }

	  var newMarkers = [first];
	  if (!sameLine) {
	    // Fill gap with whole-line-spans
	    var gap = change.text.length - 2, gapMarkers;
	    if (gap > 0 && first)
	      { for (var i$2 = 0; i$2 < first.length; ++i$2)
	        { if (first[i$2].to == null)
	          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
	    for (var i$3 = 0; i$3 < gap; ++i$3)
	      { newMarkers.push(gapMarkers); }
	    newMarkers.push(last);
	  }
	  return newMarkers
	}

	// Remove spans that are empty and don't have a clearWhenEmpty
	// option of false.
	function clearEmptySpans(spans) {
	  for (var i = 0; i < spans.length; ++i) {
	    var span = spans[i];
	    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	      { spans.splice(i--, 1); }
	  }
	  if (!spans.length) { return null }
	  return spans
	}

	// Used to 'clip' out readOnly ranges when making a change.
	function removeReadOnlyRanges(doc, from, to) {
	  var markers = null;
	  doc.iter(from.line, to.line + 1, function (line) {
	    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	      var mark = line.markedSpans[i].marker;
	      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	        { (markers || (markers = [])).push(mark); }
	    } }
	  });
	  if (!markers) { return null }
	  var parts = [{from: from, to: to}];
	  for (var i = 0; i < markers.length; ++i) {
	    var mk = markers[i], m = mk.find(0);
	    for (var j = 0; j < parts.length; ++j) {
	      var p = parts[j];
	      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
	      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	        { newParts.push({from: p.from, to: m.from}); }
	      if (dto > 0 || !mk.inclusiveRight && !dto)
	        { newParts.push({from: m.to, to: p.to}); }
	      parts.splice.apply(parts, newParts);
	      j += newParts.length - 3;
	    }
	  }
	  return parts
	}

	// Connect or disconnect spans from a line.
	function detachMarkedSpans(line) {
	  var spans = line.markedSpans;
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.detachLine(line); }
	  line.markedSpans = null;
	}
	function attachMarkedSpans(line, spans) {
	  if (!spans) { return }
	  for (var i = 0; i < spans.length; ++i)
	    { spans[i].marker.attachLine(line); }
	  line.markedSpans = spans;
	}

	// Helpers used when computing which overlapping collapsed span
	// counts as the larger one.
	function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
	function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

	// Returns a number indicating which of two overlapping collapsed
	// spans is larger (and thus includes the other). Falls back to
	// comparing ids when the spans cover exactly the same range.
	function compareCollapsedMarkers(a, b) {
	  var lenDiff = a.lines.length - b.lines.length;
	  if (lenDiff != 0) { return lenDiff }
	  var aPos = a.find(), bPos = b.find();
	  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	  if (fromCmp) { return -fromCmp }
	  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	  if (toCmp) { return toCmp }
	  return b.id - a.id
	}

	// Find out whether a line ends or starts in a collapsed span. If
	// so, return the marker for that span.
	function collapsedSpanAtSide(line, start) {
	  var sps = sawCollapsedSpans && line.markedSpans, found;
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i];
	    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	      { found = sp.marker; }
	  } }
	  return found
	}
	function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
	function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

	// Test whether there exists a collapsed span that partially
	// overlaps (covers the start or end, but not both) of a new span.
	// Such overlap is not allowed.
	function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
	  var line = getLine(doc, lineNo$$1);
	  var sps = sawCollapsedSpans && line.markedSpans;
	  if (sps) { for (var i = 0; i < sps.length; ++i) {
	    var sp = sps[i];
	    if (!sp.marker.collapsed) { continue }
	    var found = sp.marker.find(0);
	    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
	    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	      { return true }
	  } }
	}

	// A visual line is a line as drawn on the screen. Folding, for
	// example, can cause multiple logical lines to appear on the same
	// visual line. This finds the start of the visual line that the
	// given line is part of (usually that is the line itself).
	function visualLine(line) {
	  var merged;
	  while (merged = collapsedSpanAtStart(line))
	    { line = merged.find(-1, true).line; }
	  return line
	}

	function visualLineEnd(line) {
	  var merged;
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line; }
	  return line
	}

	// Returns an array of logical lines that continue the visual line
	// started by the argument, or undefined if there are no such lines.
	function visualLineContinued(line) {
	  var merged, lines;
	  while (merged = collapsedSpanAtEnd(line)) {
	    line = merged.find(1, true).line
	    ;(lines || (lines = [])).push(line);
	  }
	  return lines
	}

	// Get the line number of the start of the visual line that the
	// given line number is part of.
	function visualLineNo(doc, lineN) {
	  var line = getLine(doc, lineN), vis = visualLine(line);
	  if (line == vis) { return lineN }
	  return lineNo(vis)
	}

	// Get the line number of the start of the next visual line after
	// the given line.
	function visualLineEndNo(doc, lineN) {
	  if (lineN > doc.lastLine()) { return lineN }
	  var line = getLine(doc, lineN), merged;
	  if (!lineIsHidden(doc, line)) { return lineN }
	  while (merged = collapsedSpanAtEnd(line))
	    { line = merged.find(1, true).line; }
	  return lineNo(line) + 1
	}

	// Compute whether a line is hidden. Lines count as hidden when they
	// are part of a visual line that starts with another line, or when
	// they are entirely covered by collapsed, non-widget span.
	function lineIsHidden(doc, line) {
	  var sps = sawCollapsedSpans && line.markedSpans;
	  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	    sp = sps[i];
	    if (!sp.marker.collapsed) { continue }
	    if (sp.from == null) { return true }
	    if (sp.marker.widgetNode) { continue }
	    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	      { return true }
	  } }
	}
	function lineIsHiddenInner(doc, line, span) {
	  if (span.to == null) {
	    var end = span.marker.find(1, true);
	    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
	  }
	  if (span.marker.inclusiveRight && span.to == line.text.length)
	    { return true }
	  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
	    sp = line.markedSpans[i];
	    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	        (sp.to == null || sp.to != span.from) &&
	        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	        lineIsHiddenInner(doc, line, sp)) { return true }
	  }
	}

	// Find the height above the given line.
	function heightAtLine(lineObj) {
	  lineObj = visualLine(lineObj);

	  var h = 0, chunk = lineObj.parent;
	  for (var i = 0; i < chunk.lines.length; ++i) {
	    var line = chunk.lines[i];
	    if (line == lineObj) { break }
	    else { h += line.height; }
	  }
	  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
	      var cur = p.children[i$1];
	      if (cur == chunk) { break }
	      else { h += cur.height; }
	    }
	  }
	  return h
	}

	// Compute the character length of a line, taking into account
	// collapsed ranges (see markText) that might hide parts, and join
	// other lines onto it.
	function lineLength(line) {
	  if (line.height == 0) { return 0 }
	  var len = line.text.length, merged, cur = line;
	  while (merged = collapsedSpanAtStart(cur)) {
	    var found = merged.find(0, true);
	    cur = found.from.line;
	    len += found.from.ch - found.to.ch;
	  }
	  cur = line;
	  while (merged = collapsedSpanAtEnd(cur)) {
	    var found$1 = merged.find(0, true);
	    len -= cur.text.length - found$1.from.ch;
	    cur = found$1.to.line;
	    len += cur.text.length - found$1.to.ch;
	  }
	  return len
	}

	// Find the longest line in the document.
	function findMaxLine(cm) {
	  var d = cm.display, doc = cm.doc;
	  d.maxLine = getLine(doc, doc.first);
	  d.maxLineLength = lineLength(d.maxLine);
	  d.maxLineChanged = true;
	  doc.iter(function (line) {
	    var len = lineLength(line);
	    if (len > d.maxLineLength) {
	      d.maxLineLength = len;
	      d.maxLine = line;
	    }
	  });
	}

	// BIDI HELPERS

	function iterateBidiSections(order, from, to, f) {
	  if (!order) { return f(from, to, "ltr", 0) }
	  var found = false;
	  for (var i = 0; i < order.length; ++i) {
	    var part = order[i];
	    if (part.from < to && part.to > from || from == to && part.to == from) {
	      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
	      found = true;
	    }
	  }
	  if (!found) { f(from, to, "ltr"); }
	}

	var bidiOther = null;
	function getBidiPartAt(order, ch, sticky) {
	  var found;
	  bidiOther = null;
	  for (var i = 0; i < order.length; ++i) {
	    var cur = order[i];
	    if (cur.from < ch && cur.to > ch) { return i }
	    if (cur.to == ch) {
	      if (cur.from != cur.to && sticky == "before") { found = i; }
	      else { bidiOther = i; }
	    }
	    if (cur.from == ch) {
	      if (cur.from != cur.to && sticky != "before") { found = i; }
	      else { bidiOther = i; }
	    }
	  }
	  return found != null ? found : bidiOther
	}

	// Bidirectional ordering algorithm
	// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	// that this (partially) implements.

	// One-char codes used for character types:
	// L (L):   Left-to-Right
	// R (R):   Right-to-Left
	// r (AL):  Right-to-Left Arabic
	// 1 (EN):  European Number
	// + (ES):  European Number Separator
	// % (ET):  European Number Terminator
	// n (AN):  Arabic Number
	// , (CS):  Common Number Separator
	// m (NSM): Non-Spacing Mark
	// b (BN):  Boundary Neutral
	// s (B):   Paragraph Separator
	// t (S):   Segment Separator
	// w (WS):  Whitespace
	// N (ON):  Other Neutrals

	// Returns null if characters are ordered as they appear
	// (left-to-right), or an array of sections ({from, to, level}
	// objects) in the order in which they occur visually.
	var bidiOrdering = (function() {
	  // Character types for codepoints 0 to 0xff
	  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	  // Character types for codepoints 0x600 to 0x6f9
	  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
	  function charType(code) {
	    if (code <= 0xf7) { return lowTypes.charAt(code) }
	    else if (0x590 <= code && code <= 0x5f4) { return "R" }
	    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
	    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
	    else if (0x2000 <= code && code <= 0x200b) { return "w" }
	    else if (code == 0x200c) { return "b" }
	    else { return "L" }
	  }

	  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

	  function BidiSpan(level, from, to) {
	    this.level = level;
	    this.from = from; this.to = to;
	  }

	  return function(str, direction) {
	    var outerType = direction == "ltr" ? "L" : "R";

	    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
	    var len = str.length, types = [];
	    for (var i = 0; i < len; ++i)
	      { types.push(charType(str.charCodeAt(i))); }

	    // W1. Examine each non-spacing mark (NSM) in the level run, and
	    // change the type of the NSM to the type of the previous
	    // character. If the NSM is at the start of the level run, it will
	    // get the type of sor.
	    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
	      var type = types[i$1];
	      if (type == "m") { types[i$1] = prev; }
	      else { prev = type; }
	    }

	    // W2. Search backwards from each instance of a European number
	    // until the first strong type (R, L, AL, or sor) is found. If an
	    // AL is found, change the type of the European number to Arabic
	    // number.
	    // W3. Change all ALs to R.
	    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
	      var type$1 = types[i$2];
	      if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
	      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
	    }

	    // W4. A single European separator between two European numbers
	    // changes to a European number. A single common separator between
	    // two numbers of the same type changes to that type.
	    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
	      var type$2 = types[i$3];
	      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
	      else if (type$2 == "," && prev$1 == types[i$3+1] &&
	               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
	      prev$1 = type$2;
	    }

	    // W5. A sequence of European terminators adjacent to European
	    // numbers changes to all European numbers.
	    // W6. Otherwise, separators and terminators change to Other
	    // Neutral.
	    for (var i$4 = 0; i$4 < len; ++i$4) {
	      var type$3 = types[i$4];
	      if (type$3 == ",") { types[i$4] = "N"; }
	      else if (type$3 == "%") {
	        var end = (void 0);
	        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
	        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	        for (var j = i$4; j < end; ++j) { types[j] = replace; }
	        i$4 = end - 1;
	      }
	    }

	    // W7. Search backwards from each instance of a European number
	    // until the first strong type (R, L, or sor) is found. If an L is
	    // found, then change the type of the European number to L.
	    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
	      var type$4 = types[i$5];
	      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
	      else if (isStrong.test(type$4)) { cur$1 = type$4; }
	    }

	    // N1. A sequence of neutrals takes the direction of the
	    // surrounding strong text if the text on both sides has the same
	    // direction. European and Arabic numbers act as if they were R in
	    // terms of their influence on neutrals. Start-of-level-run (sor)
	    // and end-of-level-run (eor) are used at level run boundaries.
	    // N2. Any remaining neutrals take the embedding direction.
	    for (var i$6 = 0; i$6 < len; ++i$6) {
	      if (isNeutral.test(types[i$6])) {
	        var end$1 = (void 0);
	        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
	        var before = (i$6 ? types[i$6-1] : outerType) == "L";
	        var after = (end$1 < len ? types[end$1] : outerType) == "L";
	        var replace$1 = before == after ? (before ? "L" : "R") : outerType;
	        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
	        i$6 = end$1 - 1;
	      }
	    }

	    // Here we depart from the documented algorithm, in order to avoid
	    // building up an actual levels array. Since there are only three
	    // levels (0, 1, 2) in an implementation that doesn't take
	    // explicit embedding into account, we can build up the order on
	    // the fly, without following the level-based algorithm.
	    var order = [], m;
	    for (var i$7 = 0; i$7 < len;) {
	      if (countsAsLeft.test(types[i$7])) {
	        var start = i$7;
	        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
	        order.push(new BidiSpan(0, start, i$7));
	      } else {
	        var pos = i$7, at = order.length;
	        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
	        for (var j$2 = pos; j$2 < i$7;) {
	          if (countsAsNum.test(types[j$2])) {
	            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
	            var nstart = j$2;
	            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
	            order.splice(at, 0, new BidiSpan(2, nstart, j$2));
	            pos = j$2;
	          } else { ++j$2; }
	        }
	        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
	      }
	    }
	    if (direction == "ltr") {
	      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	        order[0].from = m[0].length;
	        order.unshift(new BidiSpan(0, 0, m[0].length));
	      }
	      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	        lst(order).to -= m[0].length;
	        order.push(new BidiSpan(0, len - m[0].length, len));
	      }
	    }

	    return direction == "rtl" ? order.reverse() : order
	  }
	})();

	// Get the bidi ordering for the given line (and cache it). Returns
	// false for lines that are fully left-to-right, and an array of
	// BidiSpan objects otherwise.
	function getOrder(line, direction) {
	  var order = line.order;
	  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
	  return order
	}

	// EVENT HANDLING

	// Lightweight event framework. on/off also work on DOM nodes,
	// registering native DOM handlers.

	var noHandlers = [];

	var on = function(emitter, type, f) {
	  if (emitter.addEventListener) {
	    emitter.addEventListener(type, f, false);
	  } else if (emitter.attachEvent) {
	    emitter.attachEvent("on" + type, f);
	  } else {
	    var map$$1 = emitter._handlers || (emitter._handlers = {});
	    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
	  }
	};

	function getHandlers(emitter, type) {
	  return emitter._handlers && emitter._handlers[type] || noHandlers
	}

	function off(emitter, type, f) {
	  if (emitter.removeEventListener) {
	    emitter.removeEventListener(type, f, false);
	  } else if (emitter.detachEvent) {
	    emitter.detachEvent("on" + type, f);
	  } else {
	    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
	    if (arr) {
	      var index = indexOf(arr, f);
	      if (index > -1)
	        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
	    }
	  }
	}

	function signal(emitter, type /*, values...*/) {
	  var handlers = getHandlers(emitter, type);
	  if (!handlers.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2);
	  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
	}

	// The DOM events that CodeMirror handles can be overridden by
	// registering a (non-DOM) handler on the editor for the event name,
	// and preventDefault-ing the event in that handler.
	function signalDOMEvent(cm, e, override) {
	  if (typeof e == "string")
	    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
	  signal(cm, override || e.type, cm, e);
	  return e_defaultPrevented(e) || e.codemirrorIgnore
	}

	function signalCursorActivity(cm) {
	  var arr = cm._handlers && cm._handlers.cursorActivity;
	  if (!arr) { return }
	  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
	    { set.push(arr[i]); } }
	}

	function hasHandler(emitter, type) {
	  return getHandlers(emitter, type).length > 0
	}

	// Add on and off methods to a constructor's prototype, to make
	// registering events on such objects more convenient.
	function eventMixin(ctor) {
	  ctor.prototype.on = function(type, f) {on(this, type, f);};
	  ctor.prototype.off = function(type, f) {off(this, type, f);};
	}

	// Due to the fact that we still support jurassic IE versions, some
	// compatibility wrappers are needed.

	function e_preventDefault(e) {
	  if (e.preventDefault) { e.preventDefault(); }
	  else { e.returnValue = false; }
	}
	function e_stopPropagation(e) {
	  if (e.stopPropagation) { e.stopPropagation(); }
	  else { e.cancelBubble = true; }
	}
	function e_defaultPrevented(e) {
	  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
	}
	function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

	function e_target(e) {return e.target || e.srcElement}
	function e_button(e) {
	  var b = e.which;
	  if (b == null) {
	    if (e.button & 1) { b = 1; }
	    else if (e.button & 2) { b = 3; }
	    else if (e.button & 4) { b = 2; }
	  }
	  if (mac && e.ctrlKey && b == 1) { b = 3; }
	  return b
	}

	// Detect drag-and-drop
	var dragAndDrop = function() {
	  // There is *some* kind of drag-and-drop support in IE6-8, but I
	  // couldn't get it to work yet.
	  if (ie && ie_version < 9) { return false }
	  var div = elt('div');
	  return "draggable" in div || "dragDrop" in div
	}();

	var zwspSupported;
	function zeroWidthElement(measure) {
	  if (zwspSupported == null) {
	    var test = elt("span", "\u200b");
	    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	    if (measure.firstChild.offsetHeight != 0)
	      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
	  }
	  var node = zwspSupported ? elt("span", "\u200b") :
	    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	  node.setAttribute("cm-text", "");
	  return node
	}

	// Feature-detect IE's crummy client rect reporting for bidi text
	var badBidiRects;
	function hasBadBidiRects(measure) {
	  if (badBidiRects != null) { return badBidiRects }
	  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	  var r0 = range(txt, 0, 1).getBoundingClientRect();
	  var r1 = range(txt, 1, 2).getBoundingClientRect();
	  removeChildren(measure);
	  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
	  return badBidiRects = (r1.right - r0.right < 3)
	}

	// See if "".split is the broken IE version, if so, provide an
	// alternative way to split lines.
	var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
	  var pos = 0, result = [], l = string.length;
	  while (pos <= l) {
	    var nl = string.indexOf("\n", pos);
	    if (nl == -1) { nl = string.length; }
	    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	    var rt = line.indexOf("\r");
	    if (rt != -1) {
	      result.push(line.slice(0, rt));
	      pos += rt + 1;
	    } else {
	      result.push(line);
	      pos = nl + 1;
	    }
	  }
	  return result
	} : function (string) { return string.split(/\r\n?|\n/); };

	var hasSelection = window.getSelection ? function (te) {
	  try { return te.selectionStart != te.selectionEnd }
	  catch(e) { return false }
	} : function (te) {
	  var range$$1;
	  try {range$$1 = te.ownerDocument.selection.createRange();}
	  catch(e) {}
	  if (!range$$1 || range$$1.parentElement() != te) { return false }
	  return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
	};

	var hasCopyEvent = (function () {
	  var e = elt("div");
	  if ("oncopy" in e) { return true }
	  e.setAttribute("oncopy", "return;");
	  return typeof e.oncopy == "function"
	})();

	var badZoomedRects = null;
	function hasBadZoomedRects(measure) {
	  if (badZoomedRects != null) { return badZoomedRects }
	  var node = removeChildrenAndAdd(measure, elt("span", "x"));
	  var normal = node.getBoundingClientRect();
	  var fromRange = range(node, 0, 1).getBoundingClientRect();
	  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
	}

	// Known modes, by name and by MIME
	var modes = {};
	var mimeModes = {};

	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	function defineMode(name, mode) {
	  if (arguments.length > 2)
	    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
	  modes[name] = mode;
	}

	function defineMIME(mime, spec) {
	  mimeModes[mime] = spec;
	}

	// Given a MIME type, a {name, ...options} config object, or a name
	// string, return a mode config object.
	function resolveMode(spec) {
	  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	    spec = mimeModes[spec];
	  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	    var found = mimeModes[spec.name];
	    if (typeof found == "string") { found = {name: found}; }
	    spec = createObj(found, spec);
	    spec.name = found.name;
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	    return resolveMode("application/xml")
	  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	    return resolveMode("application/json")
	  }
	  if (typeof spec == "string") { return {name: spec} }
	  else { return spec || {name: "null"} }
	}

	// Given a mode spec (anything that resolveMode accepts), find and
	// initialize an actual mode object.
	function getMode(options, spec) {
	  spec = resolveMode(spec);
	  var mfactory = modes[spec.name];
	  if (!mfactory) { return getMode(options, "text/plain") }
	  var modeObj = mfactory(options, spec);
	  if (modeExtensions.hasOwnProperty(spec.name)) {
	    var exts = modeExtensions[spec.name];
	    for (var prop in exts) {
	      if (!exts.hasOwnProperty(prop)) { continue }
	      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
	      modeObj[prop] = exts[prop];
	    }
	  }
	  modeObj.name = spec.name;
	  if (spec.helperType) { modeObj.helperType = spec.helperType; }
	  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
	    { modeObj[prop$1] = spec.modeProps[prop$1]; } }

	  return modeObj
	}

	// This can be used to attach properties to mode objects from
	// outside the actual mode definition.
	var modeExtensions = {};
	function extendMode(mode, properties) {
	  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	  copyObj(properties, exts);
	}

	function copyState(mode, state) {
	  if (state === true) { return state }
	  if (mode.copyState) { return mode.copyState(state) }
	  var nstate = {};
	  for (var n in state) {
	    var val = state[n];
	    if (val instanceof Array) { val = val.concat([]); }
	    nstate[n] = val;
	  }
	  return nstate
	}

	// Given a mode and a state (for that mode), find the inner mode and
	// state at the position that the state refers to.
	function innerMode(mode, state) {
	  var info;
	  while (mode.innerMode) {
	    info = mode.innerMode(state);
	    if (!info || info.mode == mode) { break }
	    state = info.state;
	    mode = info.mode;
	  }
	  return info || {mode: mode, state: state}
	}

	function startState(mode, a1, a2) {
	  return mode.startState ? mode.startState(a1, a2) : true
	}

	// STRING STREAM

	// Fed to the mode parsers, provides helper functions to make
	// parsers more succinct.

	var StringStream = function(string, tabSize, lineOracle) {
	  this.pos = this.start = 0;
	  this.string = string;
	  this.tabSize = tabSize || 8;
	  this.lastColumnPos = this.lastColumnValue = 0;
	  this.lineStart = 0;
	  this.lineOracle = lineOracle;
	};

	StringStream.prototype.eol = function () {return this.pos >= this.string.length};
	StringStream.prototype.sol = function () {return this.pos == this.lineStart};
	StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
	StringStream.prototype.next = function () {
	  if (this.pos < this.string.length)
	    { return this.string.charAt(this.pos++) }
	};
	StringStream.prototype.eat = function (match) {
	  var ch = this.string.charAt(this.pos);
	  var ok;
	  if (typeof match == "string") { ok = ch == match; }
	  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
	  if (ok) {++this.pos; return ch}
	};
	StringStream.prototype.eatWhile = function (match) {
	  var start = this.pos;
	  while (this.eat(match)){}
	  return this.pos > start
	};
	StringStream.prototype.eatSpace = function () {
	    var this$1 = this;

	  var start = this.pos;
	  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
	  return this.pos > start
	};
	StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
	StringStream.prototype.skipTo = function (ch) {
	  var found = this.string.indexOf(ch, this.pos);
	  if (found > -1) {this.pos = found; return true}
	};
	StringStream.prototype.backUp = function (n) {this.pos -= n;};
	StringStream.prototype.column = function () {
	  if (this.lastColumnPos < this.start) {
	    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	    this.lastColumnPos = this.start;
	  }
	  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	};
	StringStream.prototype.indentation = function () {
	  return countColumn(this.string, null, this.tabSize) -
	    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	};
	StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
	  if (typeof pattern == "string") {
	    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
	    var substr = this.string.substr(this.pos, pattern.length);
	    if (cased(substr) == cased(pattern)) {
	      if (consume !== false) { this.pos += pattern.length; }
	      return true
	    }
	  } else {
	    var match = this.string.slice(this.pos).match(pattern);
	    if (match && match.index > 0) { return null }
	    if (match && consume !== false) { this.pos += match[0].length; }
	    return match
	  }
	};
	StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
	StringStream.prototype.hideFirstChars = function (n, inner) {
	  this.lineStart += n;
	  try { return inner() }
	  finally { this.lineStart -= n; }
	};
	StringStream.prototype.lookAhead = function (n) {
	  var oracle = this.lineOracle;
	  return oracle && oracle.lookAhead(n)
	};
	StringStream.prototype.baseToken = function () {
	  var oracle = this.lineOracle;
	  return oracle && oracle.baseToken(this.pos)
	};

	var SavedContext = function(state, lookAhead) {
	  this.state = state;
	  this.lookAhead = lookAhead;
	};

	var Context = function(doc, state, line, lookAhead) {
	  this.state = state;
	  this.doc = doc;
	  this.line = line;
	  this.maxLookAhead = lookAhead || 0;
	  this.baseTokens = null;
	  this.baseTokenPos = 1;
	};

	Context.prototype.lookAhead = function (n) {
	  var line = this.doc.getLine(this.line + n);
	  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
	  return line
	};

	Context.prototype.baseToken = function (n) {
	    var this$1 = this;

	  if (!this.baseTokens) { return null }
	  while (this.baseTokens[this.baseTokenPos] <= n)
	    { this$1.baseTokenPos += 2; }
	  var type = this.baseTokens[this.baseTokenPos + 1];
	  return {type: type && type.replace(/( |^)overlay .*/, ""),
	          size: this.baseTokens[this.baseTokenPos] - n}
	};

	Context.prototype.nextLine = function () {
	  this.line++;
	  if (this.maxLookAhead > 0) { this.maxLookAhead--; }
	};

	Context.fromSaved = function (doc, saved, line) {
	  if (saved instanceof SavedContext)
	    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
	  else
	    { return new Context(doc, copyState(doc.mode, saved), line) }
	};

	Context.prototype.save = function (copy) {
	  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
	  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
	};


	// Compute a style array (an array starting with a mode generation
	// -- for invalidation -- followed by pairs of end positions and
	// style strings), which is used to highlight the tokens on the
	// line.
	function highlightLine(cm, line, context, forceToEnd) {
	  // A styles array always starts with a number identifying the
	  // mode/overlays that it is based on (for easy invalidation).
	  var st = [cm.state.modeGen], lineClasses = {};
	  // Compute the base array of styles
	  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
	          lineClasses, forceToEnd);
	  var state = context.state;

	  // Run overlays, adjust style array.
	  var loop = function ( o ) {
	    context.baseTokens = st;
	    var overlay = cm.state.overlays[o], i = 1, at = 0;
	    context.state = true;
	    runMode(cm, line.text, overlay.mode, context, function (end, style) {
	      var start = i;
	      // Ensure there's a token end at the current position, and that i points at it
	      while (at < end) {
	        var i_end = st[i];
	        if (i_end > end)
	          { st.splice(i, 1, end, st[i+1], i_end); }
	        i += 2;
	        at = Math.min(end, i_end);
	      }
	      if (!style) { return }
	      if (overlay.opaque) {
	        st.splice(start, i - start, end, "overlay " + style);
	        i = start + 2;
	      } else {
	        for (; start < i; start += 2) {
	          var cur = st[start+1];
	          st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
	        }
	      }
	    }, lineClasses);
	    context.state = state;
	    context.baseTokens = null;
	    context.baseTokenPos = 1;
	  };

	  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

	  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
	}

	function getLineStyles(cm, line, updateFrontier) {
	  if (!line.styles || line.styles[0] != cm.state.modeGen) {
	    var context = getContextBefore(cm, lineNo(line));
	    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
	    var result = highlightLine(cm, line, context);
	    if (resetState) { context.state = resetState; }
	    line.stateAfter = context.save(!resetState);
	    line.styles = result.styles;
	    if (result.classes) { line.styleClasses = result.classes; }
	    else if (line.styleClasses) { line.styleClasses = null; }
	    if (updateFrontier === cm.doc.highlightFrontier)
	      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
	  }
	  return line.styles
	}

	function getContextBefore(cm, n, precise) {
	  var doc = cm.doc, display = cm.display;
	  if (!doc.mode.startState) { return new Context(doc, true, n) }
	  var start = findStartLine(cm, n, precise);
	  var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
	  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

	  doc.iter(start, n, function (line) {
	    processLine(cm, line.text, context);
	    var pos = context.line;
	    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
	    context.nextLine();
	  });
	  if (precise) { doc.modeFrontier = context.line; }
	  return context
	}

	// Lightweight form of highlight -- proceed over this line and
	// update state, but don't save a style array. Used for lines that
	// aren't currently visible.
	function processLine(cm, text, context, startAt) {
	  var mode = cm.doc.mode;
	  var stream = new StringStream(text, cm.options.tabSize, context);
	  stream.start = stream.pos = startAt || 0;
	  if (text == "") { callBlankLine(mode, context.state); }
	  while (!stream.eol()) {
	    readToken(mode, stream, context.state);
	    stream.start = stream.pos;
	  }
	}

	function callBlankLine(mode, state) {
	  if (mode.blankLine) { return mode.blankLine(state) }
	  if (!mode.innerMode) { return }
	  var inner = innerMode(mode, state);
	  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
	}

	function readToken(mode, stream, state, inner) {
	  for (var i = 0; i < 10; i++) {
	    if (inner) { inner[0] = innerMode(mode, state).mode; }
	    var style = mode.token(stream, state);
	    if (stream.pos > stream.start) { return style }
	  }
	  throw new Error("Mode " + mode.name + " failed to advance stream.")
	}

	var Token = function(stream, type, state) {
	  this.start = stream.start; this.end = stream.pos;
	  this.string = stream.current();
	  this.type = type || null;
	  this.state = state;
	};

	// Utility for getTokenAt and getLineTokens
	function takeToken(cm, pos, precise, asArray) {
	  var doc = cm.doc, mode = doc.mode, style;
	  pos = clipPos(doc, pos);
	  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
	  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
	  if (asArray) { tokens = []; }
	  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	    stream.start = stream.pos;
	    style = readToken(mode, stream, context.state);
	    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
	  }
	  return asArray ? tokens : new Token(stream, style, context.state)
	}

	function extractLineClasses(type, output) {
	  if (type) { for (;;) {
	    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	    if (!lineClass) { break }
	    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	    var prop = lineClass[1] ? "bgClass" : "textClass";
	    if (output[prop] == null)
	      { output[prop] = lineClass[2]; }
	    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	      { output[prop] += " " + lineClass[2]; }
	  } }
	  return type
	}

	// Run the given mode's parser over a line, calling f for each token.
	function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
	  var flattenSpans = mode.flattenSpans;
	  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
	  var curStart = 0, curStyle = null;
	  var stream = new StringStream(text, cm.options.tabSize, context), style;
	  var inner = cm.options.addModeClass && [null];
	  if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
	  while (!stream.eol()) {
	    if (stream.pos > cm.options.maxHighlightLength) {
	      flattenSpans = false;
	      if (forceToEnd) { processLine(cm, text, context, stream.pos); }
	      stream.pos = text.length;
	      style = null;
	    } else {
	      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
	    }
	    if (inner) {
	      var mName = inner[0].name;
	      if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
	    }
	    if (!flattenSpans || curStyle != style) {
	      while (curStart < stream.start) {
	        curStart = Math.min(stream.start, curStart + 5000);
	        f(curStart, curStyle);
	      }
	      curStyle = style;
	    }
	    stream.start = stream.pos;
	  }
	  while (curStart < stream.pos) {
	    // Webkit seems to refuse to render text nodes longer than 57444
	    // characters, and returns inaccurate measurements in nodes
	    // starting around 5000 chars.
	    var pos = Math.min(stream.pos, curStart + 5000);
	    f(pos, curStyle);
	    curStart = pos;
	  }
	}

	// Finds the line to start with when starting a parse. Tries to
	// find a line with a stateAfter, so that it can start with a
	// valid state. If that fails, it returns the line with the
	// smallest indentation, which tends to need the least context to
	// parse correctly.
	function findStartLine(cm, n, precise) {
	  var minindent, minline, doc = cm.doc;
	  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	  for (var search = n; search > lim; --search) {
	    if (search <= doc.first) { return doc.first }
	    var line = getLine(doc, search - 1), after = line.stateAfter;
	    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
	      { return search }
	    var indented = countColumn(line.text, null, cm.options.tabSize);
	    if (minline == null || minindent > indented) {
	      minline = search - 1;
	      minindent = indented;
	    }
	  }
	  return minline
	}

	function retreatFrontier(doc, n) {
	  doc.modeFrontier = Math.min(doc.modeFrontier, n);
	  if (doc.highlightFrontier < n - 10) { return }
	  var start = doc.first;
	  for (var line = n - 1; line > start; line--) {
	    var saved = getLine(doc, line).stateAfter;
	    // change is on 3
	    // state on line 1 looked ahead 2 -- so saw 3
	    // test 1 + 2 < 3 should cover this
	    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
	      start = line + 1;
	      break
	    }
	  }
	  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
	}

	// LINE DATA STRUCTURE

	// Line objects. These hold state related to a line, including
	// highlighting info (the styles array).
	var Line = function(text, markedSpans, estimateHeight) {
	  this.text = text;
	  attachMarkedSpans(this, markedSpans);
	  this.height = estimateHeight ? estimateHeight(this) : 1;
	};

	Line.prototype.lineNo = function () { return lineNo(this) };
	eventMixin(Line);

	// Change the content (text, markers) of a line. Automatically
	// invalidates cached information and tries to re-estimate the
	// line's height.
	function updateLine(line, text, markedSpans, estimateHeight) {
	  line.text = text;
	  if (line.stateAfter) { line.stateAfter = null; }
	  if (line.styles) { line.styles = null; }
	  if (line.order != null) { line.order = null; }
	  detachMarkedSpans(line);
	  attachMarkedSpans(line, markedSpans);
	  var estHeight = estimateHeight ? estimateHeight(line) : 1;
	  if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	}

	// Detach a line from the document tree and its markers.
	function cleanUpLine(line) {
	  line.parent = null;
	  detachMarkedSpans(line);
	}

	// Convert a style as returned by a mode (either null, or a string
	// containing one or more styles) to a CSS style. This is cached,
	// and also looks for line-wide styles.
	var styleToClassCache = {};
	var styleToClassCacheWithMode = {};
	function interpretTokenStyle(style, options) {
	  if (!style || /^\s*$/.test(style)) { return null }
	  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	  return cache[style] ||
	    (cache[style] = style.replace(/\S+/g, "cm-$&"))
	}

	// Render the DOM representation of the text of a line. Also builds
	// up a 'line map', which points at the DOM nodes that represent
	// specific stretches of text, and is used by the measuring code.
	// The returned object contains the DOM node, this map, and
	// information about line-wide styles that were set by the mode.
	function buildLineContent(cm, lineView) {
	  // The padding-right forces the element to have a 'border', which
	  // is needed on Webkit to be able to get line-level bounding
	  // rectangles for it (in measureChar).
	  var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
	  var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
	                 col: 0, pos: 0, cm: cm,
	                 trailingSpace: false,
	                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
	  lineView.measure = {};

	  // Iterate over the logical lines that make up this visual line.
	  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
	    builder.pos = 0;
	    builder.addToken = buildToken;
	    // Optionally wire in some hacks into the token-rendering
	    // algorithm, to deal with browser quirks.
	    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
	      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
	    builder.map = [];
	    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	    if (line.styleClasses) {
	      if (line.styleClasses.bgClass)
	        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
	      if (line.styleClasses.textClass)
	        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
	    }

	    // Ensure at least a single node is present, for measuring.
	    if (builder.map.length == 0)
	      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

	    // Store the map and a cache object for the current logical line
	    if (i == 0) {
	      lineView.measure.map = builder.map;
	      lineView.measure.cache = {};
	    } else {
	      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
	      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
	    }
	  }

	  // See issue #2901
	  if (webkit) {
	    var last = builder.content.lastChild;
	    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	      { builder.content.className = "cm-tab-wrap-hack"; }
	  }

	  signal(cm, "renderLine", cm, lineView.line, builder.pre);
	  if (builder.pre.className)
	    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

	  return builder
	}

	function defaultSpecialCharPlaceholder(ch) {
	  var token = elt("span", "\u2022", "cm-invalidchar");
	  token.title = "\\u" + ch.charCodeAt(0).toString(16);
	  token.setAttribute("aria-label", token.title);
	  return token
	}

	// Build up the DOM representation for a single token, and add it to
	// the line map. Takes care to render special characters separately.
	function buildToken(builder, text, style, startStyle, endStyle, title, css) {
	  if (!text) { return }
	  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
	  var special = builder.cm.state.specialChars, mustWrap = false;
	  var content;
	  if (!special.test(text)) {
	    builder.col += text.length;
	    content = document.createTextNode(displayText);
	    builder.map.push(builder.pos, builder.pos + text.length, content);
	    if (ie && ie_version < 9) { mustWrap = true; }
	    builder.pos += text.length;
	  } else {
	    content = document.createDocumentFragment();
	    var pos = 0;
	    while (true) {
	      special.lastIndex = pos;
	      var m = special.exec(text);
	      var skipped = m ? m.index - pos : text.length - pos;
	      if (skipped) {
	        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
	        else { content.appendChild(txt); }
	        builder.map.push(builder.pos, builder.pos + skipped, txt);
	        builder.col += skipped;
	        builder.pos += skipped;
	      }
	      if (!m) { break }
	      pos += skipped + 1;
	      var txt$1 = (void 0);
	      if (m[0] == "\t") {
	        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	        txt$1.setAttribute("role", "presentation");
	        txt$1.setAttribute("cm-text", "\t");
	        builder.col += tabWidth;
	      } else if (m[0] == "\r" || m[0] == "\n") {
	        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	        txt$1.setAttribute("cm-text", m[0]);
	        builder.col += 1;
	      } else {
	        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
	        txt$1.setAttribute("cm-text", m[0]);
	        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
	        else { content.appendChild(txt$1); }
	        builder.col += 1;
	      }
	      builder.map.push(builder.pos, builder.pos + 1, txt$1);
	      builder.pos++;
	    }
	  }
	  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
	  if (style || startStyle || endStyle || mustWrap || css) {
	    var fullStyle = style || "";
	    if (startStyle) { fullStyle += startStyle; }
	    if (endStyle) { fullStyle += endStyle; }
	    var token = elt("span", [content], fullStyle, css);
	    if (title) { token.title = title; }
	    return builder.content.appendChild(token)
	  }
	  builder.content.appendChild(content);
	}

	function splitSpaces(text, trailingBefore) {
	  if (text.length > 1 && !/  /.test(text)) { return text }
	  var spaceBefore = trailingBefore, result = "";
	  for (var i = 0; i < text.length; i++) {
	    var ch = text.charAt(i);
	    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	      { ch = "\u00a0"; }
	    result += ch;
	    spaceBefore = ch == " ";
	  }
	  return result
	}

	// Work around nonsense dimensions being reported for stretches of
	// right-to-left text.
	function buildTokenBadBidi(inner, order) {
	  return function (builder, text, style, startStyle, endStyle, title, css) {
	    style = style ? style + " cm-force-border" : "cm-force-border";
	    var start = builder.pos, end = start + text.length;
	    for (;;) {
	      // Find the part that overlaps with the start of this text
	      var part = (void 0);
	      for (var i = 0; i < order.length; i++) {
	        part = order[i];
	        if (part.to > start && part.from <= start) { break }
	      }
	      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
	      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
	      startStyle = null;
	      text = text.slice(part.to - start);
	      start = part.to;
	    }
	  }
	}

	function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	  var widget = !ignoreWidget && marker.widgetNode;
	  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
	  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	    if (!widget)
	      { widget = builder.content.appendChild(document.createElement("span")); }
	    widget.setAttribute("cm-marker", marker.id);
	  }
	  if (widget) {
	    builder.cm.display.input.setUneditable(widget);
	    builder.content.appendChild(widget);
	  }
	  builder.pos += size;
	  builder.trailingSpace = false;
	}

	// Outputs a number of spans to make up a line, taking highlighting
	// and marked text into account.
	function insertLineContent(line, builder, styles) {
	  var spans = line.markedSpans, allText = line.text, at = 0;
	  if (!spans) {
	    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
	      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
	    return
	  }

	  var len = allText.length, pos = 0, i = 1, text = "", style, css;
	  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
	  for (;;) {
	    if (nextChange == pos) { // Update current marker set
	      spanStyle = spanEndStyle = spanStartStyle = title = css = "";
	      collapsed = null; nextChange = Infinity;
	      var foundBookmarks = [], endStyles = (void 0);
	      for (var j = 0; j < spans.length; ++j) {
	        var sp = spans[j], m = sp.marker;
	        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	          foundBookmarks.push(m);
	        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	            nextChange = sp.to;
	            spanEndStyle = "";
	          }
	          if (m.className) { spanStyle += " " + m.className; }
	          if (m.css) { css = (css ? css + ";" : "") + m.css; }
	          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
	          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
	          if (m.title && !title) { title = m.title; }
	          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	            { collapsed = sp; }
	        } else if (sp.from > pos && nextChange > sp.from) {
	          nextChange = sp.from;
	        }
	      }
	      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
	        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

	      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
	        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
	      if (collapsed && (collapsed.from || 0) == pos) {
	        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                           collapsed.marker, collapsed.from == null);
	        if (collapsed.to == null) { return }
	        if (collapsed.to == pos) { collapsed = false; }
	      }
	    }
	    if (pos >= len) { break }

	    var upto = Math.min(len, nextChange);
	    while (true) {
	      if (text) {
	        var end = pos + text.length;
	        if (!collapsed) {
	          var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
	        }
	        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
	        pos = end;
	        spanStartStyle = "";
	      }
	      text = allText.slice(at, at = styles[i++]);
	      style = interpretTokenStyle(styles[i++], builder.cm.options);
	    }
	  }
	}


	// These objects are used to represent the visible (currently drawn)
	// part of the document. A LineView may correspond to multiple
	// logical lines, if those are connected by collapsed ranges.
	function LineView(doc, line, lineN) {
	  // The starting line
	  this.line = line;
	  // Continuing lines, if any
	  this.rest = visualLineContinued(line);
	  // Number of logical lines in this visual line
	  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	  this.node = this.text = null;
	  this.hidden = lineIsHidden(doc, line);
	}

	// Create a range of LineView objects for the given lines.
	function buildViewArray(cm, from, to) {
	  var array = [], nextPos;
	  for (var pos = from; pos < to; pos = nextPos) {
	    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	    nextPos = pos + view.size;
	    array.push(view);
	  }
	  return array
	}

	var operationGroup = null;

	function pushOperation(op) {
	  if (operationGroup) {
	    operationGroup.ops.push(op);
	  } else {
	    op.ownsGroup = operationGroup = {
	      ops: [op],
	      delayedCallbacks: []
	    };
	  }
	}

	function fireCallbacksForOps(group) {
	  // Calls delayed callbacks and cursorActivity handlers until no
	  // new ones appear
	  var callbacks = group.delayedCallbacks, i = 0;
	  do {
	    for (; i < callbacks.length; i++)
	      { callbacks[i].call(null); }
	    for (var j = 0; j < group.ops.length; j++) {
	      var op = group.ops[j];
	      if (op.cursorActivityHandlers)
	        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
	    }
	  } while (i < callbacks.length)
	}

	function finishOperation(op, endCb) {
	  var group = op.ownsGroup;
	  if (!group) { return }

	  try { fireCallbacksForOps(group); }
	  finally {
	    operationGroup = null;
	    endCb(group);
	  }
	}

	var orphanDelayedCallbacks = null;

	// Often, we want to signal events at a point where we are in the
	// middle of some work, but don't want the handler to start calling
	// other methods on the editor, which might be in an inconsistent
	// state or simply not expect any other events to happen.
	// signalLater looks whether there are any handlers, and schedules
	// them to be executed when the last operation ends, or, if no
	// operation is active, when a timeout fires.
	function signalLater(emitter, type /*, values...*/) {
	  var arr = getHandlers(emitter, type);
	  if (!arr.length) { return }
	  var args = Array.prototype.slice.call(arguments, 2), list;
	  if (operationGroup) {
	    list = operationGroup.delayedCallbacks;
	  } else if (orphanDelayedCallbacks) {
	    list = orphanDelayedCallbacks;
	  } else {
	    list = orphanDelayedCallbacks = [];
	    setTimeout(fireOrphanDelayed, 0);
	  }
	  var loop = function ( i ) {
	    list.push(function () { return arr[i].apply(null, args); });
	  };

	  for (var i = 0; i < arr.length; ++i)
	    loop( i );
	}

	function fireOrphanDelayed() {
	  var delayed = orphanDelayedCallbacks;
	  orphanDelayedCallbacks = null;
	  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
	}

	// When an aspect of a line changes, a string is added to
	// lineView.changes. This updates the relevant part of the line's
	// DOM structure.
	function updateLineForChanges(cm, lineView, lineN, dims) {
	  for (var j = 0; j < lineView.changes.length; j++) {
	    var type = lineView.changes[j];
	    if (type == "text") { updateLineText(cm, lineView); }
	    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
	    else if (type == "class") { updateLineClasses(cm, lineView); }
	    else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
	  }
	  lineView.changes = null;
	}

	// Lines with gutter elements, widgets or a background class need to
	// be wrapped, and have the extra elements added to the wrapper div
	function ensureLineWrapped(lineView) {
	  if (lineView.node == lineView.text) {
	    lineView.node = elt("div", null, null, "position: relative");
	    if (lineView.text.parentNode)
	      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
	    lineView.node.appendChild(lineView.text);
	    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
	  }
	  return lineView.node
	}

	function updateLineBackground(cm, lineView) {
	  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	  if (cls) { cls += " CodeMirror-linebackground"; }
	  if (lineView.background) {
	    if (cls) { lineView.background.className = cls; }
	    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	  } else if (cls) {
	    var wrap = ensureLineWrapped(lineView);
	    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	    cm.display.input.setUneditable(lineView.background);
	  }
	}

	// Wrapper around buildLineContent which will reuse the structure
	// in display.externalMeasured when possible.
	function getLineContent(cm, lineView) {
	  var ext = cm.display.externalMeasured;
	  if (ext && ext.line == lineView.line) {
	    cm.display.externalMeasured = null;
	    lineView.measure = ext.measure;
	    return ext.built
	  }
	  return buildLineContent(cm, lineView)
	}

	// Redraw the line's text. Interacts with the background and text
	// classes because the mode may output tokens that influence these
	// classes.
	function updateLineText(cm, lineView) {
	  var cls = lineView.text.className;
	  var built = getLineContent(cm, lineView);
	  if (lineView.text == lineView.node) { lineView.node = built.pre; }
	  lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	  lineView.text = built.pre;
	  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	    lineView.bgClass = built.bgClass;
	    lineView.textClass = built.textClass;
	    updateLineClasses(cm, lineView);
	  } else if (cls) {
	    lineView.text.className = cls;
	  }
	}

	function updateLineClasses(cm, lineView) {
	  updateLineBackground(cm, lineView);
	  if (lineView.line.wrapClass)
	    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
	  else if (lineView.node != lineView.text)
	    { lineView.node.className = ""; }
	  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	  lineView.text.className = textClass || "";
	}

	function updateLineGutter(cm, lineView, lineN, dims) {
	  if (lineView.gutter) {
	    lineView.node.removeChild(lineView.gutter);
	    lineView.gutter = null;
	  }
	  if (lineView.gutterBackground) {
	    lineView.node.removeChild(lineView.gutterBackground);
	    lineView.gutterBackground = null;
	  }
	  if (lineView.line.gutterClass) {
	    var wrap = ensureLineWrapped(lineView);
	    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
	    cm.display.input.setUneditable(lineView.gutterBackground);
	    wrap.insertBefore(lineView.gutterBackground, lineView.text);
	  }
	  var markers = lineView.line.gutterMarkers;
	  if (cm.options.lineNumbers || markers) {
	    var wrap$1 = ensureLineWrapped(lineView);
	    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
	    cm.display.input.setUneditable(gutterWrap);
	    wrap$1.insertBefore(gutterWrap, lineView.text);
	    if (lineView.line.gutterClass)
	      { gutterWrap.className += " " + lineView.line.gutterClass; }
	    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	      { lineView.lineNumber = gutterWrap.appendChild(
	        elt("div", lineNumberFor(cm.options, lineN),
	            "CodeMirror-linenumber CodeMirror-gutter-elt",
	            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
	    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
	      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
	      if (found)
	        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
	                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
	    } }
	  }
	}

	function updateLineWidgets(cm, lineView, dims) {
	  if (lineView.alignable) { lineView.alignable = null; }
	  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
	    next = node.nextSibling;
	    if (node.className == "CodeMirror-linewidget")
	      { lineView.node.removeChild(node); }
	  }
	  insertLineWidgets(cm, lineView, dims);
	}

	// Build a line's DOM representation from scratch
	function buildLineElement(cm, lineView, lineN, dims) {
	  var built = getLineContent(cm, lineView);
	  lineView.text = lineView.node = built.pre;
	  if (built.bgClass) { lineView.bgClass = built.bgClass; }
	  if (built.textClass) { lineView.textClass = built.textClass; }

	  updateLineClasses(cm, lineView);
	  updateLineGutter(cm, lineView, lineN, dims);
	  insertLineWidgets(cm, lineView, dims);
	  return lineView.node
	}

	// A lineView may contain multiple logical lines (when merged by
	// collapsed spans). The widgets for all of them need to be drawn.
	function insertLineWidgets(cm, lineView, dims) {
	  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
	  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
	}

	function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	  if (!line.widgets) { return }
	  var wrap = ensureLineWrapped(lineView);
	  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
	    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
	    positionLineWidget(widget, node, lineView, dims);
	    cm.display.input.setUneditable(node);
	    if (allowAbove && widget.above)
	      { wrap.insertBefore(node, lineView.gutter || lineView.text); }
	    else
	      { wrap.appendChild(node); }
	    signalLater(widget, "redraw");
	  }
	}

	function positionLineWidget(widget, node, lineView, dims) {
	  if (widget.noHScroll) {
	    (lineView.alignable || (lineView.alignable = [])).push(node);
	    var width = dims.wrapperWidth;
	    node.style.left = dims.fixedPos + "px";
	    if (!widget.coverGutter) {
	      width -= dims.gutterTotalWidth;
	      node.style.paddingLeft = dims.gutterTotalWidth + "px";
	    }
	    node.style.width = width + "px";
	  }
	  if (widget.coverGutter) {
	    node.style.zIndex = 5;
	    node.style.position = "relative";
	    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
	  }
	}

	function widgetHeight(widget) {
	  if (widget.height != null) { return widget.height }
	  var cm = widget.doc.cm;
	  if (!cm) { return 0 }
	  if (!contains(document.body, widget.node)) {
	    var parentStyle = "position: relative;";
	    if (widget.coverGutter)
	      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
	    if (widget.noHScroll)
	      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
	    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	  }
	  return widget.height = widget.node.parentNode.offsetHeight
	}

	// Return true when the given mouse event happened in a widget
	function eventInWidget(display, e) {
	  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	        (n.parentNode == display.sizer && n != display.mover))
	      { return true }
	  }
	}

	// POSITION MEASUREMENT

	function paddingTop(display) {return display.lineSpace.offsetTop}
	function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
	function paddingH(display) {
	  if (display.cachedPaddingH) { return display.cachedPaddingH }
	  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
	  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
	  return data
	}

	function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
	function displayWidth(cm) {
	  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
	}
	function displayHeight(cm) {
	  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
	}

	// Ensure the lineView.wrapping.heights array is populated. This is
	// an array of bottom offsets for the lines that make up a drawn
	// line. When lineWrapping is on, there might be more than one
	// height.
	function ensureLineHeights(cm, lineView, rect) {
	  var wrapping = cm.options.lineWrapping;
	  var curWidth = wrapping && displayWidth(cm);
	  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	    var heights = lineView.measure.heights = [];
	    if (wrapping) {
	      lineView.measure.width = curWidth;
	      var rects = lineView.text.firstChild.getClientRects();
	      for (var i = 0; i < rects.length - 1; i++) {
	        var cur = rects[i], next = rects[i + 1];
	        if (Math.abs(cur.bottom - next.bottom) > 2)
	          { heights.push((cur.bottom + next.top) / 2 - rect.top); }
	      }
	    }
	    heights.push(rect.bottom - rect.top);
	  }
	}

	// Find a line map (mapping character offsets to text nodes) and a
	// measurement cache for the given line number. (A line view might
	// contain multiple lines when collapsed ranges are present.)
	function mapFromLineView(lineView, line, lineN) {
	  if (lineView.line == line)
	    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
	  for (var i = 0; i < lineView.rest.length; i++)
	    { if (lineView.rest[i] == line)
	      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
	  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
	    { if (lineNo(lineView.rest[i$1]) > lineN)
	      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
	}

	// Render a line into the hidden node display.externalMeasured. Used
	// when measurement is needed for a line that's not in the viewport.
	function updateExternalMeasurement(cm, line) {
	  line = visualLine(line);
	  var lineN = lineNo(line);
	  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	  view.lineN = lineN;
	  var built = view.built = buildLineContent(cm, view);
	  view.text = built.pre;
	  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	  return view
	}

	// Get a {top, bottom, left, right} box (in line-local coordinates)
	// for a given character.
	function measureChar(cm, line, ch, bias) {
	  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
	}

	// Find a line view that corresponds to the given line number.
	function findViewForLine(cm, lineN) {
	  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	    { return cm.display.view[findViewIndex(cm, lineN)] }
	  var ext = cm.display.externalMeasured;
	  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	    { return ext }
	}

	// Measurement can be split in two steps, the set-up work that
	// applies to the whole line, and the measurement of the actual
	// character. Functions like coordsChar, that need to do a lot of
	// measurements in a row, can thus ensure that the set-up work is
	// only done once.
	function prepareMeasureForLine(cm, line) {
	  var lineN = lineNo(line);
	  var view = findViewForLine(cm, lineN);
	  if (view && !view.text) {
	    view = null;
	  } else if (view && view.changes) {
	    updateLineForChanges(cm, view, lineN, getDimensions(cm));
	    cm.curOp.forceUpdate = true;
	  }
	  if (!view)
	    { view = updateExternalMeasurement(cm, line); }

	  var info = mapFromLineView(view, line, lineN);
	  return {
	    line: line, view: view, rect: null,
	    map: info.map, cache: info.cache, before: info.before,
	    hasHeights: false
	  }
	}

	// Given a prepared measurement object, measures the position of an
	// actual character (or fetches it from the cache).
	function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	  if (prepared.before) { ch = -1; }
	  var key = ch + (bias || ""), found;
	  if (prepared.cache.hasOwnProperty(key)) {
	    found = prepared.cache[key];
	  } else {
	    if (!prepared.rect)
	      { prepared.rect = prepared.view.text.getBoundingClientRect(); }
	    if (!prepared.hasHeights) {
	      ensureLineHeights(cm, prepared.view, prepared.rect);
	      prepared.hasHeights = true;
	    }
	    found = measureCharInner(cm, prepared, ch, bias);
	    if (!found.bogus) { prepared.cache[key] = found; }
	  }
	  return {left: found.left, right: found.right,
	          top: varHeight ? found.rtop : found.top,
	          bottom: varHeight ? found.rbottom : found.bottom}
	}

	var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

	function nodeAndOffsetInLineMap(map$$1, ch, bias) {
	  var node, start, end, collapse, mStart, mEnd;
	  // First, search the line map for the text node corresponding to,
	  // or closest to, the target character.
	  for (var i = 0; i < map$$1.length; i += 3) {
	    mStart = map$$1[i];
	    mEnd = map$$1[i + 1];
	    if (ch < mStart) {
	      start = 0; end = 1;
	      collapse = "left";
	    } else if (ch < mEnd) {
	      start = ch - mStart;
	      end = start + 1;
	    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
	      end = mEnd - mStart;
	      start = end - 1;
	      if (ch >= mEnd) { collapse = "right"; }
	    }
	    if (start != null) {
	      node = map$$1[i + 2];
	      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	        { collapse = bias; }
	      if (bias == "left" && start == 0)
	        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
	          node = map$$1[(i -= 3) + 2];
	          collapse = "left";
	        } }
	      if (bias == "right" && start == mEnd - mStart)
	        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
	          node = map$$1[(i += 3) + 2];
	          collapse = "right";
	        } }
	      break
	    }
	  }
	  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
	}

	function getUsefulRect(rects, bias) {
	  var rect = nullRect;
	  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
	    if ((rect = rects[i]).left != rect.right) { break }
	  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
	    if ((rect = rects[i$1]).left != rect.right) { break }
	  } }
	  return rect
	}

	function measureCharInner(cm, prepared, ch, bias) {
	  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

	  var rect;
	  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
	      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
	      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	        { rect = node.parentNode.getBoundingClientRect(); }
	      else
	        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
	      if (rect.left || rect.right || start == 0) { break }
	      end = start;
	      start = start - 1;
	      collapse = "right";
	    }
	    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
	  } else { // If it is a widget, simply get the box for the whole widget.
	    if (start > 0) { collapse = bias = "right"; }
	    var rects;
	    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	      { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
	    else
	      { rect = node.getBoundingClientRect(); }
	  }
	  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	    var rSpan = node.parentNode.getClientRects()[0];
	    if (rSpan)
	      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
	    else
	      { rect = nullRect; }
	  }

	  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	  var mid = (rtop + rbot) / 2;
	  var heights = prepared.view.measure.heights;
	  var i = 0;
	  for (; i < heights.length - 1; i++)
	    { if (mid < heights[i]) { break } }
	  var top = i ? heights[i - 1] : 0, bot = heights[i];
	  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                top: top, bottom: bot};
	  if (!rect.left && !rect.right) { result.bogus = true; }
	  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

	  return result
	}

	// Work around problem with bounding client rects on ranges being
	// returned incorrectly when zoomed on IE10 and below.
	function maybeUpdateRectForZooming(measure, rect) {
	  if (!window.screen || screen.logicalXDPI == null ||
	      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	    { return rect }
	  var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	  var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	  return {left: rect.left * scaleX, right: rect.right * scaleX,
	          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
	}

	function clearLineMeasurementCacheFor(lineView) {
	  if (lineView.measure) {
	    lineView.measure.cache = {};
	    lineView.measure.heights = null;
	    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	      { lineView.measure.caches[i] = {}; } }
	  }
	}

	function clearLineMeasurementCache(cm) {
	  cm.display.externalMeasure = null;
	  removeChildren(cm.display.lineMeasure);
	  for (var i = 0; i < cm.display.view.length; i++)
	    { clearLineMeasurementCacheFor(cm.display.view[i]); }
	}

	function clearCaches(cm) {
	  clearLineMeasurementCache(cm);
	  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
	  cm.display.lineNumChars = null;
	}

	function pageScrollX() {
	  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
	  // which causes page_Offset and bounding client rects to use
	  // different reference viewports and invalidate our calculations.
	  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
	  return window.pageXOffset || (document.documentElement || document.body).scrollLeft
	}
	function pageScrollY() {
	  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
	  return window.pageYOffset || (document.documentElement || document.body).scrollTop
	}

	function widgetTopHeight(lineObj) {
	  var height = 0;
	  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
	    { height += widgetHeight(lineObj.widgets[i]); } } }
	  return height
	}

	// Converts a {top, bottom, left, right} box from line-local
	// coordinates into another coordinate system. Context may be one of
	// "line", "div" (display.lineDiv), "local"./null (editor), "window",
	// or "page".
	function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
	  if (!includeWidgets) {
	    var height = widgetTopHeight(lineObj);
	    rect.top += height; rect.bottom += height;
	  }
	  if (context == "line") { return rect }
	  if (!context) { context = "local"; }
	  var yOff = heightAtLine(lineObj);
	  if (context == "local") { yOff += paddingTop(cm.display); }
	  else { yOff -= cm.display.viewOffset; }
	  if (context == "page" || context == "window") {
	    var lOff = cm.display.lineSpace.getBoundingClientRect();
	    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	    rect.left += xOff; rect.right += xOff;
	  }
	  rect.top += yOff; rect.bottom += yOff;
	  return rect
	}

	// Coverts a box from "div" coords to another coordinate system.
	// Context may be "window", "page", "div", or "local"./null.
	function fromCoordSystem(cm, coords, context) {
	  if (context == "div") { return coords }
	  var left = coords.left, top = coords.top;
	  // First move into "page" coordinate system
	  if (context == "page") {
	    left -= pageScrollX();
	    top -= pageScrollY();
	  } else if (context == "local" || !context) {
	    var localBox = cm.display.sizer.getBoundingClientRect();
	    left += localBox.left;
	    top += localBox.top;
	  }

	  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
	}

	function charCoords(cm, pos, context, lineObj, bias) {
	  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
	  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
	}

	// Returns a box for a given cursor position, which may have an
	// 'other' property containing the position of the secondary cursor
	// on a bidi boundary.
	// A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
	// and after `char - 1` in writing order of `char - 1`
	// A cursor Pos(line, char, "after") is on the same visual line as `char`
	// and before `char` in writing order of `char`
	// Examples (upper-case letters are RTL, lower-case are LTR):
	//     Pos(0, 1, ...)
	//     before   after
	// ab     a|b     a|b
	// aB     a|B     aB|
	// Ab     |Ab     A|b
	// AB     B|A     B|A
	// Every position after the last character on a line is considered to stick
	// to the last character on the line.
	function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	  lineObj = lineObj || getLine(cm.doc, pos.line);
	  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	  function get(ch, right) {
	    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	    if (right) { m.left = m.right; } else { m.right = m.left; }
	    return intoCoordSystem(cm, lineObj, m, context)
	  }
	  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
	  if (ch >= lineObj.text.length) {
	    ch = lineObj.text.length;
	    sticky = "before";
	  } else if (ch <= 0) {
	    ch = 0;
	    sticky = "after";
	  }
	  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

	  function getBidi(ch, partPos, invert) {
	    var part = order[partPos], right = part.level == 1;
	    return get(invert ? ch - 1 : ch, right != invert)
	  }
	  var partPos = getBidiPartAt(order, ch, sticky);
	  var other = bidiOther;
	  var val = getBidi(ch, partPos, sticky == "before");
	  if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
	  return val
	}

	// Used to cheaply estimate the coordinates for a position. Used for
	// intermediate scroll updates.
	function estimateCoords(cm, pos) {
	  var left = 0;
	  pos = clipPos(cm.doc, pos);
	  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
	  var lineObj = getLine(cm.doc, pos.line);
	  var top = heightAtLine(lineObj) + paddingTop(cm.display);
	  return {left: left, right: left, top: top, bottom: top + lineObj.height}
	}

	// Positions returned by coordsChar contain some extra information.
	// xRel is the relative x position of the input coordinates compared
	// to the found position (so xRel > 0 means the coordinates are to
	// the right of the character position, for example). When outside
	// is true, that means the coordinates lie outside the line's
	// vertical range.
	function PosWithInfo(line, ch, sticky, outside, xRel) {
	  var pos = Pos(line, ch, sticky);
	  pos.xRel = xRel;
	  if (outside) { pos.outside = true; }
	  return pos
	}

	// Compute the character position closest to the given coordinates.
	// Input must be lineSpace-local ("div" coordinate system).
	function coordsChar(cm, x, y) {
	  var doc = cm.doc;
	  y += cm.display.viewOffset;
	  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
	  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	  if (lineN > last)
	    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
	  if (x < 0) { x = 0; }

	  var lineObj = getLine(doc, lineN);
	  for (;;) {
	    var found = coordsCharInner(cm, lineObj, lineN, x, y);
	    var merged = collapsedSpanAtEnd(lineObj);
	    var mergedPos = merged && merged.find(0, true);
	    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
	      { lineN = lineNo(lineObj = mergedPos.to.line); }
	    else
	      { return found }
	  }
	}

	function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
	  y -= widgetTopHeight(lineObj);
	  var end = lineObj.text.length;
	  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
	  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
	  return {begin: begin, end: end}
	}

	function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
	  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
	  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
	}

	// Returns true if the given side of a box is after the given
	// coordinates, in top-to-bottom, left-to-right order.
	function boxIsAfter(box, x, y, left) {
	  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
	}

	function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
	  // Move y into line-local coordinate space
	  y -= heightAtLine(lineObj);
	  var preparedMeasure = prepareMeasureForLine(cm, lineObj);
	  // When directly calling `measureCharPrepared`, we have to adjust
	  // for the widgets at this line.
	  var widgetHeight$$1 = widgetTopHeight(lineObj);
	  var begin = 0, end = lineObj.text.length, ltr = true;

	  var order = getOrder(lineObj, cm.doc.direction);
	  // If the line isn't plain left-to-right text, first figure out
	  // which bidi section the coordinates fall into.
	  if (order) {
	    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
	                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
	    ltr = part.level != 1;
	    // The awkward -1 offsets are needed because findFirst (called
	    // on these below) will treat its first bound as inclusive,
	    // second as exclusive, but we want to actually address the
	    // characters in the part's range
	    begin = ltr ? part.from : part.to - 1;
	    end = ltr ? part.to : part.from - 1;
	  }

	  // A binary search to find the first character whose bounding box
	  // starts after the coordinates. If we run across any whose box wrap
	  // the coordinates, store that.
	  var chAround = null, boxAround = null;
	  var ch = findFirst(function (ch) {
	    var box = measureCharPrepared(cm, preparedMeasure, ch);
	    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;
	    if (!boxIsAfter(box, x, y, false)) { return false }
	    if (box.top <= y && box.left <= x) {
	      chAround = ch;
	      boxAround = box;
	    }
	    return true
	  }, begin, end);

	  var baseX, sticky, outside = false;
	  // If a box around the coordinates was found, use that
	  if (boxAround) {
	    // Distinguish coordinates nearer to the left or right side of the box
	    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
	    ch = chAround + (atStart ? 0 : 1);
	    sticky = atStart ? "after" : "before";
	    baseX = atLeft ? boxAround.left : boxAround.right;
	  } else {
	    // (Adjust for extended bound, if necessary.)
	    if (!ltr && (ch == end || ch == begin)) { ch++; }
	    // To determine which side to associate with, get the box to the
	    // left of the character and compare it's vertical position to the
	    // coordinates
	    sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
	      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?
	      "after" : "before";
	    // Now get accurate coordinates for this place, in order to get a
	    // base X position
	    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
	    baseX = coords.left;
	    outside = y < coords.top || y >= coords.bottom;
	  }

	  ch = skipExtendingChars(lineObj.text, ch, 1);
	  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
	}

	function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
	  // Bidi parts are sorted left-to-right, and in a non-line-wrapping
	  // situation, we can take this ordering to correspond to the visual
	  // ordering. This finds the first part whose end is after the given
	  // coordinates.
	  var index = findFirst(function (i) {
	    var part = order[i], ltr = part.level != 1;
	    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"),
	                                   "line", lineObj, preparedMeasure), x, y, true)
	  }, 0, order.length - 1);
	  var part = order[index];
	  // If this isn't the first part, the part's start is also after
	  // the coordinates, and the coordinates aren't on the same line as
	  // that start, move one part back.
	  if (index > 0) {
	    var ltr = part.level != 1;
	    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"),
	                             "line", lineObj, preparedMeasure);
	    if (boxIsAfter(start, x, y, true) && start.top > y)
	      { part = order[index - 1]; }
	  }
	  return part
	}

	function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
	  // In a wrapped line, rtl text on wrapping boundaries can do things
	  // that don't correspond to the ordering in our `order` array at
	  // all, so a binary search doesn't work, and we want to return a
	  // part that only spans one line so that the binary search in
	  // coordsCharInner is safe. As such, we first find the extent of the
	  // wrapped line, and then do a flat search in which we discard any
	  // spans that aren't on the line.
	  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
	  var begin = ref.begin;
	  var end = ref.end;
	  if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
	  var part = null, closestDist = null;
	  for (var i = 0; i < order.length; i++) {
	    var p = order[i];
	    if (p.from >= end || p.to <= begin) { continue }
	    var ltr = p.level != 1;
	    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
	    // Weigh against spans ending before this, so that they are only
	    // picked if nothing ends after
	    var dist = endX < x ? x - endX + 1e9 : endX - x;
	    if (!part || closestDist > dist) {
	      part = p;
	      closestDist = dist;
	    }
	  }
	  if (!part) { part = order[order.length - 1]; }
	  // Clip the part to the wrapped line.
	  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
	  if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
	  return part
	}

	var measureText;
	// Compute the default text height.
	function textHeight(display) {
	  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
	  if (measureText == null) {
	    measureText = elt("pre");
	    // Measure a bunch of lines, for browsers that compute
	    // fractional heights.
	    for (var i = 0; i < 49; ++i) {
	      measureText.appendChild(document.createTextNode("x"));
	      measureText.appendChild(elt("br"));
	    }
	    measureText.appendChild(document.createTextNode("x"));
	  }
	  removeChildrenAndAdd(display.measure, measureText);
	  var height = measureText.offsetHeight / 50;
	  if (height > 3) { display.cachedTextHeight = height; }
	  removeChildren(display.measure);
	  return height || 1
	}

	// Compute the default character width.
	function charWidth(display) {
	  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
	  var anchor = elt("span", "xxxxxxxxxx");
	  var pre = elt("pre", [anchor]);
	  removeChildrenAndAdd(display.measure, pre);
	  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	  if (width > 2) { display.cachedCharWidth = width; }
	  return width || 10
	}

	// Do a bulk-read of the DOM positions and sizes needed to draw the
	// view, so that we don't interleave reading and writing to the DOM.
	function getDimensions(cm) {
	  var d = cm.display, left = {}, width = {};
	  var gutterLeft = d.gutters.clientLeft;
	  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
	    width[cm.options.gutters[i]] = n.clientWidth;
	  }
	  return {fixedPos: compensateForHScroll(d),
	          gutterTotalWidth: d.gutters.offsetWidth,
	          gutterLeft: left,
	          gutterWidth: width,
	          wrapperWidth: d.wrapper.clientWidth}
	}

	// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	// but using getBoundingClientRect to get a sub-pixel-accurate
	// result.
	function compensateForHScroll(display) {
	  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
	}

	// Returns a function that estimates the height of a line, to use as
	// first approximation until the line becomes visible (and is thus
	// properly measurable).
	function estimateHeight(cm) {
	  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	  return function (line) {
	    if (lineIsHidden(cm.doc, line)) { return 0 }

	    var widgetsHeight = 0;
	    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
	      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
	    } }

	    if (wrapping)
	      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
	    else
	      { return widgetsHeight + th }
	  }
	}

	function estimateLineHeights(cm) {
	  var doc = cm.doc, est = estimateHeight(cm);
	  doc.iter(function (line) {
	    var estHeight = est(line);
	    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	  });
	}

	// Given a mouse event, find the corresponding position. If liberal
	// is false, it checks whether a gutter or scrollbar was clicked,
	// and returns null if it was. forRect is used by rectangular
	// selections, and tries to estimate a character position even for
	// coordinates beyond the right of the text.
	function posFromMouse(cm, e, liberal, forRect) {
	  var display = cm.display;
	  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

	  var x, y, space = display.lineSpace.getBoundingClientRect();
	  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	  try { x = e.clientX - space.left; y = e.clientY - space.top; }
	  catch (e) { return null }
	  var coords = coordsChar(cm, x, y), line;
	  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	  }
	  return coords
	}

	// Find the view element corresponding to a given line. Return null
	// when the line isn't visible.
	function findViewIndex(cm, n) {
	  if (n >= cm.display.viewTo) { return null }
	  n -= cm.display.viewFrom;
	  if (n < 0) { return null }
	  var view = cm.display.view;
	  for (var i = 0; i < view.length; i++) {
	    n -= view[i].size;
	    if (n < 0) { return i }
	  }
	}

	function updateSelection(cm) {
	  cm.display.input.showSelection(cm.display.input.prepareSelection());
	}

	function prepareSelection(cm, primary) {
	  if ( primary === void 0 ) primary = true;

	  var doc = cm.doc, result = {};
	  var curFragment = result.cursors = document.createDocumentFragment();
	  var selFragment = result.selection = document.createDocumentFragment();

	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    if (!primary && i == doc.sel.primIndex) { continue }
	    var range$$1 = doc.sel.ranges[i];
	    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
	    var collapsed = range$$1.empty();
	    if (collapsed || cm.options.showCursorWhenSelecting)
	      { drawSelectionCursor(cm, range$$1.head, curFragment); }
	    if (!collapsed)
	      { drawSelectionRange(cm, range$$1, selFragment); }
	  }
	  return result
	}

	// Draws a cursor for the given range
	function drawSelectionCursor(cm, head, output) {
	  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

	  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	  cursor.style.left = pos.left + "px";
	  cursor.style.top = pos.top + "px";
	  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

	  if (pos.other) {
	    // Secondary cursor, shown when on a 'jump' in bi-directional text
	    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	    otherCursor.style.display = "";
	    otherCursor.style.left = pos.other.left + "px";
	    otherCursor.style.top = pos.other.top + "px";
	    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	  }
	}

	function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

	// Draws the given range as a highlighted selection
	function drawSelectionRange(cm, range$$1, output) {
	  var display = cm.display, doc = cm.doc;
	  var fragment = document.createDocumentFragment();
	  var padding = paddingH(cm.display), leftSide = padding.left;
	  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
	  var docLTR = doc.direction == "ltr";

	  function add(left, top, width, bottom) {
	    if (top < 0) { top = 0; }
	    top = Math.round(top);
	    bottom = Math.round(bottom);
	    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
	  }

	  function drawForLine(line, fromArg, toArg) {
	    var lineObj = getLine(doc, line);
	    var lineLen = lineObj.text.length;
	    var start, end;
	    function coords(ch, bias) {
	      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
	    }

	    function wrapX(pos, dir, side) {
	      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
	      var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
	      var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
	      return coords(ch, prop)[prop]
	    }

	    var order = getOrder(lineObj, doc.direction);
	    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
	      var ltr = dir == "ltr";
	      var fromPos = coords(from, ltr ? "left" : "right");
	      var toPos = coords(to - 1, ltr ? "right" : "left");

	      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
	      var first = i == 0, last = !order || i == order.length - 1;
	      if (toPos.top - fromPos.top <= 3) { // Single line
	        var openLeft = (docLTR ? openStart : openEnd) && first;
	        var openRight = (docLTR ? openEnd : openStart) && last;
	        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
	        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
	        add(left, fromPos.top, right - left, fromPos.bottom);
	      } else { // Multiple lines
	        var topLeft, topRight, botLeft, botRight;
	        if (ltr) {
	          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
	          topRight = docLTR ? rightSide : wrapX(from, dir, "before");
	          botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
	          botRight = docLTR && openEnd && last ? rightSide : toPos.right;
	        } else {
	          topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
	          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
	          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
	          botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
	        }
	        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
	        if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
	        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
	      }

	      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
	      if (cmpCoords(toPos, start) < 0) { start = toPos; }
	      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
	      if (cmpCoords(toPos, end) < 0) { end = toPos; }
	    });
	    return {start: start, end: end}
	  }

	  var sFrom = range$$1.from(), sTo = range$$1.to();
	  if (sFrom.line == sTo.line) {
	    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	  } else {
	    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	    var singleVLine = visualLine(fromLine) == visualLine(toLine);
	    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	    if (singleVLine) {
	      if (leftEnd.top < rightStart.top - 2) {
	        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	      } else {
	        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	      }
	    }
	    if (leftEnd.bottom < rightStart.top)
	      { add(leftSide, leftEnd.bottom, null, rightStart.top); }
	  }

	  output.appendChild(fragment);
	}

	// Cursor-blinking
	function restartBlink(cm) {
	  if (!cm.state.focused) { return }
	  var display = cm.display;
	  clearInterval(display.blinker);
	  var on = true;
	  display.cursorDiv.style.visibility = "";
	  if (cm.options.cursorBlinkRate > 0)
	    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
	      cm.options.cursorBlinkRate); }
	  else if (cm.options.cursorBlinkRate < 0)
	    { display.cursorDiv.style.visibility = "hidden"; }
	}

	function ensureFocus(cm) {
	  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
	}

	function delayBlurEvent(cm) {
	  cm.state.delayingBlurEvent = true;
	  setTimeout(function () { if (cm.state.delayingBlurEvent) {
	    cm.state.delayingBlurEvent = false;
	    onBlur(cm);
	  } }, 100);
	}

	function onFocus(cm, e) {
	  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }

	  if (cm.options.readOnly == "nocursor") { return }
	  if (!cm.state.focused) {
	    signal(cm, "focus", cm, e);
	    cm.state.focused = true;
	    addClass(cm.display.wrapper, "CodeMirror-focused");
	    // This test prevents this from firing when a context
	    // menu is closed (since the input reset would kill the
	    // select-all detection hack)
	    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	      cm.display.input.reset();
	      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
	    }
	    cm.display.input.receivedFocus();
	  }
	  restartBlink(cm);
	}
	function onBlur(cm, e) {
	  if (cm.state.delayingBlurEvent) { return }

	  if (cm.state.focused) {
	    signal(cm, "blur", cm, e);
	    cm.state.focused = false;
	    rmClass(cm.display.wrapper, "CodeMirror-focused");
	  }
	  clearInterval(cm.display.blinker);
	  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
	}

	// Read the actual heights of the rendered lines, and update their
	// stored heights to match.
	function updateHeightsInViewport(cm) {
	  var display = cm.display;
	  var prevBottom = display.lineDiv.offsetTop;
	  for (var i = 0; i < display.view.length; i++) {
	    var cur = display.view[i], height = (void 0);
	    if (cur.hidden) { continue }
	    if (ie && ie_version < 8) {
	      var bot = cur.node.offsetTop + cur.node.offsetHeight;
	      height = bot - prevBottom;
	      prevBottom = bot;
	    } else {
	      var box = cur.node.getBoundingClientRect();
	      height = box.bottom - box.top;
	    }
	    var diff = cur.line.height - height;
	    if (height < 2) { height = textHeight(display); }
	    if (diff > .005 || diff < -.005) {
	      updateLineHeight(cur.line, height);
	      updateWidgetHeight(cur.line);
	      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
	        { updateWidgetHeight(cur.rest[j]); } }
	    }
	  }
	}

	// Read and store the height of line widgets associated with the
	// given line.
	function updateWidgetHeight(line) {
	  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)
	    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }
	}

	// Compute the lines that are visible in a given viewport (defaults
	// the the current scroll position). viewport may contain top,
	// height, and ensure (see op.scrollToPos) properties.
	function visibleLines(display, doc, viewport) {
	  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	  top = Math.floor(top - paddingTop(display));
	  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

	  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	  // forces those lines into the viewport (if possible).
	  if (viewport && viewport.ensure) {
	    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	    if (ensureFrom < from) {
	      from = ensureFrom;
	      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	      to = ensureTo;
	    }
	  }
	  return {from: from, to: Math.max(to, from + 1)}
	}

	// Re-align line numbers and gutter marks to compensate for
	// horizontal scrolling.
	function alignHorizontally(cm) {
	  var display = cm.display, view = display.view;
	  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
	  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	  var gutterW = display.gutters.offsetWidth, left = comp + "px";
	  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
	    if (cm.options.fixedGutter) {
	      if (view[i].gutter)
	        { view[i].gutter.style.left = left; }
	      if (view[i].gutterBackground)
	        { view[i].gutterBackground.style.left = left; }
	    }
	    var align = view[i].alignable;
	    if (align) { for (var j = 0; j < align.length; j++)
	      { align[j].style.left = left; } }
	  } }
	  if (cm.options.fixedGutter)
	    { display.gutters.style.left = (comp + gutterW) + "px"; }
	}

	// Used to ensure that the line number gutter is still the right
	// size for the current document size. Returns true when an update
	// is needed.
	function maybeUpdateLineNumberWidth(cm) {
	  if (!cm.options.lineNumbers) { return false }
	  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	  if (last.length != display.lineNumChars) {
	    var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                               "CodeMirror-linenumber CodeMirror-gutter-elt"));
	    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	    display.lineGutter.style.width = "";
	    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	    display.lineNumWidth = display.lineNumInnerWidth + padding;
	    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	    display.lineGutter.style.width = display.lineNumWidth + "px";
	    updateGutterSpace(cm);
	    return true
	  }
	  return false
	}

	// SCROLLING THINGS INTO VIEW

	// If an editor sits on the top or bottom of the window, partially
	// scrolled out of view, this ensures that the cursor is visible.
	function maybeScrollWindow(cm, rect) {
	  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

	  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	  if (rect.top + box.top < 0) { doScroll = true; }
	  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
	  if (doScroll != null && !phantom) {
	    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
	    cm.display.lineSpace.appendChild(scrollNode);
	    scrollNode.scrollIntoView(doScroll);
	    cm.display.lineSpace.removeChild(scrollNode);
	  }
	}

	// Scroll a given position into view (immediately), verifying that
	// it actually became visible (as line heights are accurately
	// measured, the position of something may 'drift' during drawing).
	function scrollPosIntoView(cm, pos, end, margin) {
	  if (margin == null) { margin = 0; }
	  var rect;
	  if (!cm.options.lineWrapping && pos == end) {
	    // Set pos and end to the cursor positions around the character pos sticks to
	    // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
	    // If pos == Pos(_, 0, "before"), pos and end are unchanged
	    pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
	    end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
	  }
	  for (var limit = 0; limit < 5; limit++) {
	    var changed = false;
	    var coords = cursorCoords(cm, pos);
	    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	    rect = {left: Math.min(coords.left, endCoords.left),
	            top: Math.min(coords.top, endCoords.top) - margin,
	            right: Math.max(coords.left, endCoords.left),
	            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
	    var scrollPos = calculateScrollPos(cm, rect);
	    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	    if (scrollPos.scrollTop != null) {
	      updateScrollTop(cm, scrollPos.scrollTop);
	      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
	    }
	    if (scrollPos.scrollLeft != null) {
	      setScrollLeft(cm, scrollPos.scrollLeft);
	      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
	    }
	    if (!changed) { break }
	  }
	  return rect
	}

	// Scroll a given set of coordinates into view (immediately).
	function scrollIntoView(cm, rect) {
	  var scrollPos = calculateScrollPos(cm, rect);
	  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
	  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
	}

	// Calculate a new scroll position needed to scroll the given
	// rectangle into view. Returns an object with scrollTop and
	// scrollLeft properties. When these are undefined, the
	// vertical/horizontal position does not need to be adjusted.
	function calculateScrollPos(cm, rect) {
	  var display = cm.display, snapMargin = textHeight(cm.display);
	  if (rect.top < 0) { rect.top = 0; }
	  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	  var screen = displayHeight(cm), result = {};
	  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
	  var docBottom = cm.doc.height + paddingVert(display);
	  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
	  if (rect.top < screentop) {
	    result.scrollTop = atTop ? 0 : rect.top;
	  } else if (rect.bottom > screentop + screen) {
	    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
	    if (newTop != screentop) { result.scrollTop = newTop; }
	  }

	  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	  var tooWide = rect.right - rect.left > screenw;
	  if (tooWide) { rect.right = rect.left + screenw; }
	  if (rect.left < 10)
	    { result.scrollLeft = 0; }
	  else if (rect.left < screenleft)
	    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
	  else if (rect.right > screenw + screenleft - 3)
	    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
	  return result
	}

	// Store a relative adjustment to the scroll position in the current
	// operation (to be applied when the operation finishes).
	function addToScrollTop(cm, top) {
	  if (top == null) { return }
	  resolveScrollToPos(cm);
	  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	}

	// Make sure that at the end of the operation the current cursor is
	// shown.
	function ensureCursorVisible(cm) {
	  resolveScrollToPos(cm);
	  var cur = cm.getCursor();
	  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
	}

	function scrollToCoords(cm, x, y) {
	  if (x != null || y != null) { resolveScrollToPos(cm); }
	  if (x != null) { cm.curOp.scrollLeft = x; }
	  if (y != null) { cm.curOp.scrollTop = y; }
	}

	function scrollToRange(cm, range$$1) {
	  resolveScrollToPos(cm);
	  cm.curOp.scrollToPos = range$$1;
	}

	// When an operation has its scrollToPos property set, and another
	// scroll action is applied before the end of the operation, this
	// 'simulates' scrolling that position into view in a cheap way, so
	// that the effect of intermediate scroll commands is not ignored.
	function resolveScrollToPos(cm) {
	  var range$$1 = cm.curOp.scrollToPos;
	  if (range$$1) {
	    cm.curOp.scrollToPos = null;
	    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
	    scrollToCoordsRange(cm, from, to, range$$1.margin);
	  }
	}

	function scrollToCoordsRange(cm, from, to, margin) {
	  var sPos = calculateScrollPos(cm, {
	    left: Math.min(from.left, to.left),
	    top: Math.min(from.top, to.top) - margin,
	    right: Math.max(from.right, to.right),
	    bottom: Math.max(from.bottom, to.bottom) + margin
	  });
	  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
	}

	// Sync the scrollable area and scrollbars, ensure the viewport
	// covers the visible area.
	function updateScrollTop(cm, val) {
	  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
	  if (!gecko) { updateDisplaySimple(cm, {top: val}); }
	  setScrollTop(cm, val, true);
	  if (gecko) { updateDisplaySimple(cm); }
	  startWorker(cm, 100);
	}

	function setScrollTop(cm, val, forceScroll) {
	  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);
	  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
	  cm.doc.scrollTop = val;
	  cm.display.scrollbars.setScrollTop(val);
	  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
	}

	// Sync scroller and scrollbar, ensure the gutter elements are
	// aligned.
	function setScrollLeft(cm, val, isScroller, forceScroll) {
	  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
	  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
	  cm.doc.scrollLeft = val;
	  alignHorizontally(cm);
	  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
	  cm.display.scrollbars.setScrollLeft(val);
	}

	// SCROLLBARS

	// Prepare DOM reads needed to update the scrollbars. Done in one
	// shot to minimize update/measure roundtrips.
	function measureForScrollbars(cm) {
	  var d = cm.display, gutterW = d.gutters.offsetWidth;
	  var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	  return {
	    clientHeight: d.scroller.clientHeight,
	    viewHeight: d.wrapper.clientHeight,
	    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	    viewWidth: d.wrapper.clientWidth,
	    barLeft: cm.options.fixedGutter ? gutterW : 0,
	    docHeight: docH,
	    scrollHeight: docH + scrollGap(cm) + d.barHeight,
	    nativeBarWidth: d.nativeBarWidth,
	    gutterWidth: gutterW
	  }
	}

	var NativeScrollbars = function(place, scroll, cm) {
	  this.cm = cm;
	  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	  place(vert); place(horiz);

	  on(vert, "scroll", function () {
	    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
	  });
	  on(horiz, "scroll", function () {
	    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
	  });

	  this.checkedZeroWidth = false;
	  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
	};

	NativeScrollbars.prototype.update = function (measure) {
	  var needsH = measure.scrollWidth > measure.clientWidth + 1;
	  var needsV = measure.scrollHeight > measure.clientHeight + 1;
	  var sWidth = measure.nativeBarWidth;

	  if (needsV) {
	    this.vert.style.display = "block";
	    this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	    // A bug in IE8 can cause this value to be negative, so guard it.
	    this.vert.firstChild.style.height =
	      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	  } else {
	    this.vert.style.display = "";
	    this.vert.firstChild.style.height = "0";
	  }

	  if (needsH) {
	    this.horiz.style.display = "block";
	    this.horiz.style.right = needsV ? sWidth + "px" : "0";
	    this.horiz.style.left = measure.barLeft + "px";
	    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	    this.horiz.firstChild.style.width =
	      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	  } else {
	    this.horiz.style.display = "";
	    this.horiz.firstChild.style.width = "0";
	  }

	  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	    if (sWidth == 0) { this.zeroWidthHack(); }
	    this.checkedZeroWidth = true;
	  }

	  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
	};

	NativeScrollbars.prototype.setScrollLeft = function (pos) {
	  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
	  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
	};

	NativeScrollbars.prototype.setScrollTop = function (pos) {
	  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
	  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
	};

	NativeScrollbars.prototype.zeroWidthHack = function () {
	  var w = mac && !mac_geMountainLion ? "12px" : "18px";
	  this.horiz.style.height = this.vert.style.width = w;
	  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	  this.disableHoriz = new Delayed;
	  this.disableVert = new Delayed;
	};

	NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
	  bar.style.pointerEvents = "auto";
	  function maybeDisable() {
	    // To find out whether the scrollbar is still visible, we
	    // check whether the element under the pixel in the bottom
	    // right corner of the scrollbar box is the scrollbar box
	    // itself (when the bar is still visible) or its filler child
	    // (when the bar is hidden). If it is still visible, we keep
	    // it enabled, if it's hidden, we disable pointer events.
	    var box = bar.getBoundingClientRect();
	    var elt$$1 = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
	        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
	    if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
	    else { delay.set(1000, maybeDisable); }
	  }
	  delay.set(1000, maybeDisable);
	};

	NativeScrollbars.prototype.clear = function () {
	  var parent = this.horiz.parentNode;
	  parent.removeChild(this.horiz);
	  parent.removeChild(this.vert);
	};

	var NullScrollbars = function () {};

	NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
	NullScrollbars.prototype.setScrollLeft = function () {};
	NullScrollbars.prototype.setScrollTop = function () {};
	NullScrollbars.prototype.clear = function () {};

	function updateScrollbars(cm, measure) {
	  if (!measure) { measure = measureForScrollbars(cm); }
	  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	  updateScrollbarsInner(cm, measure);
	  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	      { updateHeightsInViewport(cm); }
	    updateScrollbarsInner(cm, measureForScrollbars(cm));
	    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	  }
	}

	// Re-synchronize the fake scrollbars with the actual size of the
	// content.
	function updateScrollbarsInner(cm, measure) {
	  var d = cm.display;
	  var sizes = d.scrollbars.update(measure);

	  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

	  if (sizes.right && sizes.bottom) {
	    d.scrollbarFiller.style.display = "block";
	    d.scrollbarFiller.style.height = sizes.bottom + "px";
	    d.scrollbarFiller.style.width = sizes.right + "px";
	  } else { d.scrollbarFiller.style.display = ""; }
	  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	    d.gutterFiller.style.display = "block";
	    d.gutterFiller.style.height = sizes.bottom + "px";
	    d.gutterFiller.style.width = measure.gutterWidth + "px";
	  } else { d.gutterFiller.style.display = ""; }
	}

	var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

	function initScrollbars(cm) {
	  if (cm.display.scrollbars) {
	    cm.display.scrollbars.clear();
	    if (cm.display.scrollbars.addClass)
	      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	  }

	  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
	    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	    // Prevent clicks in the scrollbars from killing focus
	    on(node, "mousedown", function () {
	      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
	    });
	    node.setAttribute("cm-not-content", "true");
	  }, function (pos, axis) {
	    if (axis == "horizontal") { setScrollLeft(cm, pos); }
	    else { updateScrollTop(cm, pos); }
	  }, cm);
	  if (cm.display.scrollbars.addClass)
	    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	}

	// Operations are used to wrap a series of changes to the editor
	// state in such a way that each change won't have to update the
	// cursor and display (which would be awkward, slow, and
	// error-prone). Instead, display updates are batched and then all
	// combined and executed at once.

	var nextOpId = 0;
	// Start a new operation.
	function startOperation(cm) {
	  cm.curOp = {
	    cm: cm,
	    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	    startHeight: cm.doc.height, // Used to detect need to update scrollbar
	    forceUpdate: false,      // Used to force a redraw
	    updateInput: null,       // Whether to reset the input textarea
	    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	    changeObjs: null,        // Accumulated changes, for firing change events
	    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	    selectionChanged: false, // Whether the selection needs to be redrawn
	    updateMaxLine: false,    // Set when the widest line needs to be determined anew
	    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	    scrollToPos: null,       // Used to scroll to a specific position
	    focus: false,
	    id: ++nextOpId           // Unique ID
	  };
	  pushOperation(cm.curOp);
	}

	// Finish an operation, updating the display and signalling delayed events
	function endOperation(cm) {
	  var op = cm.curOp;
	  finishOperation(op, function (group) {
	    for (var i = 0; i < group.ops.length; i++)
	      { group.ops[i].cm.curOp = null; }
	    endOperations(group);
	  });
	}

	// The DOM updates done when an operation finishes are batched so
	// that the minimum number of relayouts are required.
	function endOperations(group) {
	  var ops = group.ops;
	  for (var i = 0; i < ops.length; i++) // Read DOM
	    { endOperation_R1(ops[i]); }
	  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
	    { endOperation_W1(ops[i$1]); }
	  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
	    { endOperation_R2(ops[i$2]); }
	  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
	    { endOperation_W2(ops[i$3]); }
	  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
	    { endOperation_finish(ops[i$4]); }
	}

	function endOperation_R1(op) {
	  var cm = op.cm, display = cm.display;
	  maybeClipScrollbars(cm);
	  if (op.updateMaxLine) { findMaxLine(cm); }

	  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                       op.scrollToPos.to.line >= display.viewTo) ||
	    display.maxLineChanged && cm.options.lineWrapping;
	  op.update = op.mustUpdate &&
	    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	}

	function endOperation_W1(op) {
	  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	}

	function endOperation_R2(op) {
	  var cm = op.cm, display = cm.display;
	  if (op.updatedDisplay) { updateHeightsInViewport(cm); }

	  op.barMeasure = measureForScrollbars(cm);

	  // If the max line changed since it was last measured, measure it,
	  // and ensure the document's width matches it.
	  // updateDisplay_W2 will use these properties to do the actual resizing
	  if (display.maxLineChanged && !cm.options.lineWrapping) {
	    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	    cm.display.sizerWidth = op.adjustWidthTo;
	    op.barMeasure.scrollWidth =
	      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	  }

	  if (op.updatedDisplay || op.selectionChanged)
	    { op.preparedSelection = display.input.prepareSelection(); }
	}

	function endOperation_W2(op) {
	  var cm = op.cm;

	  if (op.adjustWidthTo != null) {
	    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	    if (op.maxScrollLeft < cm.doc.scrollLeft)
	      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
	    cm.display.maxLineChanged = false;
	  }

	  var takeFocus = op.focus && op.focus == activeElt();
	  if (op.preparedSelection)
	    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
	  if (op.updatedDisplay || op.startHeight != cm.doc.height)
	    { updateScrollbars(cm, op.barMeasure); }
	  if (op.updatedDisplay)
	    { setDocumentHeight(cm, op.barMeasure); }

	  if (op.selectionChanged) { restartBlink(cm); }

	  if (cm.state.focused && op.updateInput)
	    { cm.display.input.reset(op.typing); }
	  if (takeFocus) { ensureFocus(op.cm); }
	}

	function endOperation_finish(op) {
	  var cm = op.cm, display = cm.display, doc = cm.doc;

	  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

	  // Abort mouse wheel delta measurement, when scrolling explicitly
	  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	    { display.wheelStartX = display.wheelStartY = null; }

	  // Propagate the scroll position to the actual DOM scroller
	  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

	  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
	  // If we need to scroll a specific position into view, do so.
	  if (op.scrollToPos) {
	    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	    maybeScrollWindow(cm, rect);
	  }

	  // Fire events for markers that are hidden/unidden by editing or
	  // undoing
	  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	  if (hidden) { for (var i = 0; i < hidden.length; ++i)
	    { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
	  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
	    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

	  if (display.wrapper.offsetHeight)
	    { doc.scrollTop = cm.display.scroller.scrollTop; }

	  // Fire change events, and delayed event handlers
	  if (op.changeObjs)
	    { signal(cm, "changes", cm, op.changeObjs); }
	  if (op.update)
	    { op.update.finish(); }
	}

	// Run the given function in an operation
	function runInOp(cm, f) {
	  if (cm.curOp) { return f() }
	  startOperation(cm);
	  try { return f() }
	  finally { endOperation(cm); }
	}
	// Wraps a function in an operation. Returns the wrapped function.
	function operation(cm, f) {
	  return function() {
	    if (cm.curOp) { return f.apply(cm, arguments) }
	    startOperation(cm);
	    try { return f.apply(cm, arguments) }
	    finally { endOperation(cm); }
	  }
	}
	// Used to add methods to editor and doc instances, wrapping them in
	// operations.
	function methodOp(f) {
	  return function() {
	    if (this.curOp) { return f.apply(this, arguments) }
	    startOperation(this);
	    try { return f.apply(this, arguments) }
	    finally { endOperation(this); }
	  }
	}
	function docMethodOp(f) {
	  return function() {
	    var cm = this.cm;
	    if (!cm || cm.curOp) { return f.apply(this, arguments) }
	    startOperation(cm);
	    try { return f.apply(this, arguments) }
	    finally { endOperation(cm); }
	  }
	}

	// Updates the display.view data structure for a given change to the
	// document. From and to are in pre-change coordinates. Lendiff is
	// the amount of lines added or subtracted by the change. This is
	// used for changes that span multiple lines, or change the way
	// lines are divided into visual lines. regLineChange (below)
	// registers single-line changes.
	function regChange(cm, from, to, lendiff) {
	  if (from == null) { from = cm.doc.first; }
	  if (to == null) { to = cm.doc.first + cm.doc.size; }
	  if (!lendiff) { lendiff = 0; }

	  var display = cm.display;
	  if (lendiff && to < display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers > from))
	    { display.updateLineNumbers = from; }

	  cm.curOp.viewChanged = true;

	  if (from >= display.viewTo) { // Change after
	    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	      { resetView(cm); }
	  } else if (to <= display.viewFrom) { // Change before
	    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	      resetView(cm);
	    } else {
	      display.viewFrom += lendiff;
	      display.viewTo += lendiff;
	    }
	  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	    resetView(cm);
	  } else if (from <= display.viewFrom) { // Top overlap
	    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	    if (cut) {
	      display.view = display.view.slice(cut.index);
	      display.viewFrom = cut.lineN;
	      display.viewTo += lendiff;
	    } else {
	      resetView(cm);
	    }
	  } else if (to >= display.viewTo) { // Bottom overlap
	    var cut$1 = viewCuttingPoint(cm, from, from, -1);
	    if (cut$1) {
	      display.view = display.view.slice(0, cut$1.index);
	      display.viewTo = cut$1.lineN;
	    } else {
	      resetView(cm);
	    }
	  } else { // Gap in the middle
	    var cutTop = viewCuttingPoint(cm, from, from, -1);
	    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	    if (cutTop && cutBot) {
	      display.view = display.view.slice(0, cutTop.index)
	        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	        .concat(display.view.slice(cutBot.index));
	      display.viewTo += lendiff;
	    } else {
	      resetView(cm);
	    }
	  }

	  var ext = display.externalMeasured;
	  if (ext) {
	    if (to < ext.lineN)
	      { ext.lineN += lendiff; }
	    else if (from < ext.lineN + ext.size)
	      { display.externalMeasured = null; }
	  }
	}

	// Register a change to a single line. Type must be one of "text",
	// "gutter", "class", "widget"
	function regLineChange(cm, line, type) {
	  cm.curOp.viewChanged = true;
	  var display = cm.display, ext = cm.display.externalMeasured;
	  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	    { display.externalMeasured = null; }

	  if (line < display.viewFrom || line >= display.viewTo) { return }
	  var lineView = display.view[findViewIndex(cm, line)];
	  if (lineView.node == null) { return }
	  var arr = lineView.changes || (lineView.changes = []);
	  if (indexOf(arr, type) == -1) { arr.push(type); }
	}

	// Clear the view.
	function resetView(cm) {
	  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	  cm.display.view = [];
	  cm.display.viewOffset = 0;
	}

	function viewCuttingPoint(cm, oldN, newN, dir) {
	  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	    { return {index: index, lineN: newN} }
	  var n = cm.display.viewFrom;
	  for (var i = 0; i < index; i++)
	    { n += view[i].size; }
	  if (n != oldN) {
	    if (dir > 0) {
	      if (index == view.length - 1) { return null }
	      diff = (n + view[index].size) - oldN;
	      index++;
	    } else {
	      diff = n - oldN;
	    }
	    oldN += diff; newN += diff;
	  }
	  while (visualLineNo(cm.doc, newN) != newN) {
	    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
	    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	    index += dir;
	  }
	  return {index: index, lineN: newN}
	}

	// Force the view to cover a given range, adding empty view element
	// or clipping off existing ones as needed.
	function adjustView(cm, from, to) {
	  var display = cm.display, view = display.view;
	  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	    display.view = buildViewArray(cm, from, to);
	    display.viewFrom = from;
	  } else {
	    if (display.viewFrom > from)
	      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
	    else if (display.viewFrom < from)
	      { display.view = display.view.slice(findViewIndex(cm, from)); }
	    display.viewFrom = from;
	    if (display.viewTo < to)
	      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
	    else if (display.viewTo > to)
	      { display.view = display.view.slice(0, findViewIndex(cm, to)); }
	  }
	  display.viewTo = to;
	}

	// Count the number of lines in the view whose DOM representation is
	// out of date (or nonexistent).
	function countDirtyView(cm) {
	  var view = cm.display.view, dirty = 0;
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i];
	    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
	  }
	  return dirty
	}

	// HIGHLIGHT WORKER

	function startWorker(cm, time) {
	  if (cm.doc.highlightFrontier < cm.display.viewTo)
	    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
	}

	function highlightWorker(cm) {
	  var doc = cm.doc;
	  if (doc.highlightFrontier >= cm.display.viewTo) { return }
	  var end = +new Date + cm.options.workTime;
	  var context = getContextBefore(cm, doc.highlightFrontier);
	  var changedLines = [];

	  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
	    if (context.line >= cm.display.viewFrom) { // Visible
	      var oldStyles = line.styles;
	      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
	      var highlighted = highlightLine(cm, line, context, true);
	      if (resetState) { context.state = resetState; }
	      line.styles = highlighted.styles;
	      var oldCls = line.styleClasses, newCls = highlighted.classes;
	      if (newCls) { line.styleClasses = newCls; }
	      else if (oldCls) { line.styleClasses = null; }
	      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
	      if (ischange) { changedLines.push(context.line); }
	      line.stateAfter = context.save();
	      context.nextLine();
	    } else {
	      if (line.text.length <= cm.options.maxHighlightLength)
	        { processLine(cm, line.text, context); }
	      line.stateAfter = context.line % 5 == 0 ? context.save() : null;
	      context.nextLine();
	    }
	    if (+new Date > end) {
	      startWorker(cm, cm.options.workDelay);
	      return true
	    }
	  });
	  doc.highlightFrontier = context.line;
	  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
	  if (changedLines.length) { runInOp(cm, function () {
	    for (var i = 0; i < changedLines.length; i++)
	      { regLineChange(cm, changedLines[i], "text"); }
	  }); }
	}

	// DISPLAY DRAWING

	var DisplayUpdate = function(cm, viewport, force) {
	  var display = cm.display;

	  this.viewport = viewport;
	  // Store some values that we'll need later (but don't want to force a relayout for)
	  this.visible = visibleLines(display, cm.doc, viewport);
	  this.editorIsHidden = !display.wrapper.offsetWidth;
	  this.wrapperHeight = display.wrapper.clientHeight;
	  this.wrapperWidth = display.wrapper.clientWidth;
	  this.oldDisplayWidth = displayWidth(cm);
	  this.force = force;
	  this.dims = getDimensions(cm);
	  this.events = [];
	};

	DisplayUpdate.prototype.signal = function (emitter, type) {
	  if (hasHandler(emitter, type))
	    { this.events.push(arguments); }
	};
	DisplayUpdate.prototype.finish = function () {
	    var this$1 = this;

	  for (var i = 0; i < this.events.length; i++)
	    { signal.apply(null, this$1.events[i]); }
	};

	function maybeClipScrollbars(cm) {
	  var display = cm.display;
	  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	    display.heightForcer.style.height = scrollGap(cm) + "px";
	    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	    display.scrollbarsClipped = true;
	  }
	}

	function selectionSnapshot(cm) {
	  if (cm.hasFocus()) { return null }
	  var active = activeElt();
	  if (!active || !contains(cm.display.lineDiv, active)) { return null }
	  var result = {activeElt: active};
	  if (window.getSelection) {
	    var sel = window.getSelection();
	    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
	      result.anchorNode = sel.anchorNode;
	      result.anchorOffset = sel.anchorOffset;
	      result.focusNode = sel.focusNode;
	      result.focusOffset = sel.focusOffset;
	    }
	  }
	  return result
	}

	function restoreSelection(snapshot) {
	  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
	  snapshot.activeElt.focus();
	  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
	    var sel = window.getSelection(), range$$1 = document.createRange();
	    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
	    range$$1.collapse(false);
	    sel.removeAllRanges();
	    sel.addRange(range$$1);
	    sel.extend(snapshot.focusNode, snapshot.focusOffset);
	  }
	}

	// Does the actual updating of the line display. Bails out
	// (returning false) when there is nothing to be done and forced is
	// false.
	function updateDisplayIfNeeded(cm, update) {
	  var display = cm.display, doc = cm.doc;

	  if (update.editorIsHidden) {
	    resetView(cm);
	    return false
	  }

	  // Bail out if the visible area is already rendered and nothing changed.
	  if (!update.force &&
	      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	      display.renderedView == display.view && countDirtyView(cm) == 0)
	    { return false }

	  if (maybeUpdateLineNumberWidth(cm)) {
	    resetView(cm);
	    update.dims = getDimensions(cm);
	  }

	  // Compute a suitable new viewport (from & to)
	  var end = doc.first + doc.size;
	  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
	  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
	  if (sawCollapsedSpans) {
	    from = visualLineNo(cm.doc, from);
	    to = visualLineEndNo(cm.doc, to);
	  }

	  var different = from != display.viewFrom || to != display.viewTo ||
	    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	  adjustView(cm, from, to);

	  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	  // Position the mover div to align with the current scroll position
	  cm.display.mover.style.top = display.viewOffset + "px";

	  var toUpdate = countDirtyView(cm);
	  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	    { return false }

	  // For big changes, we hide the enclosing element during the
	  // update, since that speeds up the operations on most browsers.
	  var selSnapshot = selectionSnapshot(cm);
	  if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
	  patchDisplay(cm, display.updateLineNumbers, update.dims);
	  if (toUpdate > 4) { display.lineDiv.style.display = ""; }
	  display.renderedView = display.view;
	  // There might have been a widget with a focused element that got
	  // hidden or updated, if so re-focus it.
	  restoreSelection(selSnapshot);

	  // Prevent selection and cursors from interfering with the scroll
	  // width and height.
	  removeChildren(display.cursorDiv);
	  removeChildren(display.selectionDiv);
	  display.gutters.style.height = display.sizer.style.minHeight = 0;

	  if (different) {
	    display.lastWrapHeight = update.wrapperHeight;
	    display.lastWrapWidth = update.wrapperWidth;
	    startWorker(cm, 400);
	  }

	  display.updateLineNumbers = null;

	  return true
	}

	function postUpdateDisplay(cm, update) {
	  var viewport = update.viewport;

	  for (var first = true;; first = false) {
	    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	      // Clip forced viewport to actual scrollable area.
	      if (viewport && viewport.top != null)
	        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
	      // Updated line heights might result in the drawn area not
	      // actually covering the viewport. Keep looping until it does.
	      update.visible = visibleLines(cm.display, cm.doc, viewport);
	      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	        { break }
	    }
	    if (!updateDisplayIfNeeded(cm, update)) { break }
	    updateHeightsInViewport(cm);
	    var barMeasure = measureForScrollbars(cm);
	    updateSelection(cm);
	    updateScrollbars(cm, barMeasure);
	    setDocumentHeight(cm, barMeasure);
	    update.force = false;
	  }

	  update.signal(cm, "update", cm);
	  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	  }
	}

	function updateDisplaySimple(cm, viewport) {
	  var update = new DisplayUpdate(cm, viewport);
	  if (updateDisplayIfNeeded(cm, update)) {
	    updateHeightsInViewport(cm);
	    postUpdateDisplay(cm, update);
	    var barMeasure = measureForScrollbars(cm);
	    updateSelection(cm);
	    updateScrollbars(cm, barMeasure);
	    setDocumentHeight(cm, barMeasure);
	    update.finish();
	  }
	}

	// Sync the actual display DOM structure with display.view, removing
	// nodes for lines that are no longer in view, and creating the ones
	// that are not there yet, and updating the ones that are out of
	// date.
	function patchDisplay(cm, updateNumbersFrom, dims) {
	  var display = cm.display, lineNumbers = cm.options.lineNumbers;
	  var container = display.lineDiv, cur = container.firstChild;

	  function rm(node) {
	    var next = node.nextSibling;
	    // Works around a throw-scroll bug in OS X Webkit
	    if (webkit && mac && cm.display.currentWheelTarget == node)
	      { node.style.display = "none"; }
	    else
	      { node.parentNode.removeChild(node); }
	    return next
	  }

	  var view = display.view, lineN = display.viewFrom;
	  // Loop over the elements in the view, syncing cur (the DOM nodes
	  // in display.lineDiv) with the view as we go.
	  for (var i = 0; i < view.length; i++) {
	    var lineView = view[i];
	    if (lineView.hidden) {
	    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	      var node = buildLineElement(cm, lineView, lineN, dims);
	      container.insertBefore(node, cur);
	    } else { // Already drawn
	      while (cur != lineView.node) { cur = rm(cur); }
	      var updateNumber = lineNumbers && updateNumbersFrom != null &&
	        updateNumbersFrom <= lineN && lineView.lineNumber;
	      if (lineView.changes) {
	        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
	        updateLineForChanges(cm, lineView, lineN, dims);
	      }
	      if (updateNumber) {
	        removeChildren(lineView.lineNumber);
	        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	      }
	      cur = lineView.node.nextSibling;
	    }
	    lineN += lineView.size;
	  }
	  while (cur) { cur = rm(cur); }
	}

	function updateGutterSpace(cm) {
	  var width = cm.display.gutters.offsetWidth;
	  cm.display.sizer.style.marginLeft = width + "px";
	}

	function setDocumentHeight(cm, measure) {
	  cm.display.sizer.style.minHeight = measure.docHeight + "px";
	  cm.display.heightForcer.style.top = measure.docHeight + "px";
	  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
	}

	// Rebuild the gutter elements, ensure the margin to the left of the
	// code matches their width.
	function updateGutters(cm) {
	  var gutters = cm.display.gutters, specs = cm.options.gutters;
	  removeChildren(gutters);
	  var i = 0;
	  for (; i < specs.length; ++i) {
	    var gutterClass = specs[i];
	    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
	    if (gutterClass == "CodeMirror-linenumbers") {
	      cm.display.lineGutter = gElt;
	      gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
	    }
	  }
	  gutters.style.display = i ? "" : "none";
	  updateGutterSpace(cm);
	}

	// Make sure the gutters options contains the element
	// "CodeMirror-linenumbers" when the lineNumbers option is true.
	function setGuttersForLineNumbers(options) {
	  var found = indexOf(options.gutters, "CodeMirror-linenumbers");
	  if (found == -1 && options.lineNumbers) {
	    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
	  } else if (found > -1 && !options.lineNumbers) {
	    options.gutters = options.gutters.slice(0);
	    options.gutters.splice(found, 1);
	  }
	}

	// Since the delta values reported on mouse wheel events are
	// unstandardized between browsers and even browser versions, and
	// generally horribly unpredictable, this code starts by measuring
	// the scroll effect that the first few mouse wheel events have,
	// and, from that, detects the way it can convert deltas to pixel
	// offsets afterwards.
	//
	// The reason we want to know the amount a wheel event will scroll
	// is that it gives us a chance to update the display before the
	// actual scrolling happens, reducing flickering.

	var wheelSamples = 0;
	var wheelPixelsPerUnit = null;
	// Fill in a browser-detected starting value on browsers where we
	// know one. These don't have to be accurate -- the result of them
	// being wrong would just be a slight flicker on the first wheel
	// scroll (if it is large enough).
	if (ie) { wheelPixelsPerUnit = -.53; }
	else if (gecko) { wheelPixelsPerUnit = 15; }
	else if (chrome) { wheelPixelsPerUnit = -.7; }
	else if (safari) { wheelPixelsPerUnit = -1/3; }

	function wheelEventDelta(e) {
	  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
	  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
	  else if (dy == null) { dy = e.wheelDelta; }
	  return {x: dx, y: dy}
	}
	function wheelEventPixels(e) {
	  var delta = wheelEventDelta(e);
	  delta.x *= wheelPixelsPerUnit;
	  delta.y *= wheelPixelsPerUnit;
	  return delta
	}

	function onScrollWheel(cm, e) {
	  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

	  var display = cm.display, scroll = display.scroller;
	  // Quit if there's nothing to scroll here
	  var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	  var canScrollY = scroll.scrollHeight > scroll.clientHeight;
	  if (!(dx && canScrollX || dy && canScrollY)) { return }

	  // Webkit browsers on OS X abort momentum scrolls when the target
	  // of the scroll event is removed from the scrollable element.
	  // This hack (see related code in patchDisplay) makes sure the
	  // element is kept around.
	  if (dy && mac && webkit) {
	    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	      for (var i = 0; i < view.length; i++) {
	        if (view[i].node == cur) {
	          cm.display.currentWheelTarget = cur;
	          break outer
	        }
	      }
	    }
	  }

	  // On some browsers, horizontal scrolling will cause redraws to
	  // happen before the gutter has been realigned, causing it to
	  // wriggle around in a most unseemly way. When we have an
	  // estimated pixels/delta value, we just handle horizontal
	  // scrolling entirely here. It'll be slightly off from native, but
	  // better than glitching out.
	  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	    if (dy && canScrollY)
	      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
	    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
	    // Only prevent default scrolling if vertical scrolling is
	    // actually possible. Otherwise, it causes vertical scroll
	    // jitter on OSX trackpads when deltaX is small and deltaY
	    // is large (issue #3579)
	    if (!dy || (dy && canScrollY))
	      { e_preventDefault(e); }
	    display.wheelStartX = null; // Abort measurement, if in progress
	    return
	  }

	  // 'Project' the visible viewport to cover the area that is being
	  // scrolled into view (if we know enough to estimate it).
	  if (dy && wheelPixelsPerUnit != null) {
	    var pixels = dy * wheelPixelsPerUnit;
	    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
	    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
	    updateDisplaySimple(cm, {top: top, bottom: bot});
	  }

	  if (wheelSamples < 20) {
	    if (display.wheelStartX == null) {
	      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	      display.wheelDX = dx; display.wheelDY = dy;
	      setTimeout(function () {
	        if (display.wheelStartX == null) { return }
	        var movedX = scroll.scrollLeft - display.wheelStartX;
	        var movedY = scroll.scrollTop - display.wheelStartY;
	        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	          (movedX && display.wheelDX && movedX / display.wheelDX);
	        display.wheelStartX = display.wheelStartY = null;
	        if (!sample) { return }
	        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	        ++wheelSamples;
	      }, 200);
	    } else {
	      display.wheelDX += dx; display.wheelDY += dy;
	    }
	  }
	}

	// Selection objects are immutable. A new one is created every time
	// the selection changes. A selection is one or more non-overlapping
	// (and non-touching) ranges, sorted, and an integer that indicates
	// which one is the primary selection (the one that's scrolled into
	// view, that getCursor returns, etc).
	var Selection = function(ranges, primIndex) {
	  this.ranges = ranges;
	  this.primIndex = primIndex;
	};

	Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

	Selection.prototype.equals = function (other) {
	    var this$1 = this;

	  if (other == this) { return true }
	  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
	  for (var i = 0; i < this.ranges.length; i++) {
	    var here = this$1.ranges[i], there = other.ranges[i];
	    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
	  }
	  return true
	};

	Selection.prototype.deepCopy = function () {
	    var this$1 = this;

	  var out = [];
	  for (var i = 0; i < this.ranges.length; i++)
	    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
	  return new Selection(out, this.primIndex)
	};

	Selection.prototype.somethingSelected = function () {
	    var this$1 = this;

	  for (var i = 0; i < this.ranges.length; i++)
	    { if (!this$1.ranges[i].empty()) { return true } }
	  return false
	};

	Selection.prototype.contains = function (pos, end) {
	    var this$1 = this;

	  if (!end) { end = pos; }
	  for (var i = 0; i < this.ranges.length; i++) {
	    var range = this$1.ranges[i];
	    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	      { return i }
	  }
	  return -1
	};

	var Range = function(anchor, head) {
	  this.anchor = anchor; this.head = head;
	};

	Range.prototype.from = function () { return minPos(this.anchor, this.head) };
	Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
	Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

	// Take an unsorted, potentially overlapping set of ranges, and
	// build a selection out of it. 'Consumes' ranges array (modifying
	// it).
	function normalizeSelection(ranges, primIndex) {
	  var prim = ranges[primIndex];
	  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
	  primIndex = indexOf(ranges, prim);
	  for (var i = 1; i < ranges.length; i++) {
	    var cur = ranges[i], prev = ranges[i - 1];
	    if (cmp(prev.to(), cur.from()) >= 0) {
	      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	      if (i <= primIndex) { --primIndex; }
	      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	    }
	  }
	  return new Selection(ranges, primIndex)
	}

	function simpleSelection(anchor, head) {
	  return new Selection([new Range(anchor, head || anchor)], 0)
	}

	// Compute the position of the end of a change (its 'to' property
	// refers to the pre-change end).
	function changeEnd(change) {
	  if (!change.text) { return change.to }
	  return Pos(change.from.line + change.text.length - 1,
	             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
	}

	// Adjust a position to refer to the post-change position of the
	// same text, or the end of the change if the change covers it.
	function adjustForChange(pos, change) {
	  if (cmp(pos, change.from) < 0) { return pos }
	  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

	  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
	  return Pos(line, ch)
	}

	function computeSelAfterChange(doc, change) {
	  var out = [];
	  for (var i = 0; i < doc.sel.ranges.length; i++) {
	    var range = doc.sel.ranges[i];
	    out.push(new Range(adjustForChange(range.anchor, change),
	                       adjustForChange(range.head, change)));
	  }
	  return normalizeSelection(out, doc.sel.primIndex)
	}

	function offsetPos(pos, old, nw) {
	  if (pos.line == old.line)
	    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
	  else
	    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
	}

	// Used by replaceSelections to allow moving the selection to the
	// start or around the replaced test. Hint may be "start" or "around".
	function computeReplacedSel(doc, changes, hint) {
	  var out = [];
	  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	  for (var i = 0; i < changes.length; i++) {
	    var change = changes[i];
	    var from = offsetPos(change.from, oldPrev, newPrev);
	    var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	    oldPrev = change.to;
	    newPrev = to;
	    if (hint == "around") {
	      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	      out[i] = new Range(inv ? to : from, inv ? from : to);
	    } else {
	      out[i] = new Range(from, from);
	    }
	  }
	  return new Selection(out, doc.sel.primIndex)
	}

	// Used to get the editor into a consistent state again when options change.

	function loadMode(cm) {
	  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
	  resetModeState(cm);
	}

	function resetModeState(cm) {
	  cm.doc.iter(function (line) {
	    if (line.stateAfter) { line.stateAfter = null; }
	    if (line.styles) { line.styles = null; }
	  });
	  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
	  startWorker(cm, 100);
	  cm.state.modeGen++;
	  if (cm.curOp) { regChange(cm); }
	}

	// DOCUMENT DATA STRUCTURE

	// By default, updates that start and end at the beginning of a line
	// are treated specially, in order to make the association of line
	// widgets and marker elements with the text behave more intuitive.
	function isWholeLineUpdate(doc, change) {
	  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
	}

	// Perform a change on the document data structure.
	function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
	  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
	  function update(line, text, spans) {
	    updateLine(line, text, spans, estimateHeight$$1);
	    signalLater(line, "change", line, change);
	  }
	  function linesFor(start, end) {
	    var result = [];
	    for (var i = start; i < end; ++i)
	      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
	    return result
	  }

	  var from = change.from, to = change.to, text = change.text;
	  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

	  // Adjust the line structure
	  if (change.full) {
	    doc.insert(0, linesFor(0, text.length));
	    doc.remove(text.length, doc.size - text.length);
	  } else if (isWholeLineUpdate(doc, change)) {
	    // This is a whole-line replace. Treated specially to make
	    // sure line objects move the way they are supposed to.
	    var added = linesFor(0, text.length - 1);
	    update(lastLine, lastLine.text, lastSpans);
	    if (nlines) { doc.remove(from.line, nlines); }
	    if (added.length) { doc.insert(from.line, added); }
	  } else if (firstLine == lastLine) {
	    if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	    } else {
	      var added$1 = linesFor(1, text.length - 1);
	      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      doc.insert(from.line + 1, added$1);
	    }
	  } else if (text.length == 1) {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	    doc.remove(from.line + 1, nlines);
	  } else {
	    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	    var added$2 = linesFor(1, text.length - 1);
	    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
	    doc.insert(from.line + 1, added$2);
	  }

	  signalLater(doc, "change", doc, change);
	}

	// Call f for all linked documents.
	function linkedDocs(doc, f, sharedHistOnly) {
	  function propagate(doc, skip, sharedHist) {
	    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
	      var rel = doc.linked[i];
	      if (rel.doc == skip) { continue }
	      var shared = sharedHist && rel.sharedHist;
	      if (sharedHistOnly && !shared) { continue }
	      f(rel.doc, shared);
	      propagate(rel.doc, doc, shared);
	    } }
	  }
	  propagate(doc, null, true);
	}

	// Attach a document to an editor.
	function attachDoc(cm, doc) {
	  if (doc.cm) { throw new Error("This document is already in use.") }
	  cm.doc = doc;
	  doc.cm = cm;
	  estimateLineHeights(cm);
	  loadMode(cm);
	  setDirectionClass(cm);
	  if (!cm.options.lineWrapping) { findMaxLine(cm); }
	  cm.options.mode = doc.modeOption;
	  regChange(cm);
	}

	function setDirectionClass(cm) {
	  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
	}

	function directionChanged(cm) {
	  runInOp(cm, function () {
	    setDirectionClass(cm);
	    regChange(cm);
	  });
	}

	function History(startGen) {
	  // Arrays of change events and selections. Doing something adds an
	  // event to done and clears undo. Undoing moves events from done
	  // to undone, redoing moves them in the other direction.
	  this.done = []; this.undone = [];
	  this.undoDepth = Infinity;
	  // Used to track when changes can be merged into a single undo
	  // event
	  this.lastModTime = this.lastSelTime = 0;
	  this.lastOp = this.lastSelOp = null;
	  this.lastOrigin = this.lastSelOrigin = null;
	  // Used by the isClean() method
	  this.generation = this.maxGeneration = startGen || 1;
	}

	// Create a history change event from an updateDoc-style change
	// object.
	function historyChangeFromChange(doc, change) {
	  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
	  return histChange
	}

	// Pop all selection events off the end of a history array. Stop at
	// a change event.
	function clearSelectionEvents(array) {
	  while (array.length) {
	    var last = lst(array);
	    if (last.ranges) { array.pop(); }
	    else { break }
	  }
	}

	// Find the top change event in the history. Pop off selection
	// events that are in the way.
	function lastChangeEvent(hist, force) {
	  if (force) {
	    clearSelectionEvents(hist.done);
	    return lst(hist.done)
	  } else if (hist.done.length && !lst(hist.done).ranges) {
	    return lst(hist.done)
	  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	    hist.done.pop();
	    return lst(hist.done)
	  }
	}

	// Register a change in the history. Merges changes that are within
	// a single operation, or are close together with an origin that
	// allows merging (starting with "+") into a single event.
	function addChangeToHistory(doc, change, selAfter, opId) {
	  var hist = doc.history;
	  hist.undone.length = 0;
	  var time = +new Date, cur;
	  var last;

	  if ((hist.lastOp == opId ||
	       hist.lastOrigin == change.origin && change.origin &&
	       ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
	        change.origin.charAt(0) == "*")) &&
	      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	    // Merge this change into the last event
	    last = lst(cur.changes);
	    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	      // Optimized case for simple insertion -- don't want to add
	      // new changesets for every character typed
	      last.to = changeEnd(change);
	    } else {
	      // Add new sub-event
	      cur.changes.push(historyChangeFromChange(doc, change));
	    }
	  } else {
	    // Can not be merged, start a new event.
	    var before = lst(hist.done);
	    if (!before || !before.ranges)
	      { pushSelectionToHistory(doc.sel, hist.done); }
	    cur = {changes: [historyChangeFromChange(doc, change)],
	           generation: hist.generation};
	    hist.done.push(cur);
	    while (hist.done.length > hist.undoDepth) {
	      hist.done.shift();
	      if (!hist.done[0].ranges) { hist.done.shift(); }
	    }
	  }
	  hist.done.push(selAfter);
	  hist.generation = ++hist.maxGeneration;
	  hist.lastModTime = hist.lastSelTime = time;
	  hist.lastOp = hist.lastSelOp = opId;
	  hist.lastOrigin = hist.lastSelOrigin = change.origin;

	  if (!last) { signal(doc, "historyAdded"); }
	}

	function selectionEventCanBeMerged(doc, origin, prev, sel) {
	  var ch = origin.charAt(0);
	  return ch == "*" ||
	    ch == "+" &&
	    prev.ranges.length == sel.ranges.length &&
	    prev.somethingSelected() == sel.somethingSelected() &&
	    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
	}

	// Called whenever the selection changes, sets the new selection as
	// the pending selection in the history, and pushes the old pending
	// selection into the 'done' array when it was significantly
	// different (in number of selected ranges, emptiness, or time).
	function addSelectionToHistory(doc, sel, opId, options) {
	  var hist = doc.history, origin = options && options.origin;

	  // A new event is started when the previous origin does not match
	  // the current, or the origins don't allow matching. Origins
	  // starting with * are always merged, those starting with + are
	  // merged when similar and close together in time.
	  if (opId == hist.lastSelOp ||
	      (origin && hist.lastSelOrigin == origin &&
	       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	    { hist.done[hist.done.length - 1] = sel; }
	  else
	    { pushSelectionToHistory(sel, hist.done); }

	  hist.lastSelTime = +new Date;
	  hist.lastSelOrigin = origin;
	  hist.lastSelOp = opId;
	  if (options && options.clearRedo !== false)
	    { clearSelectionEvents(hist.undone); }
	}

	function pushSelectionToHistory(sel, dest) {
	  var top = lst(dest);
	  if (!(top && top.ranges && top.equals(sel)))
	    { dest.push(sel); }
	}

	// Used to store marked span information in the history.
	function attachLocalSpans(doc, change, from, to) {
	  var existing = change["spans_" + doc.id], n = 0;
	  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
	    if (line.markedSpans)
	      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
	    ++n;
	  });
	}

	// When un/re-doing restores text containing marked spans, those
	// that have been explicitly cleared should not be restored.
	function removeClearedSpans(spans) {
	  if (!spans) { return null }
	  var out;
	  for (var i = 0; i < spans.length; ++i) {
	    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
	    else if (out) { out.push(spans[i]); }
	  }
	  return !out ? spans : out.length ? out : null
	}

	// Retrieve and filter the old marked spans stored in a change event.
	function getOldSpans(doc, change) {
	  var found = change["spans_" + doc.id];
	  if (!found) { return null }
	  var nw = [];
	  for (var i = 0; i < change.text.length; ++i)
	    { nw.push(removeClearedSpans(found[i])); }
	  return nw
	}

	// Used for un/re-doing changes from the history. Combines the
	// result of computing the existing spans with the set of spans that
	// existed in the history (so that deleting around a span and then
	// undoing brings back the span).
	function mergeOldSpans(doc, change) {
	  var old = getOldSpans(doc, change);
	  var stretched = stretchSpansOverChange(doc, change);
	  if (!old) { return stretched }
	  if (!stretched) { return old }

	  for (var i = 0; i < old.length; ++i) {
	    var oldCur = old[i], stretchCur = stretched[i];
	    if (oldCur && stretchCur) {
	      spans: for (var j = 0; j < stretchCur.length; ++j) {
	        var span = stretchCur[j];
	        for (var k = 0; k < oldCur.length; ++k)
	          { if (oldCur[k].marker == span.marker) { continue spans } }
	        oldCur.push(span);
	      }
	    } else if (stretchCur) {
	      old[i] = stretchCur;
	    }
	  }
	  return old
	}

	// Used both to provide a JSON-safe object in .getHistory, and, when
	// detaching a document, to split the history in two
	function copyHistoryArray(events, newGroup, instantiateSel) {
	  var copy = [];
	  for (var i = 0; i < events.length; ++i) {
	    var event = events[i];
	    if (event.ranges) {
	      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	      continue
	    }
	    var changes = event.changes, newChanges = [];
	    copy.push({changes: newChanges});
	    for (var j = 0; j < changes.length; ++j) {
	      var change = changes[j], m = (void 0);
	      newChanges.push({from: change.from, to: change.to, text: change.text});
	      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
	        if (indexOf(newGroup, Number(m[1])) > -1) {
	          lst(newChanges)[prop] = change[prop];
	          delete change[prop];
	        }
	      } } }
	    }
	  }
	  return copy
	}

	// The 'scroll' parameter given to many of these indicated whether
	// the new cursor position should be scrolled into view after
	// modifying the selection.

	// If shift is held or the extend flag is set, extends a range to
	// include a given position (and optionally a second position).
	// Otherwise, simply returns the range between the given positions.
	// Used for cursor motion and such.
	function extendRange(range, head, other, extend) {
	  if (extend) {
	    var anchor = range.anchor;
	    if (other) {
	      var posBefore = cmp(head, anchor) < 0;
	      if (posBefore != (cmp(other, anchor) < 0)) {
	        anchor = head;
	        head = other;
	      } else if (posBefore != (cmp(head, other) < 0)) {
	        head = other;
	      }
	    }
	    return new Range(anchor, head)
	  } else {
	    return new Range(other || head, head)
	  }
	}

	// Extend the primary selection range, discard the rest.
	function extendSelection(doc, head, other, options, extend) {
	  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
	  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
	}

	// Extend all selections (pos is an array of selections with length
	// equal the number of selections)
	function extendSelections(doc, heads, options) {
	  var out = [];
	  var extend = doc.cm && (doc.cm.display.shift || doc.extend);
	  for (var i = 0; i < doc.sel.ranges.length; i++)
	    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
	  var newSel = normalizeSelection(out, doc.sel.primIndex);
	  setSelection(doc, newSel, options);
	}

	// Updates a single range in the selection.
	function replaceOneSelection(doc, i, range, options) {
	  var ranges = doc.sel.ranges.slice(0);
	  ranges[i] = range;
	  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
	}

	// Reset the selection to a single range.
	function setSimpleSelection(doc, anchor, head, options) {
	  setSelection(doc, simpleSelection(anchor, head), options);
	}

	// Give beforeSelectionChange handlers a change to influence a
	// selection update.
	function filterSelectionChange(doc, sel, options) {
	  var obj = {
	    ranges: sel.ranges,
	    update: function(ranges) {
	      var this$1 = this;

	      this.ranges = [];
	      for (var i = 0; i < ranges.length; i++)
	        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                   clipPos(doc, ranges[i].head)); }
	    },
	    origin: options && options.origin
	  };
	  signal(doc, "beforeSelectionChange", doc, obj);
	  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
	  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
	  else { return sel }
	}

	function setSelectionReplaceHistory(doc, sel, options) {
	  var done = doc.history.done, last = lst(done);
	  if (last && last.ranges) {
	    done[done.length - 1] = sel;
	    setSelectionNoUndo(doc, sel, options);
	  } else {
	    setSelection(doc, sel, options);
	  }
	}

	// Set a new selection.
	function setSelection(doc, sel, options) {
	  setSelectionNoUndo(doc, sel, options);
	  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	}

	function setSelectionNoUndo(doc, sel, options) {
	  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	    { sel = filterSelectionChange(doc, sel, options); }

	  var bias = options && options.bias ||
	    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

	  if (!(options && options.scroll === false) && doc.cm)
	    { ensureCursorVisible(doc.cm); }
	}

	function setSelectionInner(doc, sel) {
	  if (sel.equals(doc.sel)) { return }

	  doc.sel = sel;

	  if (doc.cm) {
	    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
	    signalCursorActivity(doc.cm);
	  }
	  signalLater(doc, "cursorActivity", doc);
	}

	// Verify that the selection does not partially select any atomic
	// marked ranges.
	function reCheckSelection(doc) {
	  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
	}

	// Return a selection that does not partially select any atomic
	// ranges.
	function skipAtomicInSelection(doc, sel, bias, mayClear) {
	  var out;
	  for (var i = 0; i < sel.ranges.length; i++) {
	    var range = sel.ranges[i];
	    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
	    if (out || newAnchor != range.anchor || newHead != range.head) {
	      if (!out) { out = sel.ranges.slice(0, i); }
	      out[i] = new Range(newAnchor, newHead);
	    }
	  }
	  return out ? normalizeSelection(out, sel.primIndex) : sel
	}

	function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	  var line = getLine(doc, pos.line);
	  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	    var sp = line.markedSpans[i], m = sp.marker;
	    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	      if (mayClear) {
	        signal(m, "beforeCursorEnter");
	        if (m.explicitlyCleared) {
	          if (!line.markedSpans) { break }
	          else {--i; continue}
	        }
	      }
	      if (!m.atomic) { continue }

	      if (oldPos) {
	        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
	        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
	          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
	        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
	      }

	      var far = m.find(dir < 0 ? -1 : 1);
	      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
	        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
	      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
	    }
	  } }
	  return pos
	}

	// Ensure a given position is not inside an atomic range.
	function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	  var dir = bias || 1;
	  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
	  if (!found) {
	    doc.cantEdit = true;
	    return Pos(doc.first, 0)
	  }
	  return found
	}

	function movePos(doc, pos, dir, line) {
	  if (dir < 0 && pos.ch == 0) {
	    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
	    else { return null }
	  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
	    else { return null }
	  } else {
	    return new Pos(pos.line, pos.ch + dir)
	  }
	}

	function selectAll(cm) {
	  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
	}

	// UPDATING

	// Allow "beforeChange" event handlers to influence a change
	function filterChange(doc, change, update) {
	  var obj = {
	    canceled: false,
	    from: change.from,
	    to: change.to,
	    text: change.text,
	    origin: change.origin,
	    cancel: function () { return obj.canceled = true; }
	  };
	  if (update) { obj.update = function (from, to, text, origin) {
	    if (from) { obj.from = clipPos(doc, from); }
	    if (to) { obj.to = clipPos(doc, to); }
	    if (text) { obj.text = text; }
	    if (origin !== undefined) { obj.origin = origin; }
	  }; }
	  signal(doc, "beforeChange", doc, obj);
	  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

	  if (obj.canceled) { return null }
	  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
	}

	// Apply a change to a document, and add it to the document's
	// history, and propagating it to all linked documents.
	function makeChange(doc, change, ignoreReadOnly) {
	  if (doc.cm) {
	    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
	    if (doc.cm.state.suppressEdits) { return }
	  }

	  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	    change = filterChange(doc, change, true);
	    if (!change) { return }
	  }

	  // Possibly split or suppress the update based on the presence
	  // of read-only spans in its range.
	  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	  if (split) {
	    for (var i = split.length - 1; i >= 0; --i)
	      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
	  } else {
	    makeChangeInner(doc, change);
	  }
	}

	function makeChangeInner(doc, change) {
	  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
	  var selAfter = computeSelAfterChange(doc, change);
	  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

	  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	  var rebased = [];

	  linkedDocs(doc, function (doc, sharedHist) {
	    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	      rebaseHist(doc.history, change);
	      rebased.push(doc.history);
	    }
	    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	  });
	}

	// Revert a change stored in a document's history.
	function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }

	  var hist = doc.history, event, selAfter = doc.sel;
	  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

	  // Verify that there is a useable event (so that ctrl-z won't
	  // needlessly clear selection events)
	  var i = 0;
	  for (; i < source.length; i++) {
	    event = source[i];
	    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	      { break }
	  }
	  if (i == source.length) { return }
	  hist.lastOrigin = hist.lastSelOrigin = null;

	  for (;;) {
	    event = source.pop();
	    if (event.ranges) {
	      pushSelectionToHistory(event, dest);
	      if (allowSelectionOnly && !event.equals(doc.sel)) {
	        setSelection(doc, event, {clearRedo: false});
	        return
	      }
	      selAfter = event;
	    }
	    else { break }
	  }

	  // Build up a reverse change object to add to the opposite history
	  // stack (redo when undoing, and vice versa).
	  var antiChanges = [];
	  pushSelectionToHistory(selAfter, dest);
	  dest.push({changes: antiChanges, generation: hist.generation});
	  hist.generation = event.generation || ++hist.maxGeneration;

	  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

	  var loop = function ( i ) {
	    var change = event.changes[i];
	    change.origin = type;
	    if (filter && !filterChange(doc, change, false)) {
	      source.length = 0;
	      return {}
	    }

	    antiChanges.push(historyChangeFromChange(doc, change));

	    var after = i ? computeSelAfterChange(doc, change) : lst(source);
	    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
	    var rebased = [];

	    // Propagate to the linked documents
	    linkedDocs(doc, function (doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	    });
	  };

	  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
	    var returned = loop( i$1 );

	    if ( returned ) return returned.v;
	  }
	}

	// Sub-views need their line numbers shifted when text is added
	// above or below them in the parent document.
	function shiftDoc(doc, distance) {
	  if (distance == 0) { return }
	  doc.first += distance;
	  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
	    Pos(range.anchor.line + distance, range.anchor.ch),
	    Pos(range.head.line + distance, range.head.ch)
	  ); }), doc.sel.primIndex);
	  if (doc.cm) {
	    regChange(doc.cm, doc.first, doc.first - distance, distance);
	    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	      { regLineChange(doc.cm, l, "gutter"); }
	  }
	}

	// More lower-level change function, handling only a single document
	// (not linked ones).
	function makeChangeSingleDoc(doc, change, selAfter, spans) {
	  if (doc.cm && !doc.cm.curOp)
	    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

	  if (change.to.line < doc.first) {
	    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	    return
	  }
	  if (change.from.line > doc.lastLine()) { return }

	  // Clip the change to the size of this doc
	  if (change.from.line < doc.first) {
	    var shift = change.text.length - 1 - (doc.first - change.from.line);
	    shiftDoc(doc, shift);
	    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	              text: [lst(change.text)], origin: change.origin};
	  }
	  var last = doc.lastLine();
	  if (change.to.line > last) {
	    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	              text: [change.text[0]], origin: change.origin};
	  }

	  change.removed = getBetween(doc, change.from, change.to);

	  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
	  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
	  else { updateDoc(doc, change, spans); }
	  setSelectionNoUndo(doc, selAfter, sel_dontScroll);
	}

	// Handle the interaction of a change to a document with the editor
	// that this document is part of.
	function makeChangeSingleDocInEditor(cm, change, spans) {
	  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

	  var recomputeMaxLength = false, checkWidthStart = from.line;
	  if (!cm.options.lineWrapping) {
	    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	    doc.iter(checkWidthStart, to.line + 1, function (line) {
	      if (line == display.maxLine) {
	        recomputeMaxLength = true;
	        return true
	      }
	    });
	  }

	  if (doc.sel.contains(change.from, change.to) > -1)
	    { signalCursorActivity(cm); }

	  updateDoc(doc, change, spans, estimateHeight(cm));

	  if (!cm.options.lineWrapping) {
	    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
	      var len = lineLength(line);
	      if (len > display.maxLineLength) {
	        display.maxLine = line;
	        display.maxLineLength = len;
	        display.maxLineChanged = true;
	        recomputeMaxLength = false;
	      }
	    });
	    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
	  }

	  retreatFrontier(doc, from.line);
	  startWorker(cm, 400);

	  var lendiff = change.text.length - (to.line - from.line) - 1;
	  // Remember that these lines changed, for updating the display
	  if (change.full)
	    { regChange(cm); }
	  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	    { regLineChange(cm, from.line, "text"); }
	  else
	    { regChange(cm, from.line, to.line + 1, lendiff); }

	  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	  if (changeHandler || changesHandler) {
	    var obj = {
	      from: from, to: to,
	      text: change.text,
	      removed: change.removed,
	      origin: change.origin
	    };
	    if (changeHandler) { signalLater(cm, "change", cm, obj); }
	    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
	  }
	  cm.display.selForContextMenu = null;
	}

	function replaceRange(doc, code, from, to, origin) {
	  if (!to) { to = from; }
	  if (cmp(to, from) < 0) { var assign;
	    (assign = [to, from], from = assign[0], to = assign[1], assign); }
	  if (typeof code == "string") { code = doc.splitLines(code); }
	  makeChange(doc, {from: from, to: to, text: code, origin: origin});
	}

	// Rebasing/resetting history to deal with externally-sourced changes

	function rebaseHistSelSingle(pos, from, to, diff) {
	  if (to < pos.line) {
	    pos.line += diff;
	  } else if (from < pos.line) {
	    pos.line = from;
	    pos.ch = 0;
	  }
	}

	// Tries to rebase an array of history events given a change in the
	// document. If the change touches the same lines as the event, the
	// event, and everything 'behind' it, is discarded. If the change is
	// before the event, the event's positions are updated. Uses a
	// copy-on-write scheme for the positions, to avoid having to
	// reallocate them all on every rebase, but also avoid problems with
	// shared position objects being unsafely updated.
	function rebaseHistArray(array, from, to, diff) {
	  for (var i = 0; i < array.length; ++i) {
	    var sub = array[i], ok = true;
	    if (sub.ranges) {
	      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	      for (var j = 0; j < sub.ranges.length; j++) {
	        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	      }
	      continue
	    }
	    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
	      var cur = sub.changes[j$1];
	      if (to < cur.from.line) {
	        cur.from = Pos(cur.from.line + diff, cur.from.ch);
	        cur.to = Pos(cur.to.line + diff, cur.to.ch);
	      } else if (from <= cur.to.line) {
	        ok = false;
	        break
	      }
	    }
	    if (!ok) {
	      array.splice(0, i + 1);
	      i = 0;
	    }
	  }
	}

	function rebaseHist(hist, change) {
	  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	  rebaseHistArray(hist.done, from, to, diff);
	  rebaseHistArray(hist.undone, from, to, diff);
	}

	// Utility for applying a change to a line by handle or number,
	// returning the number and optionally registering the line as
	// changed.
	function changeLine(doc, handle, changeType, op) {
	  var no = handle, line = handle;
	  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
	  else { no = lineNo(handle); }
	  if (no == null) { return null }
	  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
	  return line
	}

	// The document is represented as a BTree consisting of leaves, with
	// chunk of lines in them, and branches, with up to ten leaves or
	// other branch nodes below them. The top node is always a branch
	// node, and is the document object itself (meaning it has
	// additional methods and properties).
	//
	// All nodes have parent links. The tree is used both to go from
	// line numbers to line objects, and to go from objects to numbers.
	// It also indexes by height, and is used to convert between height
	// and line object, and to find the total height of the document.
	//
	// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

	function LeafChunk(lines) {
	  var this$1 = this;

	  this.lines = lines;
	  this.parent = null;
	  var height = 0;
	  for (var i = 0; i < lines.length; ++i) {
	    lines[i].parent = this$1;
	    height += lines[i].height;
	  }
	  this.height = height;
	}

	LeafChunk.prototype = {
	  chunkSize: function chunkSize() { return this.lines.length },

	  // Remove the n lines at offset 'at'.
	  removeInner: function removeInner(at, n) {
	    var this$1 = this;

	    for (var i = at, e = at + n; i < e; ++i) {
	      var line = this$1.lines[i];
	      this$1.height -= line.height;
	      cleanUpLine(line);
	      signalLater(line, "delete");
	    }
	    this.lines.splice(at, n);
	  },

	  // Helper used to collapse a small branch into a single leaf.
	  collapse: function collapse(lines) {
	    lines.push.apply(lines, this.lines);
	  },

	  // Insert the given array of lines at offset 'at', count them as
	  // having the given height.
	  insertInner: function insertInner(at, lines, height) {
	    var this$1 = this;

	    this.height += height;
	    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
	  },

	  // Used to iterate over a part of the tree.
	  iterN: function iterN(at, n, op) {
	    var this$1 = this;

	    for (var e = at + n; at < e; ++at)
	      { if (op(this$1.lines[at])) { return true } }
	  }
	};

	function BranchChunk(children) {
	  var this$1 = this;

	  this.children = children;
	  var size = 0, height = 0;
	  for (var i = 0; i < children.length; ++i) {
	    var ch = children[i];
	    size += ch.chunkSize(); height += ch.height;
	    ch.parent = this$1;
	  }
	  this.size = size;
	  this.height = height;
	  this.parent = null;
	}

	BranchChunk.prototype = {
	  chunkSize: function chunkSize() { return this.size },

	  removeInner: function removeInner(at, n) {
	    var this$1 = this;

	    this.size -= n;
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at < sz) {
	        var rm = Math.min(n, sz - at), oldHeight = child.height;
	        child.removeInner(at, rm);
	        this$1.height -= oldHeight - child.height;
	        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
	        if ((n -= rm) == 0) { break }
	        at = 0;
	      } else { at -= sz; }
	    }
	    // If the result is smaller than 25 lines, ensure that it is a
	    // single leaf node.
	    if (this.size - n < 25 &&
	        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	      var lines = [];
	      this.collapse(lines);
	      this.children = [new LeafChunk(lines)];
	      this.children[0].parent = this;
	    }
	  },

	  collapse: function collapse(lines) {
	    var this$1 = this;

	    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
	  },

	  insertInner: function insertInner(at, lines, height) {
	    var this$1 = this;

	    this.size += lines.length;
	    this.height += height;
	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at <= sz) {
	        child.insertInner(at, lines, height);
	        if (child.lines && child.lines.length > 50) {
	          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	          var remaining = child.lines.length % 25 + 25;
	          for (var pos = remaining; pos < child.lines.length;) {
	            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	            child.height -= leaf.height;
	            this$1.children.splice(++i, 0, leaf);
	            leaf.parent = this$1;
	          }
	          child.lines = child.lines.slice(0, remaining);
	          this$1.maybeSpill();
	        }
	        break
	      }
	      at -= sz;
	    }
	  },

	  // When a node has grown, check whether it should be split.
	  maybeSpill: function maybeSpill() {
	    if (this.children.length <= 10) { return }
	    var me = this;
	    do {
	      var spilled = me.children.splice(me.children.length - 5, 5);
	      var sibling = new BranchChunk(spilled);
	      if (!me.parent) { // Become the parent node
	        var copy = new BranchChunk(me.children);
	        copy.parent = me;
	        me.children = [copy, sibling];
	        me = copy;
	     } else {
	        me.size -= sibling.size;
	        me.height -= sibling.height;
	        var myIndex = indexOf(me.parent.children, me);
	        me.parent.children.splice(myIndex + 1, 0, sibling);
	      }
	      sibling.parent = me.parent;
	    } while (me.children.length > 10)
	    me.parent.maybeSpill();
	  },

	  iterN: function iterN(at, n, op) {
	    var this$1 = this;

	    for (var i = 0; i < this.children.length; ++i) {
	      var child = this$1.children[i], sz = child.chunkSize();
	      if (at < sz) {
	        var used = Math.min(n, sz - at);
	        if (child.iterN(at, used, op)) { return true }
	        if ((n -= used) == 0) { break }
	        at = 0;
	      } else { at -= sz; }
	    }
	  }
	};

	// Line widgets are block elements displayed above or below a line.

	var LineWidget = function(doc, node, options) {
	  var this$1 = this;

	  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
	    { this$1[opt] = options[opt]; } } }
	  this.doc = doc;
	  this.node = node;
	};

	LineWidget.prototype.clear = function () {
	    var this$1 = this;

	  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	  if (no == null || !ws) { return }
	  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
	  if (!ws.length) { line.widgets = null; }
	  var height = widgetHeight(this);
	  updateLineHeight(line, Math.max(0, line.height - height));
	  if (cm) {
	    runInOp(cm, function () {
	      adjustScrollWhenAboveVisible(cm, line, -height);
	      regLineChange(cm, no, "widget");
	    });
	    signalLater(cm, "lineWidgetCleared", cm, this, no);
	  }
	};

	LineWidget.prototype.changed = function () {
	    var this$1 = this;

	  var oldH = this.height, cm = this.doc.cm, line = this.line;
	  this.height = null;
	  var diff = widgetHeight(this) - oldH;
	  if (!diff) { return }
	  updateLineHeight(line, line.height + diff);
	  if (cm) {
	    runInOp(cm, function () {
	      cm.curOp.forceUpdate = true;
	      adjustScrollWhenAboveVisible(cm, line, diff);
	      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
	    });
	  }
	};
	eventMixin(LineWidget);

	function adjustScrollWhenAboveVisible(cm, line, diff) {
	  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	    { addToScrollTop(cm, diff); }
	}

	function addLineWidget(doc, handle, node, options) {
	  var widget = new LineWidget(doc, node, options);
	  var cm = doc.cm;
	  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
	  changeLine(doc, handle, "widget", function (line) {
	    var widgets = line.widgets || (line.widgets = []);
	    if (widget.insertAt == null) { widgets.push(widget); }
	    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
	    widget.line = line;
	    if (cm && !lineIsHidden(doc, line)) {
	      var aboveVisible = heightAtLine(line) < doc.scrollTop;
	      updateLineHeight(line, line.height + widgetHeight(widget));
	      if (aboveVisible) { addToScrollTop(cm, widget.height); }
	      cm.curOp.forceUpdate = true;
	    }
	    return true
	  });
	  signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
	  return widget
	}

	// TEXTMARKERS

	// Created with markText and setBookmark methods. A TextMarker is a
	// handle that can be used to clear or find a marked position in the
	// document. Line objects hold arrays (markedSpans) containing
	// {from, to, marker} object pointing to such marker objects, and
	// indicating that such a marker is present on that line. Multiple
	// lines may point to the same marker when it spans across lines.
	// The spans will have null for their from/to properties when the
	// marker continues beyond the start/end of the line. Markers have
	// links back to the lines they currently touch.

	// Collapsed markers have unique ids, in order to be able to order
	// them, which is needed for uniquely determining an outer marker
	// when they overlap (they may nest, but not partially overlap).
	var nextMarkerId = 0;

	var TextMarker = function(doc, type) {
	  this.lines = [];
	  this.type = type;
	  this.doc = doc;
	  this.id = ++nextMarkerId;
	};

	// Clear the marker.
	TextMarker.prototype.clear = function () {
	    var this$1 = this;

	  if (this.explicitlyCleared) { return }
	  var cm = this.doc.cm, withOp = cm && !cm.curOp;
	  if (withOp) { startOperation(cm); }
	  if (hasHandler(this, "clear")) {
	    var found = this.find();
	    if (found) { signalLater(this, "clear", found.from, found.to); }
	  }
	  var min = null, max = null;
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i];
	    var span = getMarkedSpanFor(line.markedSpans, this$1);
	    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
	    else if (cm) {
	      if (span.to != null) { max = lineNo(line); }
	      if (span.from != null) { min = lineNo(line); }
	    }
	    line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
	      { updateLineHeight(line, textHeight(cm.display)); }
	  }
	  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
	    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
	    if (len > cm.display.maxLineLength) {
	      cm.display.maxLine = visual;
	      cm.display.maxLineLength = len;
	      cm.display.maxLineChanged = true;
	    }
	  } }

	  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
	  this.lines.length = 0;
	  this.explicitlyCleared = true;
	  if (this.atomic && this.doc.cantEdit) {
	    this.doc.cantEdit = false;
	    if (cm) { reCheckSelection(cm.doc); }
	  }
	  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
	  if (withOp) { endOperation(cm); }
	  if (this.parent) { this.parent.clear(); }
	};

	// Find the position of the marker in the document. Returns a {from,
	// to} object by default. Side can be passed to get a specific side
	// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	// Pos objects returned contain a line object, rather than a line
	// number (used to prevent looking up the same line twice).
	TextMarker.prototype.find = function (side, lineObj) {
	    var this$1 = this;

	  if (side == null && this.type == "bookmark") { side = 1; }
	  var from, to;
	  for (var i = 0; i < this.lines.length; ++i) {
	    var line = this$1.lines[i];
	    var span = getMarkedSpanFor(line.markedSpans, this$1);
	    if (span.from != null) {
	      from = Pos(lineObj ? line : lineNo(line), span.from);
	      if (side == -1) { return from }
	    }
	    if (span.to != null) {
	      to = Pos(lineObj ? line : lineNo(line), span.to);
	      if (side == 1) { return to }
	    }
	  }
	  return from && {from: from, to: to}
	};

	// Signals that the marker's widget changed, and surrounding layout
	// should be recomputed.
	TextMarker.prototype.changed = function () {
	    var this$1 = this;

	  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	  if (!pos || !cm) { return }
	  runInOp(cm, function () {
	    var line = pos.line, lineN = lineNo(pos.line);
	    var view = findViewForLine(cm, lineN);
	    if (view) {
	      clearLineMeasurementCacheFor(view);
	      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	    }
	    cm.curOp.updateMaxLine = true;
	    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	      var oldHeight = widget.height;
	      widget.height = null;
	      var dHeight = widgetHeight(widget) - oldHeight;
	      if (dHeight)
	        { updateLineHeight(line, line.height + dHeight); }
	    }
	    signalLater(cm, "markerChanged", cm, this$1);
	  });
	};

	TextMarker.prototype.attachLine = function (line) {
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp;
	    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
	  }
	  this.lines.push(line);
	};

	TextMarker.prototype.detachLine = function (line) {
	  this.lines.splice(indexOf(this.lines, line), 1);
	  if (!this.lines.length && this.doc.cm) {
	    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	  }
	};
	eventMixin(TextMarker);

	// Create a marker, wire it up to the right lines, and
	function markText(doc, from, to, options, type) {
	  // Shared markers (across linked documents) are handled separately
	  // (markTextShared will call out to this again, once per
	  // document).
	  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
	  // Ensure we are in an operation.
	  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

	  var marker = new TextMarker(doc, type), diff = cmp(from, to);
	  if (options) { copyObj(options, marker, false); }
	  // Don't connect empty markers unless clearWhenEmpty is false
	  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	    { return marker }
	  if (marker.replacedWith) {
	    // Showing up as a widget implies collapsed (widget replaces text)
	    marker.collapsed = true;
	    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
	    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
	    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
	  }
	  if (marker.collapsed) {
	    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
	    seeCollapsedSpans();
	  }

	  if (marker.addToHistory)
	    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

	  var curLine = from.line, cm = doc.cm, updateMaxLine;
	  doc.iter(curLine, to.line + 1, function (line) {
	    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	      { updateMaxLine = true; }
	    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
	    addMarkedSpan(line, new MarkedSpan(marker,
	                                       curLine == from.line ? from.ch : null,
	                                       curLine == to.line ? to.ch : null));
	    ++curLine;
	  });
	  // lineIsHidden depends on the presence of the spans, so needs a second pass
	  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
	    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
	  }); }

	  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

	  if (marker.readOnly) {
	    seeReadOnlySpans();
	    if (doc.history.done.length || doc.history.undone.length)
	      { doc.clearHistory(); }
	  }
	  if (marker.collapsed) {
	    marker.id = ++nextMarkerId;
	    marker.atomic = true;
	  }
	  if (cm) {
	    // Sync editor state
	    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
	    if (marker.collapsed)
	      { regChange(cm, from.line, to.line + 1); }
	    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
	      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
	    if (marker.atomic) { reCheckSelection(cm.doc); }
	    signalLater(cm, "markerAdded", cm, marker);
	  }
	  return marker
	}

	// SHARED TEXTMARKERS

	// A shared marker spans multiple linked documents. It is
	// implemented as a meta-marker-object controlling multiple normal
	// markers.
	var SharedTextMarker = function(markers, primary) {
	  var this$1 = this;

	  this.markers = markers;
	  this.primary = primary;
	  for (var i = 0; i < markers.length; ++i)
	    { markers[i].parent = this$1; }
	};

	SharedTextMarker.prototype.clear = function () {
	    var this$1 = this;

	  if (this.explicitlyCleared) { return }
	  this.explicitlyCleared = true;
	  for (var i = 0; i < this.markers.length; ++i)
	    { this$1.markers[i].clear(); }
	  signalLater(this, "clear");
	};

	SharedTextMarker.prototype.find = function (side, lineObj) {
	  return this.primary.find(side, lineObj)
	};
	eventMixin(SharedTextMarker);

	function markTextShared(doc, from, to, options, type) {
	  options = copyObj(options);
	  options.shared = false;
	  var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	  var widget = options.widgetNode;
	  linkedDocs(doc, function (doc) {
	    if (widget) { options.widgetNode = widget.cloneNode(true); }
	    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	    for (var i = 0; i < doc.linked.length; ++i)
	      { if (doc.linked[i].isParent) { return } }
	    primary = lst(markers);
	  });
	  return new SharedTextMarker(markers, primary)
	}

	function findSharedMarkers(doc) {
	  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
	}

	function copySharedMarkers(doc, markers) {
	  for (var i = 0; i < markers.length; i++) {
	    var marker = markers[i], pos = marker.find();
	    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	    if (cmp(mFrom, mTo)) {
	      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	      marker.markers.push(subMark);
	      subMark.parent = marker;
	    }
	  }
	}

	function detachSharedMarkers(markers) {
	  var loop = function ( i ) {
	    var marker = markers[i], linked = [marker.primary.doc];
	    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
	    for (var j = 0; j < marker.markers.length; j++) {
	      var subMarker = marker.markers[j];
	      if (indexOf(linked, subMarker.doc) == -1) {
	        subMarker.parent = null;
	        marker.markers.splice(j--, 1);
	      }
	    }
	  };

	  for (var i = 0; i < markers.length; i++) loop( i );
	}

	var nextDocId = 0;
	var Doc = function(text, mode, firstLine, lineSep, direction) {
	  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
	  if (firstLine == null) { firstLine = 0; }

	  BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	  this.first = firstLine;
	  this.scrollTop = this.scrollLeft = 0;
	  this.cantEdit = false;
	  this.cleanGeneration = 1;
	  this.modeFrontier = this.highlightFrontier = firstLine;
	  var start = Pos(firstLine, 0);
	  this.sel = simpleSelection(start);
	  this.history = new History(null);
	  this.id = ++nextDocId;
	  this.modeOption = mode;
	  this.lineSep = lineSep;
	  this.direction = (direction == "rtl") ? "rtl" : "ltr";
	  this.extend = false;

	  if (typeof text == "string") { text = this.splitLines(text); }
	  updateDoc(this, {from: start, to: start, text: text});
	  setSelection(this, simpleSelection(start), sel_dontScroll);
	};

	Doc.prototype = createObj(BranchChunk.prototype, {
	  constructor: Doc,
	  // Iterate over the document. Supports two forms -- with only one
	  // argument, it calls that for each line in the document. With
	  // three, it iterates over the range given by the first two (with
	  // the second being non-inclusive).
	  iter: function(from, to, op) {
	    if (op) { this.iterN(from - this.first, to - from, op); }
	    else { this.iterN(this.first, this.first + this.size, from); }
	  },

	  // Non-public interface for adding and removing lines.
	  insert: function(at, lines) {
	    var height = 0;
	    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
	    this.insertInner(at - this.first, lines, height);
	  },
	  remove: function(at, n) { this.removeInner(at - this.first, n); },

	  // From here, the methods are part of the public interface. Most
	  // are also available from CodeMirror (editor) instances.

	  getValue: function(lineSep) {
	    var lines = getLines(this, this.first, this.first + this.size);
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },
	  setValue: docMethodOp(function(code) {
	    var top = Pos(this.first, 0), last = this.first + this.size - 1;
	    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                      text: this.splitLines(code), origin: "setValue", full: true}, true);
	    if (this.cm) { scrollToCoords(this.cm, 0, 0); }
	    setSelection(this, simpleSelection(top), sel_dontScroll);
	  }),
	  replaceRange: function(code, from, to, origin) {
	    from = clipPos(this, from);
	    to = to ? clipPos(this, to) : from;
	    replaceRange(this, code, from, to, origin);
	  },
	  getRange: function(from, to, lineSep) {
	    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	    if (lineSep === false) { return lines }
	    return lines.join(lineSep || this.lineSeparator())
	  },

	  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

	  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
	  getLineNumber: function(line) {return lineNo(line)},

	  getLineHandleVisualStart: function(line) {
	    if (typeof line == "number") { line = getLine(this, line); }
	    return visualLine(line)
	  },

	  lineCount: function() {return this.size},
	  firstLine: function() {return this.first},
	  lastLine: function() {return this.first + this.size - 1},

	  clipPos: function(pos) {return clipPos(this, pos)},

	  getCursor: function(start) {
	    var range$$1 = this.sel.primary(), pos;
	    if (start == null || start == "head") { pos = range$$1.head; }
	    else if (start == "anchor") { pos = range$$1.anchor; }
	    else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
	    else { pos = range$$1.from(); }
	    return pos
	  },
	  listSelections: function() { return this.sel.ranges },
	  somethingSelected: function() {return this.sel.somethingSelected()},

	  setCursor: docMethodOp(function(line, ch, options) {
	    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	  }),
	  setSelection: docMethodOp(function(anchor, head, options) {
	    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	  }),
	  extendSelection: docMethodOp(function(head, other, options) {
	    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	  }),
	  extendSelections: docMethodOp(function(heads, options) {
	    extendSelections(this, clipPosArray(this, heads), options);
	  }),
	  extendSelectionsBy: docMethodOp(function(f, options) {
	    var heads = map(this.sel.ranges, f);
	    extendSelections(this, clipPosArray(this, heads), options);
	  }),
	  setSelections: docMethodOp(function(ranges, primary, options) {
	    var this$1 = this;

	    if (!ranges.length) { return }
	    var out = [];
	    for (var i = 0; i < ranges.length; i++)
	      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
	                         clipPos(this$1, ranges[i].head)); }
	    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
	    setSelection(this, normalizeSelection(out, primary), options);
	  }),
	  addSelection: docMethodOp(function(anchor, head, options) {
	    var ranges = this.sel.ranges.slice(0);
	    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
	  }),

	  getSelection: function(lineSep) {
	    var this$1 = this;

	    var ranges = this.sel.ranges, lines;
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
	      lines = lines ? lines.concat(sel) : sel;
	    }
	    if (lineSep === false) { return lines }
	    else { return lines.join(lineSep || this.lineSeparator()) }
	  },
	  getSelections: function(lineSep) {
	    var this$1 = this;

	    var parts = [], ranges = this.sel.ranges;
	    for (var i = 0; i < ranges.length; i++) {
	      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
	      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
	      parts[i] = sel;
	    }
	    return parts
	  },
	  replaceSelection: function(code, collapse, origin) {
	    var dup = [];
	    for (var i = 0; i < this.sel.ranges.length; i++)
	      { dup[i] = code; }
	    this.replaceSelections(dup, collapse, origin || "+input");
	  },
	  replaceSelections: docMethodOp(function(code, collapse, origin) {
	    var this$1 = this;

	    var changes = [], sel = this.sel;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range$$1 = sel.ranges[i];
	      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
	    }
	    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
	      { makeChange(this$1, changes[i$1]); }
	    if (newSel) { setSelectionReplaceHistory(this, newSel); }
	    else if (this.cm) { ensureCursorVisible(this.cm); }
	  }),
	  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

	  setExtending: function(val) {this.extend = val;},
	  getExtending: function() {return this.extend},

	  historySize: function() {
	    var hist = this.history, done = 0, undone = 0;
	    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
	    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
	    return {undo: done, redo: undone}
	  },
	  clearHistory: function() {this.history = new History(this.history.maxGeneration);},

	  markClean: function() {
	    this.cleanGeneration = this.changeGeneration(true);
	  },
	  changeGeneration: function(forceSplit) {
	    if (forceSplit)
	      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
	    return this.history.generation
	  },
	  isClean: function (gen) {
	    return this.history.generation == (gen || this.cleanGeneration)
	  },

	  getHistory: function() {
	    return {done: copyHistoryArray(this.history.done),
	            undone: copyHistoryArray(this.history.undone)}
	  },
	  setHistory: function(histData) {
	    var hist = this.history = new History(this.history.maxGeneration);
	    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	  },

	  setGutterMarker: docMethodOp(function(line, gutterID, value) {
	    return changeLine(this, line, "gutter", function (line) {
	      var markers = line.gutterMarkers || (line.gutterMarkers = {});
	      markers[gutterID] = value;
	      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
	      return true
	    })
	  }),

	  clearGutter: docMethodOp(function(gutterID) {
	    var this$1 = this;

	    this.iter(function (line) {
	      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	        changeLine(this$1, line, "gutter", function () {
	          line.gutterMarkers[gutterID] = null;
	          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
	          return true
	        });
	      }
	    });
	  }),

	  lineInfo: function(line) {
	    var n;
	    if (typeof line == "number") {
	      if (!isLine(this, line)) { return null }
	      n = line;
	      line = getLine(this, line);
	      if (!line) { return null }
	    } else {
	      n = lineNo(line);
	      if (n == null) { return null }
	    }
	    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	            widgets: line.widgets}
	  },

	  addLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass";
	      if (!line[prop]) { line[prop] = cls; }
	      else if (classTest(cls).test(line[prop])) { return false }
	      else { line[prop] += " " + cls; }
	      return true
	    })
	  }),
	  removeLineClass: docMethodOp(function(handle, where, cls) {
	    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	      var prop = where == "text" ? "textClass"
	               : where == "background" ? "bgClass"
	               : where == "gutter" ? "gutterClass" : "wrapClass";
	      var cur = line[prop];
	      if (!cur) { return false }
	      else if (cls == null) { line[prop] = null; }
	      else {
	        var found = cur.match(classTest(cls));
	        if (!found) { return false }
	        var end = found.index + found[0].length;
	        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	      }
	      return true
	    })
	  }),

	  addLineWidget: docMethodOp(function(handle, node, options) {
	    return addLineWidget(this, handle, node, options)
	  }),
	  removeLineWidget: function(widget) { widget.clear(); },

	  markText: function(from, to, options) {
	    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
	  },
	  setBookmark: function(pos, options) {
	    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                    insertLeft: options && options.insertLeft,
	                    clearWhenEmpty: false, shared: options && options.shared,
	                    handleMouseEvents: options && options.handleMouseEvents};
	    pos = clipPos(this, pos);
	    return markText(this, pos, pos, realOpts, "bookmark")
	  },
	  findMarksAt: function(pos) {
	    pos = clipPos(this, pos);
	    var markers = [], spans = getLine(this, pos.line).markedSpans;
	    if (spans) { for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if ((span.from == null || span.from <= pos.ch) &&
	          (span.to == null || span.to >= pos.ch))
	        { markers.push(span.marker.parent || span.marker); }
	    } }
	    return markers
	  },
	  findMarks: function(from, to, filter) {
	    from = clipPos(this, from); to = clipPos(this, to);
	    var found = [], lineNo$$1 = from.line;
	    this.iter(from.line, to.line + 1, function (line) {
	      var spans = line.markedSpans;
	      if (spans) { for (var i = 0; i < spans.length; i++) {
	        var span = spans[i];
	        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
	              span.from == null && lineNo$$1 != from.line ||
	              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
	            (!filter || filter(span.marker)))
	          { found.push(span.marker.parent || span.marker); }
	      } }
	      ++lineNo$$1;
	    });
	    return found
	  },
	  getAllMarks: function() {
	    var markers = [];
	    this.iter(function (line) {
	      var sps = line.markedSpans;
	      if (sps) { for (var i = 0; i < sps.length; ++i)
	        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
	    });
	    return markers
	  },

	  posFromIndex: function(off) {
	    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
	    this.iter(function (line) {
	      var sz = line.text.length + sepSize;
	      if (sz > off) { ch = off; return true }
	      off -= sz;
	      ++lineNo$$1;
	    });
	    return clipPos(this, Pos(lineNo$$1, ch))
	  },
	  indexFromPos: function (coords) {
	    coords = clipPos(this, coords);
	    var index = coords.ch;
	    if (coords.line < this.first || coords.ch < 0) { return 0 }
	    var sepSize = this.lineSeparator().length;
	    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
	      index += line.text.length + sepSize;
	    });
	    return index
	  },

	  copy: function(copyHistory) {
	    var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                      this.modeOption, this.first, this.lineSep, this.direction);
	    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	    doc.sel = this.sel;
	    doc.extend = false;
	    if (copyHistory) {
	      doc.history.undoDepth = this.history.undoDepth;
	      doc.setHistory(this.getHistory());
	    }
	    return doc
	  },

	  linkedDoc: function(options) {
	    if (!options) { options = {}; }
	    var from = this.first, to = this.first + this.size;
	    if (options.from != null && options.from > from) { from = options.from; }
	    if (options.to != null && options.to < to) { to = options.to; }
	    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
	    if (options.sharedHist) { copy.history = this.history
	    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	    copySharedMarkers(copy, findSharedMarkers(this));
	    return copy
	  },
	  unlinkDoc: function(other) {
	    var this$1 = this;

	    if (other instanceof CodeMirror$1) { other = other.doc; }
	    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
	      var link = this$1.linked[i];
	      if (link.doc != other) { continue }
	      this$1.linked.splice(i, 1);
	      other.unlinkDoc(this$1);
	      detachSharedMarkers(findSharedMarkers(this$1));
	      break
	    } }
	    // If the histories were shared, split them again
	    if (other.history == this.history) {
	      var splitIds = [other.id];
	      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
	      other.history = new History(null);
	      other.history.done = copyHistoryArray(this.history.done, splitIds);
	      other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	    }
	  },
	  iterLinkedDocs: function(f) {linkedDocs(this, f);},

	  getMode: function() {return this.mode},
	  getEditor: function() {return this.cm},

	  splitLines: function(str) {
	    if (this.lineSep) { return str.split(this.lineSep) }
	    return splitLinesAuto(str)
	  },
	  lineSeparator: function() { return this.lineSep || "\n" },

	  setDirection: docMethodOp(function (dir) {
	    if (dir != "rtl") { dir = "ltr"; }
	    if (dir == this.direction) { return }
	    this.direction = dir;
	    this.iter(function (line) { return line.order = null; });
	    if (this.cm) { directionChanged(this.cm); }
	  })
	});

	// Public alias.
	Doc.prototype.eachLine = Doc.prototype.iter;

	// Kludge to work around strange IE behavior where it'll sometimes
	// re-fire a series of drag-related events right after the drop (#1551)
	var lastDrop = 0;

	function onDrop(e) {
	  var cm = this;
	  clearDragCursor(cm);
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	    { return }
	  e_preventDefault(e);
	  if (ie) { lastDrop = +new Date; }
	  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	  if (!pos || cm.isReadOnly()) { return }
	  // Might be a file drop, in which case we simply extract the text
	  // and insert it.
	  if (files && files.length && window.FileReader && window.File) {
	    var n = files.length, text = Array(n), read = 0;
	    var loadFile = function (file, i) {
	      if (cm.options.allowDropFileTypes &&
	          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
	        { return }

	      var reader = new FileReader;
	      reader.onload = operation(cm, function () {
	        var content = reader.result;
	        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
	        text[i] = content;
	        if (++read == n) {
	          pos = clipPos(cm.doc, pos);
	          var change = {from: pos, to: pos,
	                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
	                        origin: "paste"};
	          makeChange(cm.doc, change);
	          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
	        }
	      });
	      reader.readAsText(file);
	    };
	    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
	  } else { // Normal drop
	    // Don't do a replace if the drop happened inside of the selected text.
	    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	      cm.state.draggingText(e);
	      // Ensure the editor is re-focused
	      setTimeout(function () { return cm.display.input.focus(); }, 20);
	      return
	    }
	    try {
	      var text$1 = e.dataTransfer.getData("Text");
	      if (text$1) {
	        var selected;
	        if (cm.state.draggingText && !cm.state.draggingText.copy)
	          { selected = cm.listSelections(); }
	        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
	          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
	        cm.replaceSelection(text$1, "around", "paste");
	        cm.display.input.focus();
	      }
	    }
	    catch(e){}
	  }
	}

	function onDragStart(cm, e) {
	  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
	  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

	  e.dataTransfer.setData("Text", cm.getSelection());
	  e.dataTransfer.effectAllowed = "copyMove";

	  // Use dummy image instead of default browsers image.
	  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	  if (e.dataTransfer.setDragImage && !safari) {
	    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	    if (presto) {
	      img.width = img.height = 1;
	      cm.display.wrapper.appendChild(img);
	      // Force a relayout, or Opera won't use our image for some obscure reason
	      img._top = img.offsetTop;
	    }
	    e.dataTransfer.setDragImage(img, 0, 0);
	    if (presto) { img.parentNode.removeChild(img); }
	  }
	}

	function onDragOver(cm, e) {
	  var pos = posFromMouse(cm, e);
	  if (!pos) { return }
	  var frag = document.createDocumentFragment();
	  drawSelectionCursor(cm, pos, frag);
	  if (!cm.display.dragCursor) {
	    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	  }
	  removeChildrenAndAdd(cm.display.dragCursor, frag);
	}

	function clearDragCursor(cm) {
	  if (cm.display.dragCursor) {
	    cm.display.lineSpace.removeChild(cm.display.dragCursor);
	    cm.display.dragCursor = null;
	  }
	}

	// These must be handled carefully, because naively registering a
	// handler for each editor will cause the editors to never be
	// garbage collected.

	function forEachCodeMirror(f) {
	  if (!document.getElementsByClassName) { return }
	  var byClass = document.getElementsByClassName("CodeMirror");
	  for (var i = 0; i < byClass.length; i++) {
	    var cm = byClass[i].CodeMirror;
	    if (cm) { f(cm); }
	  }
	}

	var globalsRegistered = false;
	function ensureGlobalHandlers() {
	  if (globalsRegistered) { return }
	  registerGlobalHandlers();
	  globalsRegistered = true;
	}
	function registerGlobalHandlers() {
	  // When the window resizes, we need to refresh active editors.
	  var resizeTimer;
	  on(window, "resize", function () {
	    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
	      resizeTimer = null;
	      forEachCodeMirror(onResize);
	    }, 100); }
	  });
	  // When the window loses focus, we want to show the editor as blurred
	  on(window, "blur", function () { return forEachCodeMirror(onBlur); });
	}
	// Called when the window resizes
	function onResize(cm) {
	  var d = cm.display;
	  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
	    { return }
	  // Might be a text scaling operation, clear size caches.
	  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	  d.scrollbarsClipped = false;
	  cm.setSize();
	}

	var keyNames = {
	  3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
	  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	};

	// Number keys
	for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
	// Alphabetic keys
	for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
	// Function keys
	for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

	var keyMap = {};

	keyMap.basic = {
	  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	  "Esc": "singleSelection"
	};
	// Note that the save and find-related commands aren't defined by
	// default. User code or addons can define them. Unknown commands
	// are simply ignored.
	keyMap.pcDefault = {
	  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	  fallthrough: "basic"
	};
	// Very basic readline/emacs-style bindings, which are standard on Mac.
	keyMap.emacsy = {
	  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	  "Ctrl-O": "openLine"
	};
	keyMap.macDefault = {
	  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	  fallthrough: ["basic", "emacsy"]
	};
	keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

	// KEYMAP DISPATCH

	function normalizeKeyName(name) {
	  var parts = name.split(/-(?!$)/);
	  name = parts[parts.length - 1];
	  var alt, ctrl, shift, cmd;
	  for (var i = 0; i < parts.length - 1; i++) {
	    var mod = parts[i];
	    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
	    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
	    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
	    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
	    else { throw new Error("Unrecognized modifier name: " + mod) }
	  }
	  if (alt) { name = "Alt-" + name; }
	  if (ctrl) { name = "Ctrl-" + name; }
	  if (cmd) { name = "Cmd-" + name; }
	  if (shift) { name = "Shift-" + name; }
	  return name
	}

	// This is a kludge to keep keymaps mostly working as raw objects
	// (backwards compatibility) while at the same time support features
	// like normalization and multi-stroke key bindings. It compiles a
	// new normalized keymap, and then updates the old object to reflect
	// this.
	function normalizeKeyMap(keymap) {
	  var copy = {};
	  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
	    var value = keymap[keyname];
	    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
	    if (value == "...") { delete keymap[keyname]; continue }

	    var keys = map(keyname.split(" "), normalizeKeyName);
	    for (var i = 0; i < keys.length; i++) {
	      var val = (void 0), name = (void 0);
	      if (i == keys.length - 1) {
	        name = keys.join(" ");
	        val = value;
	      } else {
	        name = keys.slice(0, i + 1).join(" ");
	        val = "...";
	      }
	      var prev = copy[name];
	      if (!prev) { copy[name] = val; }
	      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
	    }
	    delete keymap[keyname];
	  } }
	  for (var prop in copy) { keymap[prop] = copy[prop]; }
	  return keymap
	}

	function lookupKey(key, map$$1, handle, context) {
	  map$$1 = getKeyMap(map$$1);
	  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
	  if (found === false) { return "nothing" }
	  if (found === "...") { return "multi" }
	  if (found != null && handle(found)) { return "handled" }

	  if (map$$1.fallthrough) {
	    if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
	      { return lookupKey(key, map$$1.fallthrough, handle, context) }
	    for (var i = 0; i < map$$1.fallthrough.length; i++) {
	      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
	      if (result) { return result }
	    }
	  }
	}

	// Modifier key presses don't count as 'real' key presses for the
	// purpose of keymap fallthrough.
	function isModifierKey(value) {
	  var name = typeof value == "string" ? value : keyNames[value.keyCode];
	  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
	}

	function addModifierNames(name, event, noShift) {
	  var base = name;
	  if (event.altKey && base != "Alt") { name = "Alt-" + name; }
	  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
	  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
	  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
	  return name
	}

	// Look up the name of a key as indicated by an event object.
	function keyName(event, noShift) {
	  if (presto && event.keyCode == 34 && event["char"]) { return false }
	  var name = keyNames[event.keyCode];
	  if (name == null || event.altGraphKey) { return false }
	  return addModifierNames(name, event, noShift)
	}

	function getKeyMap(val) {
	  return typeof val == "string" ? keyMap[val] : val
	}

	// Helper for deleting text near the selection(s), used to implement
	// backspace, delete, and similar functionality.
	function deleteNearSelection(cm, compute) {
	  var ranges = cm.doc.sel.ranges, kill = [];
	  // Build up a set of ranges to kill first, merging overlapping
	  // ranges.
	  for (var i = 0; i < ranges.length; i++) {
	    var toKill = compute(ranges[i]);
	    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	      var replaced = kill.pop();
	      if (cmp(replaced.from, toKill.from) < 0) {
	        toKill.from = replaced.from;
	        break
	      }
	    }
	    kill.push(toKill);
	  }
	  // Next, remove those actual ranges.
	  runInOp(cm, function () {
	    for (var i = kill.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
	    ensureCursorVisible(cm);
	  });
	}

	function moveCharLogically(line, ch, dir) {
	  var target = skipExtendingChars(line.text, ch + dir, dir);
	  return target < 0 || target > line.text.length ? null : target
	}

	function moveLogically(line, start, dir) {
	  var ch = moveCharLogically(line, start.ch, dir);
	  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
	}

	function endOfLine(visually, cm, lineObj, lineNo, dir) {
	  if (visually) {
	    var order = getOrder(lineObj, cm.doc.direction);
	    if (order) {
	      var part = dir < 0 ? lst(order) : order[0];
	      var moveInStorageOrder = (dir < 0) == (part.level == 1);
	      var sticky = moveInStorageOrder ? "after" : "before";
	      var ch;
	      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
	      // it could be that the last bidi part is not on the last visual line,
	      // since visual lines contain content order-consecutive chunks.
	      // Thus, in rtl, we are looking for the first (content-order) character
	      // in the rtl chunk that is on the last line (that is, the same line
	      // as the last (content-order) character).
	      if (part.level > 0 || cm.doc.direction == "rtl") {
	        var prep = prepareMeasureForLine(cm, lineObj);
	        ch = dir < 0 ? lineObj.text.length - 1 : 0;
	        var targetTop = measureCharPrepared(cm, prep, ch).top;
	        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
	        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
	      } else { ch = dir < 0 ? part.to : part.from; }
	      return new Pos(lineNo, ch, sticky)
	    }
	  }
	  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
	}

	function moveVisually(cm, line, start, dir) {
	  var bidi = getOrder(line, cm.doc.direction);
	  if (!bidi) { return moveLogically(line, start, dir) }
	  if (start.ch >= line.text.length) {
	    start.ch = line.text.length;
	    start.sticky = "before";
	  } else if (start.ch <= 0) {
	    start.ch = 0;
	    start.sticky = "after";
	  }
	  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
	  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
	    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
	    // nothing interesting happens.
	    return moveLogically(line, start, dir)
	  }

	  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
	  var prep;
	  var getWrappedLineExtent = function (ch) {
	    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
	    prep = prep || prepareMeasureForLine(cm, line);
	    return wrappedLineExtentChar(cm, line, prep, ch)
	  };
	  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

	  if (cm.doc.direction == "rtl" || part.level == 1) {
	    var moveInStorageOrder = (part.level == 1) == (dir < 0);
	    var ch = mv(start, moveInStorageOrder ? 1 : -1);
	    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
	      // Case 2: We move within an rtl part or in an rtl editor on the same visual line
	      var sticky = moveInStorageOrder ? "before" : "after";
	      return new Pos(start.line, ch, sticky)
	    }
	  }

	  // Case 3: Could not move within this bidi part in this visual line, so leave
	  // the current bidi part

	  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
	    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
	      ? new Pos(start.line, mv(ch, 1), "before")
	      : new Pos(start.line, ch, "after"); };

	    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
	      var part = bidi[partPos];
	      var moveInStorageOrder = (dir > 0) == (part.level != 1);
	      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
	      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
	      ch = moveInStorageOrder ? part.from : mv(part.to, -1);
	      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
	    }
	  };

	  // Case 3a: Look for other bidi parts on the same visual line
	  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
	  if (res) { return res }

	  // Case 3b: Look for other bidi parts on the next visual line
	  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
	  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
	    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
	    if (res) { return res }
	  }

	  // Case 4: Nowhere to move
	  return null
	}

	// Commands are parameter-less actions that can be performed on an
	// editor, mostly used for keybindings.
	var commands = {
	  selectAll: selectAll,
	  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
	  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
	    if (range.empty()) {
	      var len = getLine(cm.doc, range.head.line).text.length;
	      if (range.head.ch == len && range.head.line < cm.lastLine())
	        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
	      else
	        { return {from: range.head, to: Pos(range.head.line, len)} }
	    } else {
	      return {from: range.from(), to: range.to()}
	    }
	  }); },
	  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0),
	    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
	  }); }); },
	  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	    from: Pos(range.from().line, 0), to: range.from()
	  }); }); },
	  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	    return {from: leftPos, to: range.from()}
	  }); },
	  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
	    var top = cm.charCoords(range.head, "div").top + 5;
	    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	    return {from: range.from(), to: rightPos }
	  }); },
	  undo: function (cm) { return cm.undo(); },
	  redo: function (cm) { return cm.redo(); },
	  undoSelection: function (cm) { return cm.undoSelection(); },
	  redoSelection: function (cm) { return cm.redoSelection(); },
	  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
	  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
	  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
	    {origin: "+move", bias: 1}
	  ); },
	  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
	    {origin: "+move", bias: -1}
	  ); },
	  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
	  }, sel_move); },
	  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    return cm.coordsChar({left: 0, top: top}, "div")
	  }, sel_move); },
	  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
	    var top = cm.cursorCoords(range.head, "div").top + 5;
	    var pos = cm.coordsChar({left: 0, top: top}, "div");
	    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
	    return pos
	  }, sel_move); },
	  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
	  goLineDown: function (cm) { return cm.moveV(1, "line"); },
	  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
	  goPageDown: function (cm) { return cm.moveV(1, "page"); },
	  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
	  goCharRight: function (cm) { return cm.moveH(1, "char"); },
	  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
	  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
	  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
	  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
	  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
	  goWordRight: function (cm) { return cm.moveH(1, "word"); },
	  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
	  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
	  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
	  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
	  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
	  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
	  indentAuto: function (cm) { return cm.indentSelection("smart"); },
	  indentMore: function (cm) { return cm.indentSelection("add"); },
	  indentLess: function (cm) { return cm.indentSelection("subtract"); },
	  insertTab: function (cm) { return cm.replaceSelection("\t"); },
	  insertSoftTab: function (cm) {
	    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	    for (var i = 0; i < ranges.length; i++) {
	      var pos = ranges[i].from();
	      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	      spaces.push(spaceStr(tabSize - col % tabSize));
	    }
	    cm.replaceSelections(spaces);
	  },
	  defaultTab: function (cm) {
	    if (cm.somethingSelected()) { cm.indentSelection("add"); }
	    else { cm.execCommand("insertTab"); }
	  },
	  // Swap the two chars left and right of each selection's head.
	  // Move cursor behind the two swapped characters afterwards.
	  //
	  // Doesn't consider line feeds a character.
	  // Doesn't scan more than one line above to find a character.
	  // Doesn't do anything on an empty line.
	  // Doesn't do anything with non-empty selections.
	  transposeChars: function (cm) { return runInOp(cm, function () {
	    var ranges = cm.listSelections(), newSel = [];
	    for (var i = 0; i < ranges.length; i++) {
	      if (!ranges[i].empty()) { continue }
	      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	      if (line) {
	        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
	        if (cur.ch > 0) {
	          cur = new Pos(cur.line, cur.ch + 1);
	          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                          Pos(cur.line, cur.ch - 2), cur, "+transpose");
	        } else if (cur.line > cm.doc.first) {
	          var prev = getLine(cm.doc, cur.line - 1).text;
	          if (prev) {
	            cur = new Pos(cur.line, 1);
	            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                            prev.charAt(prev.length - 1),
	                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
	          }
	        }
	      }
	      newSel.push(new Range(cur, cur));
	    }
	    cm.setSelections(newSel);
	  }); },
	  newlineAndIndent: function (cm) { return runInOp(cm, function () {
	    var sels = cm.listSelections();
	    for (var i = sels.length - 1; i >= 0; i--)
	      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
	    sels = cm.listSelections();
	    for (var i$1 = 0; i$1 < sels.length; i$1++)
	      { cm.indentLine(sels[i$1].from().line, null, true); }
	    ensureCursorVisible(cm);
	  }); },
	  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
	  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
	};


	function lineStart(cm, lineN) {
	  var line = getLine(cm.doc, lineN);
	  var visual = visualLine(line);
	  if (visual != line) { lineN = lineNo(visual); }
	  return endOfLine(true, cm, visual, lineN, 1)
	}
	function lineEnd(cm, lineN) {
	  var line = getLine(cm.doc, lineN);
	  var visual = visualLineEnd(line);
	  if (visual != line) { lineN = lineNo(visual); }
	  return endOfLine(true, cm, line, lineN, -1)
	}
	function lineStartSmart(cm, pos) {
	  var start = lineStart(cm, pos.line);
	  var line = getLine(cm.doc, start.line);
	  var order = getOrder(line, cm.doc.direction);
	  if (!order || order[0].level == 0) {
	    var firstNonWS = Math.max(0, line.text.search(/\S/));
	    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
	  }
	  return start
	}

	// Run a handler that was bound to a key.
	function doHandleBinding(cm, bound, dropShift) {
	  if (typeof bound == "string") {
	    bound = commands[bound];
	    if (!bound) { return false }
	  }
	  // Ensure previous input has been read, so that the handler sees a
	  // consistent view of the document
	  cm.display.input.ensurePolled();
	  var prevShift = cm.display.shift, done = false;
	  try {
	    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	    if (dropShift) { cm.display.shift = false; }
	    done = bound(cm) != Pass;
	  } finally {
	    cm.display.shift = prevShift;
	    cm.state.suppressEdits = false;
	  }
	  return done
	}

	function lookupKeyForEditor(cm, name, handle) {
	  for (var i = 0; i < cm.state.keyMaps.length; i++) {
	    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	    if (result) { return result }
	  }
	  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	    || lookupKey(name, cm.options.keyMap, handle, cm)
	}

	// Note that, despite the name, this function is also used to check
	// for bound mouse clicks.

	var stopSeq = new Delayed;
	function dispatchKey(cm, name, e, handle) {
	  var seq = cm.state.keySeq;
	  if (seq) {
	    if (isModifierKey(name)) { return "handled" }
	    stopSeq.set(50, function () {
	      if (cm.state.keySeq == seq) {
	        cm.state.keySeq = null;
	        cm.display.input.reset();
	      }
	    });
	    name = seq + " " + name;
	  }
	  var result = lookupKeyForEditor(cm, name, handle);

	  if (result == "multi")
	    { cm.state.keySeq = name; }
	  if (result == "handled")
	    { signalLater(cm, "keyHandled", cm, name, e); }

	  if (result == "handled" || result == "multi") {
	    e_preventDefault(e);
	    restartBlink(cm);
	  }

	  if (seq && !result && /\'$/.test(name)) {
	    e_preventDefault(e);
	    return true
	  }
	  return !!result
	}

	// Handle a key from the keydown event.
	function handleKeyBinding(cm, e) {
	  var name = keyName(e, true);
	  if (!name) { return false }

	  if (e.shiftKey && !cm.state.keySeq) {
	    // First try to resolve full name (including 'Shift-'). Failing
	    // that, see if there is a cursor-motion command (starting with
	    // 'go') bound to the keyname without 'Shift-'.
	    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
	        || dispatchKey(cm, name, e, function (b) {
	             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	               { return doHandleBinding(cm, b) }
	           })
	  } else {
	    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
	  }
	}

	// Handle a key from the keypress event
	function handleCharBinding(cm, e, ch) {
	  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
	}

	var lastStoppedKey = null;
	function onKeyDown(e) {
	  var cm = this;
	  cm.curOp.focus = activeElt();
	  if (signalDOMEvent(cm, e)) { return }
	  // IE does strange things with escape.
	  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
	  var code = e.keyCode;
	  cm.display.shift = code == 16 || e.shiftKey;
	  var handled = handleKeyBinding(cm, e);
	  if (presto) {
	    lastStoppedKey = handled ? code : null;
	    // Opera has no cut event... we try to at least catch the key combo
	    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	      { cm.replaceSelection("", null, "cut"); }
	  }

	  // Turn mouse into crosshair when Alt is held on Mac.
	  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	    { showCrossHair(cm); }
	}

	function showCrossHair(cm) {
	  var lineDiv = cm.display.lineDiv;
	  addClass(lineDiv, "CodeMirror-crosshair");

	  function up(e) {
	    if (e.keyCode == 18 || !e.altKey) {
	      rmClass(lineDiv, "CodeMirror-crosshair");
	      off(document, "keyup", up);
	      off(document, "mouseover", up);
	    }
	  }
	  on(document, "keyup", up);
	  on(document, "mouseover", up);
	}

	function onKeyUp(e) {
	  if (e.keyCode == 16) { this.doc.sel.shift = false; }
	  signalDOMEvent(this, e);
	}

	function onKeyPress(e) {
	  var cm = this;
	  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
	  var keyCode = e.keyCode, charCode = e.charCode;
	  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
	  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
	  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	  // Some browsers fire keypress events for backspace
	  if (ch == "\x08") { return }
	  if (handleCharBinding(cm, e, ch)) { return }
	  cm.display.input.onKeyPress(e);
	}

	var DOUBLECLICK_DELAY = 400;

	var PastClick = function(time, pos, button) {
	  this.time = time;
	  this.pos = pos;
	  this.button = button;
	};

	PastClick.prototype.compare = function (time, pos, button) {
	  return this.time + DOUBLECLICK_DELAY > time &&
	    cmp(pos, this.pos) == 0 && button == this.button
	};

	var lastClick;
	var lastDoubleClick;
	function clickRepeat(pos, button) {
	  var now = +new Date;
	  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
	    lastClick = lastDoubleClick = null;
	    return "triple"
	  } else if (lastClick && lastClick.compare(now, pos, button)) {
	    lastDoubleClick = new PastClick(now, pos, button);
	    lastClick = null;
	    return "double"
	  } else {
	    lastClick = new PastClick(now, pos, button);
	    lastDoubleClick = null;
	    return "single"
	  }
	}

	// A mouse down can be a single click, double click, triple click,
	// start of selection drag, start of text drag, new cursor
	// (ctrl-click), rectangle drag (alt-drag), or xwin
	// middle-click-paste. Or it might be a click on something we should
	// not interfere with, such as a scrollbar or widget.
	function onMouseDown(e) {
	  var cm = this, display = cm.display;
	  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
	  display.input.ensurePolled();
	  display.shift = e.shiftKey;

	  if (eventInWidget(display, e)) {
	    if (!webkit) {
	      // Briefly turn off draggability, to allow widgets to do
	      // normal dragging things.
	      display.scroller.draggable = false;
	      setTimeout(function () { return display.scroller.draggable = true; }, 100);
	    }
	    return
	  }
	  if (clickInGutter(cm, e)) { return }
	  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
	  window.focus();

	  // #3261: make sure, that we're not starting a second selection
	  if (button == 1 && cm.state.selectingText)
	    { cm.state.selectingText(e); }

	  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

	  if (button == 1) {
	    if (pos) { leftButtonDown(cm, pos, repeat, e); }
	    else if (e_target(e) == display.scroller) { e_preventDefault(e); }
	  } else if (button == 2) {
	    if (pos) { extendSelection(cm.doc, pos); }
	    setTimeout(function () { return display.input.focus(); }, 20);
	  } else if (button == 3) {
	    if (captureRightClick) { onContextMenu(cm, e); }
	    else { delayBlurEvent(cm); }
	  }
	}

	function handleMappedButton(cm, button, pos, repeat, event) {
	  var name = "Click";
	  if (repeat == "double") { name = "Double" + name; }
	  else if (repeat == "triple") { name = "Triple" + name; }
	  name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

	  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
	    if (typeof bound == "string") { bound = commands[bound]; }
	    if (!bound) { return false }
	    var done = false;
	    try {
	      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	      done = bound(cm, pos) != Pass;
	    } finally {
	      cm.state.suppressEdits = false;
	    }
	    return done
	  })
	}

	function configureMouse(cm, repeat, event) {
	  var option = cm.getOption("configureMouse");
	  var value = option ? option(cm, repeat, event) : {};
	  if (value.unit == null) {
	    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
	    value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
	  }
	  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
	  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
	  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
	  return value
	}

	function leftButtonDown(cm, pos, repeat, event) {
	  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
	  else { cm.curOp.focus = activeElt(); }

	  var behavior = configureMouse(cm, repeat, event);

	  var sel = cm.doc.sel, contained;
	  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	      repeat == "single" && (contained = sel.contains(pos)) > -1 &&
	      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
	      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
	    { leftButtonStartDrag(cm, event, pos, behavior); }
	  else
	    { leftButtonSelect(cm, event, pos, behavior); }
	}

	// Start a text drag. When it ends, see if any dragging actually
	// happen, and treat as a click if it didn't.
	function leftButtonStartDrag(cm, event, pos, behavior) {
	  var display = cm.display, moved = false;
	  var dragEnd = operation(cm, function (e) {
	    if (webkit) { display.scroller.draggable = false; }
	    cm.state.draggingText = false;
	    off(document, "mouseup", dragEnd);
	    off(document, "mousemove", mouseMove);
	    off(display.scroller, "dragstart", dragStart);
	    off(display.scroller, "drop", dragEnd);
	    if (!moved) {
	      e_preventDefault(e);
	      if (!behavior.addNew)
	        { extendSelection(cm.doc, pos, null, null, behavior.extend); }
	      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	      if (webkit || ie && ie_version == 9)
	        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }
	      else
	        { display.input.focus(); }
	    }
	  });
	  var mouseMove = function(e2) {
	    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
	  };
	  var dragStart = function () { return moved = true; };
	  // Let the drag handler handle this.
	  if (webkit) { display.scroller.draggable = true; }
	  cm.state.draggingText = dragEnd;
	  dragEnd.copy = !behavior.moveOnDrag;
	  // IE's approach to draggable
	  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
	  on(document, "mouseup", dragEnd);
	  on(document, "mousemove", mouseMove);
	  on(display.scroller, "dragstart", dragStart);
	  on(display.scroller, "drop", dragEnd);

	  delayBlurEvent(cm);
	  setTimeout(function () { return display.input.focus(); }, 20);
	}

	function rangeForUnit(cm, pos, unit) {
	  if (unit == "char") { return new Range(pos, pos) }
	  if (unit == "word") { return cm.findWordAt(pos) }
	  if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
	  var result = unit(cm, pos);
	  return new Range(result.from, result.to)
	}

	// Normal selection, as opposed to text dragging.
	function leftButtonSelect(cm, event, start, behavior) {
	  var display = cm.display, doc = cm.doc;
	  e_preventDefault(event);

	  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	  if (behavior.addNew && !behavior.extend) {
	    ourIndex = doc.sel.contains(start);
	    if (ourIndex > -1)
	      { ourRange = ranges[ourIndex]; }
	    else
	      { ourRange = new Range(start, start); }
	  } else {
	    ourRange = doc.sel.primary();
	    ourIndex = doc.sel.primIndex;
	  }

	  if (behavior.unit == "rectangle") {
	    if (!behavior.addNew) { ourRange = new Range(start, start); }
	    start = posFromMouse(cm, event, true, true);
	    ourIndex = -1;
	  } else {
	    var range$$1 = rangeForUnit(cm, start, behavior.unit);
	    if (behavior.extend)
	      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }
	    else
	      { ourRange = range$$1; }
	  }

	  if (!behavior.addNew) {
	    ourIndex = 0;
	    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	    startSel = doc.sel;
	  } else if (ourIndex == -1) {
	    ourIndex = ranges.length;
	    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
	                 {scroll: false, origin: "*mouse"});
	  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
	    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                 {scroll: false, origin: "*mouse"});
	    startSel = doc.sel;
	  } else {
	    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	  }

	  var lastPos = start;
	  function extendTo(pos) {
	    if (cmp(lastPos, pos) == 0) { return }
	    lastPos = pos;

	    if (behavior.unit == "rectangle") {
	      var ranges = [], tabSize = cm.options.tabSize;
	      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	           line <= end; line++) {
	        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	        if (left == right)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
	        else if (text.length > leftPos)
	          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
	      }
	      if (!ranges.length) { ranges.push(new Range(start, start)); }
	      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                   {origin: "*mouse", scroll: false});
	      cm.scrollIntoView(pos);
	    } else {
	      var oldRange = ourRange;
	      var range$$1 = rangeForUnit(cm, pos, behavior.unit);
	      var anchor = oldRange.anchor, head;
	      if (cmp(range$$1.anchor, anchor) > 0) {
	        head = range$$1.head;
	        anchor = minPos(oldRange.from(), range$$1.anchor);
	      } else {
	        head = range$$1.anchor;
	        anchor = maxPos(oldRange.to(), range$$1.head);
	      }
	      var ranges$1 = startSel.ranges.slice(0);
	      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
	      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
	    }
	  }

	  var editorSize = display.wrapper.getBoundingClientRect();
	  // Used to ensure timeout re-tries don't fire when another extend
	  // happened in the meantime (clearTimeout isn't reliable -- at
	  // least on Chrome, the timeouts still happen even when cleared,
	  // if the clear happens after their scheduled firing time).
	  var counter = 0;

	  function extend(e) {
	    var curCount = ++counter;
	    var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
	    if (!cur) { return }
	    if (cmp(cur, lastPos) != 0) {
	      cm.curOp.focus = activeElt();
	      extendTo(cur);
	      var visible = visibleLines(display, doc);
	      if (cur.line >= visible.to || cur.line < visible.from)
	        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
	    } else {
	      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	      if (outside) { setTimeout(operation(cm, function () {
	        if (counter != curCount) { return }
	        display.scroller.scrollTop += outside;
	        extend(e);
	      }), 50); }
	    }
	  }

	  function done(e) {
	    cm.state.selectingText = false;
	    counter = Infinity;
	    e_preventDefault(e);
	    display.input.focus();
	    off(document, "mousemove", move);
	    off(document, "mouseup", up);
	    doc.history.lastSelOrigin = null;
	  }

	  var move = operation(cm, function (e) {
	    if (!e_button(e)) { done(e); }
	    else { extend(e); }
	  });
	  var up = operation(cm, done);
	  cm.state.selectingText = up;
	  on(document, "mousemove", move);
	  on(document, "mouseup", up);
	}

	// Used when mouse-selecting to adjust the anchor to the proper side
	// of a bidi jump depending on the visual position of the head.
	function bidiSimplify(cm, range$$1) {
	  var anchor = range$$1.anchor;
	  var head = range$$1.head;
	  var anchorLine = getLine(cm.doc, anchor.line);
	  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }
	  var order = getOrder(anchorLine);
	  if (!order) { return range$$1 }
	  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
	  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }
	  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
	  if (boundary == 0 || boundary == order.length) { return range$$1 }

	  // Compute the relative visual position of the head compared to the
	  // anchor (<0 is to the left, >0 to the right)
	  var leftSide;
	  if (head.line != anchor.line) {
	    leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
	  } else {
	    var headIndex = getBidiPartAt(order, head.ch, head.sticky);
	    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
	    if (headIndex == boundary - 1 || headIndex == boundary)
	      { leftSide = dir < 0; }
	    else
	      { leftSide = dir > 0; }
	  }

	  var usePart = order[boundary + (leftSide ? -1 : 0)];
	  var from = leftSide == (usePart.level == 1);
	  var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
	  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
	}


	// Determines whether an event happened in the gutter, and fires the
	// handlers for the corresponding event.
	function gutterEvent(cm, e, type, prevent) {
	  var mX, mY;
	  if (e.touches) {
	    mX = e.touches[0].clientX;
	    mY = e.touches[0].clientY;
	  } else {
	    try { mX = e.clientX; mY = e.clientY; }
	    catch(e) { return false }
	  }
	  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
	  if (prevent) { e_preventDefault(e); }

	  var display = cm.display;
	  var lineBox = display.lineDiv.getBoundingClientRect();

	  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
	  mY -= lineBox.top - display.viewOffset;

	  for (var i = 0; i < cm.options.gutters.length; ++i) {
	    var g = display.gutters.childNodes[i];
	    if (g && g.getBoundingClientRect().right >= mX) {
	      var line = lineAtHeight(cm.doc, mY);
	      var gutter = cm.options.gutters[i];
	      signal(cm, type, cm, line, gutter, e);
	      return e_defaultPrevented(e)
	    }
	  }
	}

	function clickInGutter(cm, e) {
	  return gutterEvent(cm, e, "gutterClick", true)
	}

	// CONTEXT MENU HANDLING

	// To make the context menu work, we need to briefly unhide the
	// textarea (making it as unobtrusive as possible) to let the
	// right-click take effect on it.
	function onContextMenu(cm, e) {
	  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
	  if (signalDOMEvent(cm, e, "contextmenu")) { return }
	  cm.display.input.onContextMenu(e);
	}

	function contextMenuInGutter(cm, e) {
	  if (!hasHandler(cm, "gutterContextMenu")) { return false }
	  return gutterEvent(cm, e, "gutterContextMenu", false)
	}

	function themeChanged(cm) {
	  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	  clearCaches(cm);
	}

	var Init = {toString: function(){return "CodeMirror.Init"}};

	var defaults = {};
	var optionHandlers = {};

	function defineOptions(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers;

	  function option(name, deflt, handle, notOnInit) {
	    CodeMirror.defaults[name] = deflt;
	    if (handle) { optionHandlers[name] =
	      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
	  }

	  CodeMirror.defineOption = option;

	  // Passed to option handlers when there is no old value.
	  CodeMirror.Init = Init;

	  // These two are, on init, called from the constructor because they
	  // have to be initialized before the editor can start at all.
	  option("value", "", function (cm, val) { return cm.setValue(val); }, true);
	  option("mode", null, function (cm, val) {
	    cm.doc.modeOption = val;
	    loadMode(cm);
	  }, true);

	  option("indentUnit", 2, loadMode, true);
	  option("indentWithTabs", false);
	  option("smartIndent", true);
	  option("tabSize", 4, function (cm) {
	    resetModeState(cm);
	    clearCaches(cm);
	    regChange(cm);
	  }, true);
	  option("lineSeparator", null, function (cm, val) {
	    cm.doc.lineSep = val;
	    if (!val) { return }
	    var newBreaks = [], lineNo = cm.doc.first;
	    cm.doc.iter(function (line) {
	      for (var pos = 0;;) {
	        var found = line.text.indexOf(val, pos);
	        if (found == -1) { break }
	        pos = found + val.length;
	        newBreaks.push(Pos(lineNo, found));
	      }
	      lineNo++;
	    });
	    for (var i = newBreaks.length - 1; i >= 0; i--)
	      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
	  });
	  option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
	    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	    if (old != Init) { cm.refresh(); }
	  });
	  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
	  option("electricChars", true);
	  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
	    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
	  }, true);
	  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
	  option("rtlMoveVisually", !windows);
	  option("wholeLineUpdateBefore", true);

	  option("theme", "default", function (cm) {
	    themeChanged(cm);
	    guttersChanged(cm);
	  }, true);
	  option("keyMap", "default", function (cm, val, old) {
	    var next = getKeyMap(val);
	    var prev = old != Init && getKeyMap(old);
	    if (prev && prev.detach) { prev.detach(cm, next); }
	    if (next.attach) { next.attach(cm, prev || null); }
	  });
	  option("extraKeys", null);
	  option("configureMouse", null);

	  option("lineWrapping", false, wrappingChanged, true);
	  option("gutters", [], function (cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("fixedGutter", true, function (cm, val) {
	    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	    cm.refresh();
	  }, true);
	  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
	  option("scrollbarStyle", "native", function (cm) {
	    initScrollbars(cm);
	    updateScrollbars(cm);
	    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	  }, true);
	  option("lineNumbers", false, function (cm) {
	    setGuttersForLineNumbers(cm.options);
	    guttersChanged(cm);
	  }, true);
	  option("firstLineNumber", 1, guttersChanged, true);
	  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true);
	  option("showCursorWhenSelecting", false, updateSelection, true);

	  option("resetSelectionOnContextMenu", true);
	  option("lineWiseCopyCut", true);
	  option("pasteLinesPerSelection", true);

	  option("readOnly", false, function (cm, val) {
	    if (val == "nocursor") {
	      onBlur(cm);
	      cm.display.input.blur();
	    }
	    cm.display.input.readOnlyChanged(val);
	  });
	  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
	  option("dragDrop", true, dragDropChanged);
	  option("allowDropFileTypes", null);

	  option("cursorBlinkRate", 530);
	  option("cursorScrollMargin", 0);
	  option("cursorHeight", 1, updateSelection, true);
	  option("singleCursorHeightPerLine", true, updateSelection, true);
	  option("workTime", 100);
	  option("workDelay", 100);
	  option("flattenSpans", true, resetModeState, true);
	  option("addModeClass", false, resetModeState, true);
	  option("pollInterval", 100);
	  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
	  option("historyEventDelay", 1250);
	  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
	  option("maxHighlightLength", 10000, resetModeState, true);
	  option("moveInputWithCursor", true, function (cm, val) {
	    if (!val) { cm.display.input.resetPosition(); }
	  });

	  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
	  option("autofocus", null);
	  option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
	}

	function guttersChanged(cm) {
	  updateGutters(cm);
	  regChange(cm);
	  alignHorizontally(cm);
	}

	function dragDropChanged(cm, value, old) {
	  var wasOn = old && old != Init;
	  if (!value != !wasOn) {
	    var funcs = cm.display.dragFunctions;
	    var toggle = value ? on : off;
	    toggle(cm.display.scroller, "dragstart", funcs.start);
	    toggle(cm.display.scroller, "dragenter", funcs.enter);
	    toggle(cm.display.scroller, "dragover", funcs.over);
	    toggle(cm.display.scroller, "dragleave", funcs.leave);
	    toggle(cm.display.scroller, "drop", funcs.drop);
	  }
	}

	function wrappingChanged(cm) {
	  if (cm.options.lineWrapping) {
	    addClass(cm.display.wrapper, "CodeMirror-wrap");
	    cm.display.sizer.style.minWidth = "";
	    cm.display.sizerWidth = null;
	  } else {
	    rmClass(cm.display.wrapper, "CodeMirror-wrap");
	    findMaxLine(cm);
	  }
	  estimateLineHeights(cm);
	  regChange(cm);
	  clearCaches(cm);
	  setTimeout(function () { return updateScrollbars(cm); }, 100);
	}

	// A CodeMirror instance represents an editor. This is the object
	// that user code is usually dealing with.

	function CodeMirror$1(place, options) {
	  var this$1 = this;

	  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }

	  this.options = options = options ? copyObj(options) : {};
	  // Determine effective options based on given values and defaults.
	  copyObj(defaults, options, false);
	  setGuttersForLineNumbers(options);

	  var doc = options.value;
	  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
	  this.doc = doc;

	  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
	  var display = this.display = new Display(place, doc, input);
	  display.wrapper.CodeMirror = this;
	  updateGutters(this);
	  themeChanged(this);
	  if (options.lineWrapping)
	    { this.display.wrapper.className += " CodeMirror-wrap"; }
	  initScrollbars(this);

	  this.state = {
	    keyMaps: [],  // stores maps added by addKeyMap
	    overlays: [], // highlighting overlays, as added by addOverlay
	    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	    overwrite: false,
	    delayingBlurEvent: false,
	    focused: false,
	    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
	    selectingText: false,
	    draggingText: false,
	    highlight: new Delayed(), // stores highlight worker timeout
	    keySeq: null,  // Unfinished key sequence
	    specialChars: null
	  };

	  if (options.autofocus && !mobile) { display.input.focus(); }

	  // Override magic textarea content restore that IE sometimes does
	  // on our hidden textarea on reload
	  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

	  registerEventHandlers(this);
	  ensureGlobalHandlers();

	  startOperation(this);
	  this.curOp.forceUpdate = true;
	  attachDoc(this, doc);

	  if ((options.autofocus && !mobile) || this.hasFocus())
	    { setTimeout(bind(onFocus, this), 20); }
	  else
	    { onBlur(this); }

	  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
	    { optionHandlers[opt](this$1, options[opt], Init); } }
	  maybeUpdateLineNumberWidth(this);
	  if (options.finishInit) { options.finishInit(this); }
	  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
	  endOperation(this);
	  // Suppress optimizelegibility in Webkit, since it breaks text
	  // measuring on line wrapping boundaries.
	  if (webkit && options.lineWrapping &&
	      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	    { display.lineDiv.style.textRendering = "auto"; }
	}

	// The default configuration options.
	CodeMirror$1.defaults = defaults;
	// Functions to run when options are changed.
	CodeMirror$1.optionHandlers = optionHandlers;

	// Attach the necessary event handlers when initializing the editor
	function registerEventHandlers(cm) {
	  var d = cm.display;
	  on(d.scroller, "mousedown", operation(cm, onMouseDown));
	  // Older IE's will not fire a second mousedown for a double click
	  if (ie && ie_version < 11)
	    { on(d.scroller, "dblclick", operation(cm, function (e) {
	      if (signalDOMEvent(cm, e)) { return }
	      var pos = posFromMouse(cm, e);
	      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
	      e_preventDefault(e);
	      var word = cm.findWordAt(pos);
	      extendSelection(cm.doc, word.anchor, word.head);
	    })); }
	  else
	    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
	  // Some browsers fire contextmenu *after* opening the menu, at
	  // which point we can't mess with it anymore. Context menu is
	  // handled in onMouseDown for these browsers.
	  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }); }

	  // Used to suppress mouse event handling when a touch happens
	  var touchFinished, prevTouch = {end: 0};
	  function finishTouch() {
	    if (d.activeTouch) {
	      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
	      prevTouch = d.activeTouch;
	      prevTouch.end = +new Date;
	    }
	  }
	  function isMouseLikeTouchEvent(e) {
	    if (e.touches.length != 1) { return false }
	    var touch = e.touches[0];
	    return touch.radiusX <= 1 && touch.radiusY <= 1
	  }
	  function farAway(touch, other) {
	    if (other.left == null) { return true }
	    var dx = other.left - touch.left, dy = other.top - touch.top;
	    return dx * dx + dy * dy > 20 * 20
	  }
	  on(d.scroller, "touchstart", function (e) {
	    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
	      d.input.ensurePolled();
	      clearTimeout(touchFinished);
	      var now = +new Date;
	      d.activeTouch = {start: now, moved: false,
	                       prev: now - prevTouch.end <= 300 ? prevTouch : null};
	      if (e.touches.length == 1) {
	        d.activeTouch.left = e.touches[0].pageX;
	        d.activeTouch.top = e.touches[0].pageY;
	      }
	    }
	  });
	  on(d.scroller, "touchmove", function () {
	    if (d.activeTouch) { d.activeTouch.moved = true; }
	  });
	  on(d.scroller, "touchend", function (e) {
	    var touch = d.activeTouch;
	    if (touch && !eventInWidget(d, e) && touch.left != null &&
	        !touch.moved && new Date - touch.start < 300) {
	      var pos = cm.coordsChar(d.activeTouch, "page"), range;
	      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	        { range = new Range(pos, pos); }
	      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	        { range = cm.findWordAt(pos); }
	      else // Triple tap
	        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
	      cm.setSelection(range.anchor, range.head);
	      cm.focus();
	      e_preventDefault(e);
	    }
	    finishTouch();
	  });
	  on(d.scroller, "touchcancel", finishTouch);

	  // Sync scrolling between fake scrollbars and real scrollable
	  // area, ensure viewport is updated when scrolling.
	  on(d.scroller, "scroll", function () {
	    if (d.scroller.clientHeight) {
	      updateScrollTop(cm, d.scroller.scrollTop);
	      setScrollLeft(cm, d.scroller.scrollLeft, true);
	      signal(cm, "scroll", cm);
	    }
	  });

	  // Listen to wheel events in order to try and update the viewport on time.
	  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
	  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

	  // Prevent wrapper from ever scrolling
	  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

	  d.dragFunctions = {
	    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
	    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
	    start: function (e) { return onDragStart(cm, e); },
	    drop: operation(cm, onDrop),
	    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
	  };

	  var inp = d.input.getField();
	  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
	  on(inp, "keydown", operation(cm, onKeyDown));
	  on(inp, "keypress", operation(cm, onKeyPress));
	  on(inp, "focus", function (e) { return onFocus(cm, e); });
	  on(inp, "blur", function (e) { return onBlur(cm, e); });
	}

	var initHooks = [];
	CodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };

	// Indent the given line. The how parameter can be "smart",
	// "add"/null, "subtract", or "prev". When aggressive is false
	// (typically set to true for forced single-line indents), empty
	// lines are not indented, and places where the mode returns Pass
	// are left alone.
	function indentLine(cm, n, how, aggressive) {
	  var doc = cm.doc, state;
	  if (how == null) { how = "add"; }
	  if (how == "smart") {
	    // Fall back to "prev" when the mode doesn't have an indentation
	    // method.
	    if (!doc.mode.indent) { how = "prev"; }
	    else { state = getContextBefore(cm, n).state; }
	  }

	  var tabSize = cm.options.tabSize;
	  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	  if (line.stateAfter) { line.stateAfter = null; }
	  var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	  if (!aggressive && !/\S/.test(line.text)) {
	    indentation = 0;
	    how = "not";
	  } else if (how == "smart") {
	    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	    if (indentation == Pass || indentation > 150) {
	      if (!aggressive) { return }
	      how = "prev";
	    }
	  }
	  if (how == "prev") {
	    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
	    else { indentation = 0; }
	  } else if (how == "add") {
	    indentation = curSpace + cm.options.indentUnit;
	  } else if (how == "subtract") {
	    indentation = curSpace - cm.options.indentUnit;
	  } else if (typeof how == "number") {
	    indentation = curSpace + how;
	  }
	  indentation = Math.max(0, indentation);

	  var indentString = "", pos = 0;
	  if (cm.options.indentWithTabs)
	    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
	  if (pos < indentation) { indentString += spaceStr(indentation - pos); }

	  if (indentString != curSpaceString) {
	    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	    line.stateAfter = null;
	    return true
	  } else {
	    // Ensure that, if the cursor was in the whitespace at the start
	    // of the line, it is moved to the end of that space.
	    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
	      var range = doc.sel.ranges[i$1];
	      if (range.head.line == n && range.head.ch < curSpaceString.length) {
	        var pos$1 = Pos(n, curSpaceString.length);
	        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
	        break
	      }
	    }
	  }
	}

	// This will be set to a {lineWise: bool, text: [string]} object, so
	// that, when pasting, we know what kind of selections the copied
	// text was made out of.
	var lastCopied = null;

	function setLastCopied(newLastCopied) {
	  lastCopied = newLastCopied;
	}

	function applyTextInput(cm, inserted, deleted, sel, origin) {
	  var doc = cm.doc;
	  cm.display.shift = false;
	  if (!sel) { sel = doc.sel; }

	  var paste = cm.state.pasteIncoming || origin == "paste";
	  var textLines = splitLinesAuto(inserted), multiPaste = null;
	  // When pasing N lines into N selections, insert one line per selection
	  if (paste && sel.ranges.length > 1) {
	    if (lastCopied && lastCopied.text.join("\n") == inserted) {
	      if (sel.ranges.length % lastCopied.text.length == 0) {
	        multiPaste = [];
	        for (var i = 0; i < lastCopied.text.length; i++)
	          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
	      }
	    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
	      multiPaste = map(textLines, function (l) { return [l]; });
	    }
	  }

	  var updateInput;
	  // Normal behavior is to insert the new text into every selection
	  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
	    var range$$1 = sel.ranges[i$1];
	    var from = range$$1.from(), to = range$$1.to();
	    if (range$$1.empty()) {
	      if (deleted && deleted > 0) // Handle deletion
	        { from = Pos(from.line, from.ch - deleted); }
	      else if (cm.state.overwrite && !paste) // Handle overwrite
	        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
	      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
	        { from = to = Pos(from.line, 0); }
	    }
	    updateInput = cm.curOp.updateInput;
	    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
	                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
	    makeChange(cm.doc, changeEvent);
	    signalLater(cm, "inputRead", cm, changeEvent);
	  }
	  if (inserted && !paste)
	    { triggerElectric(cm, inserted); }

	  ensureCursorVisible(cm);
	  cm.curOp.updateInput = updateInput;
	  cm.curOp.typing = true;
	  cm.state.pasteIncoming = cm.state.cutIncoming = false;
	}

	function handlePaste(e, cm) {
	  var pasted = e.clipboardData && e.clipboardData.getData("Text");
	  if (pasted) {
	    e.preventDefault();
	    if (!cm.isReadOnly() && !cm.options.disableInput)
	      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
	    return true
	  }
	}

	function triggerElectric(cm, inserted) {
	  // When an 'electric' character is inserted, immediately trigger a reindent
	  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
	  var sel = cm.doc.sel;

	  for (var i = sel.ranges.length - 1; i >= 0; i--) {
	    var range$$1 = sel.ranges[i];
	    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
	    var mode = cm.getModeAt(range$$1.head);
	    var indented = false;
	    if (mode.electricChars) {
	      for (var j = 0; j < mode.electricChars.length; j++)
	        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	          indented = indentLine(cm, range$$1.head.line, "smart");
	          break
	        } }
	    } else if (mode.electricInput) {
	      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
	        { indented = indentLine(cm, range$$1.head.line, "smart"); }
	    }
	    if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
	  }
	}

	function copyableRanges(cm) {
	  var text = [], ranges = [];
	  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	    var line = cm.doc.sel.ranges[i].head.line;
	    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	    ranges.push(lineRange);
	    text.push(cm.getRange(lineRange.anchor, lineRange.head));
	  }
	  return {text: text, ranges: ranges}
	}

	function disableBrowserMagic(field, spellcheck) {
	  field.setAttribute("autocorrect", "off");
	  field.setAttribute("autocapitalize", "off");
	  field.setAttribute("spellcheck", !!spellcheck);
	}

	function hiddenTextarea() {
	  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	  // The textarea is kept positioned near the cursor to prevent the
	  // fact that it'll be scrolled into view on input from scrolling
	  // our fake cursor out of view. On webkit, when wrap=off, paste is
	  // very slow. So make the area wide instead.
	  if (webkit) { te.style.width = "1000px"; }
	  else { te.setAttribute("wrap", "off"); }
	  // If border: 0; -- iOS fails to open keyboard (issue #1287)
	  if (ios) { te.style.border = "1px solid black"; }
	  disableBrowserMagic(te);
	  return div
	}

	// The publicly visible API. Note that methodOp(f) means
	// 'wrap f in an operation, performed on its `this` parameter'.

	// This is not the complete set of editor methods. Most of the
	// methods defined on the Doc type are also injected into
	// CodeMirror.prototype, for backwards compatibility and
	// convenience.

	var addEditorMethods = function(CodeMirror) {
	  var optionHandlers = CodeMirror.optionHandlers;

	  var helpers = CodeMirror.helpers = {};

	  CodeMirror.prototype = {
	    constructor: CodeMirror,
	    focus: function(){window.focus(); this.display.input.focus();},

	    setOption: function(option, value) {
	      var options = this.options, old = options[option];
	      if (options[option] == value && option != "mode") { return }
	      options[option] = value;
	      if (optionHandlers.hasOwnProperty(option))
	        { operation(this, optionHandlers[option])(this, value, old); }
	      signal(this, "optionChange", this, option);
	    },

	    getOption: function(option) {return this.options[option]},
	    getDoc: function() {return this.doc},

	    addKeyMap: function(map$$1, bottom) {
	      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
	    },
	    removeKeyMap: function(map$$1) {
	      var maps = this.state.keyMaps;
	      for (var i = 0; i < maps.length; ++i)
	        { if (maps[i] == map$$1 || maps[i].name == map$$1) {
	          maps.splice(i, 1);
	          return true
	        } }
	    },

	    addOverlay: methodOp(function(spec, options) {
	      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
	      insertSorted(this.state.overlays,
	                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
	                    priority: (options && options.priority) || 0},
	                   function (overlay) { return overlay.priority; });
	      this.state.modeGen++;
	      regChange(this);
	    }),
	    removeOverlay: methodOp(function(spec) {
	      var this$1 = this;

	      var overlays = this.state.overlays;
	      for (var i = 0; i < overlays.length; ++i) {
	        var cur = overlays[i].modeSpec;
	        if (cur == spec || typeof spec == "string" && cur.name == spec) {
	          overlays.splice(i, 1);
	          this$1.state.modeGen++;
	          regChange(this$1);
	          return
	        }
	      }
	    }),

	    indentLine: methodOp(function(n, dir, aggressive) {
	      if (typeof dir != "string" && typeof dir != "number") {
	        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
	        else { dir = dir ? "add" : "subtract"; }
	      }
	      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
	    }),
	    indentSelection: methodOp(function(how) {
	      var this$1 = this;

	      var ranges = this.doc.sel.ranges, end = -1;
	      for (var i = 0; i < ranges.length; i++) {
	        var range$$1 = ranges[i];
	        if (!range$$1.empty()) {
	          var from = range$$1.from(), to = range$$1.to();
	          var start = Math.max(end, from.line);
	          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	          for (var j = start; j < end; ++j)
	            { indentLine(this$1, j, how); }
	          var newRanges = this$1.doc.sel.ranges;
	          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
	        } else if (range$$1.head.line > end) {
	          indentLine(this$1, range$$1.head.line, how, true);
	          end = range$$1.head.line;
	          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
	        }
	      }
	    }),

	    // Fetch the parser token for a given character. Useful for hacks
	    // that want to inspect the mode state (say, for completion).
	    getTokenAt: function(pos, precise) {
	      return takeToken(this, pos, precise)
	    },

	    getLineTokens: function(line, precise) {
	      return takeToken(this, Pos(line), precise, true)
	    },

	    getTokenTypeAt: function(pos) {
	      pos = clipPos(this.doc, pos);
	      var styles = getLineStyles(this, getLine(this.doc, pos.line));
	      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	      var type;
	      if (ch == 0) { type = styles[2]; }
	      else { for (;;) {
	        var mid = (before + after) >> 1;
	        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
	        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
	        else { type = styles[mid * 2 + 2]; break }
	      } }
	      var cut = type ? type.indexOf("overlay ") : -1;
	      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
	    },

	    getModeAt: function(pos) {
	      var mode = this.doc.mode;
	      if (!mode.innerMode) { return mode }
	      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
	    },

	    getHelper: function(pos, type) {
	      return this.getHelpers(pos, type)[0]
	    },

	    getHelpers: function(pos, type) {
	      var this$1 = this;

	      var found = [];
	      if (!helpers.hasOwnProperty(type)) { return found }
	      var help = helpers[type], mode = this.getModeAt(pos);
	      if (typeof mode[type] == "string") {
	        if (help[mode[type]]) { found.push(help[mode[type]]); }
	      } else if (mode[type]) {
	        for (var i = 0; i < mode[type].length; i++) {
	          var val = help[mode[type][i]];
	          if (val) { found.push(val); }
	        }
	      } else if (mode.helperType && help[mode.helperType]) {
	        found.push(help[mode.helperType]);
	      } else if (help[mode.name]) {
	        found.push(help[mode.name]);
	      }
	      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
	        var cur = help._global[i$1];
	        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
	          { found.push(cur.val); }
	      }
	      return found
	    },

	    getStateAfter: function(line, precise) {
	      var doc = this.doc;
	      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	      return getContextBefore(this, line + 1, precise).state
	    },

	    cursorCoords: function(start, mode) {
	      var pos, range$$1 = this.doc.sel.primary();
	      if (start == null) { pos = range$$1.head; }
	      else if (typeof start == "object") { pos = clipPos(this.doc, start); }
	      else { pos = start ? range$$1.from() : range$$1.to(); }
	      return cursorCoords(this, pos, mode || "page")
	    },

	    charCoords: function(pos, mode) {
	      return charCoords(this, clipPos(this.doc, pos), mode || "page")
	    },

	    coordsChar: function(coords, mode) {
	      coords = fromCoordSystem(this, coords, mode || "page");
	      return coordsChar(this, coords.left, coords.top)
	    },

	    lineAtHeight: function(height, mode) {
	      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	      return lineAtHeight(this.doc, height + this.display.viewOffset)
	    },
	    heightAtLine: function(line, mode, includeWidgets) {
	      var end = false, lineObj;
	      if (typeof line == "number") {
	        var last = this.doc.first + this.doc.size - 1;
	        if (line < this.doc.first) { line = this.doc.first; }
	        else if (line > last) { line = last; end = true; }
	        lineObj = getLine(this.doc, line);
	      } else {
	        lineObj = line;
	      }
	      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
	        (end ? this.doc.height - heightAtLine(lineObj) : 0)
	    },

	    defaultTextHeight: function() { return textHeight(this.display) },
	    defaultCharWidth: function() { return charWidth(this.display) },

	    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

	    addWidget: function(pos, node, scroll, vert, horiz) {
	      var display = this.display;
	      pos = cursorCoords(this, clipPos(this.doc, pos));
	      var top = pos.bottom, left = pos.left;
	      node.style.position = "absolute";
	      node.setAttribute("cm-ignore-events", "true");
	      this.display.input.setUneditable(node);
	      display.sizer.appendChild(node);
	      if (vert == "over") {
	        top = pos.top;
	      } else if (vert == "above" || vert == "near") {
	        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	        // Default to positioning above (if specified and possible); otherwise default to positioning below
	        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	          { top = pos.top - node.offsetHeight; }
	        else if (pos.bottom + node.offsetHeight <= vspace)
	          { top = pos.bottom; }
	        if (left + node.offsetWidth > hspace)
	          { left = hspace - node.offsetWidth; }
	      }
	      node.style.top = top + "px";
	      node.style.left = node.style.right = "";
	      if (horiz == "right") {
	        left = display.sizer.clientWidth - node.offsetWidth;
	        node.style.right = "0px";
	      } else {
	        if (horiz == "left") { left = 0; }
	        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
	        node.style.left = left + "px";
	      }
	      if (scroll)
	        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
	    },

	    triggerOnKeyDown: methodOp(onKeyDown),
	    triggerOnKeyPress: methodOp(onKeyPress),
	    triggerOnKeyUp: onKeyUp,
	    triggerOnMouseDown: methodOp(onMouseDown),

	    execCommand: function(cmd) {
	      if (commands.hasOwnProperty(cmd))
	        { return commands[cmd].call(null, this) }
	    },

	    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

	    findPosH: function(from, amount, unit, visually) {
	      var this$1 = this;

	      var dir = 1;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      var cur = clipPos(this.doc, from);
	      for (var i = 0; i < amount; ++i) {
	        cur = findPosH(this$1.doc, cur, dir, unit, visually);
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },

	    moveH: methodOp(function(dir, unit) {
	      var this$1 = this;

	      this.extendSelectionsBy(function (range$$1) {
	        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
	          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
	        else
	          { return dir < 0 ? range$$1.from() : range$$1.to() }
	      }, sel_move);
	    }),

	    deleteH: methodOp(function(dir, unit) {
	      var sel = this.doc.sel, doc = this.doc;
	      if (sel.somethingSelected())
	        { doc.replaceSelection("", null, "+delete"); }
	      else
	        { deleteNearSelection(this, function (range$$1) {
	          var other = findPosH(doc, range$$1.head, dir, unit, false);
	          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
	        }); }
	    }),

	    findPosV: function(from, amount, unit, goalColumn) {
	      var this$1 = this;

	      var dir = 1, x = goalColumn;
	      if (amount < 0) { dir = -1; amount = -amount; }
	      var cur = clipPos(this.doc, from);
	      for (var i = 0; i < amount; ++i) {
	        var coords = cursorCoords(this$1, cur, "div");
	        if (x == null) { x = coords.left; }
	        else { coords.left = x; }
	        cur = findPosV(this$1, coords, dir, unit);
	        if (cur.hitSide) { break }
	      }
	      return cur
	    },

	    moveV: methodOp(function(dir, unit) {
	      var this$1 = this;

	      var doc = this.doc, goals = [];
	      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
	      doc.extendSelectionsBy(function (range$$1) {
	        if (collapse)
	          { return dir < 0 ? range$$1.from() : range$$1.to() }
	        var headPos = cursorCoords(this$1, range$$1.head, "div");
	        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
	        goals.push(headPos.left);
	        var pos = findPosV(this$1, headPos, dir, unit);
	        if (unit == "page" && range$$1 == doc.sel.primary())
	          { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
	        return pos
	      }, sel_move);
	      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
	        { doc.sel.ranges[i].goalColumn = goals[i]; } }
	    }),

	    // Find the word at the given position (as returned by coordsChar).
	    findWordAt: function(pos) {
	      var doc = this.doc, line = getLine(doc, pos.line).text;
	      var start = pos.ch, end = pos.ch;
	      if (line) {
	        var helper = this.getHelper(pos, "wordChars");
	        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
	        var startChar = line.charAt(start);
	        var check = isWordChar(startChar, helper)
	          ? function (ch) { return isWordChar(ch, helper); }
	          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
	          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
	        while (start > 0 && check(line.charAt(start - 1))) { --start; }
	        while (end < line.length && check(line.charAt(end))) { ++end; }
	      }
	      return new Range(Pos(pos.line, start), Pos(pos.line, end))
	    },

	    toggleOverwrite: function(value) {
	      if (value != null && value == this.state.overwrite) { return }
	      if (this.state.overwrite = !this.state.overwrite)
	        { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
	      else
	        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

	      signal(this, "overwriteToggle", this, this.state.overwrite);
	    },
	    hasFocus: function() { return this.display.input.getField() == activeElt() },
	    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

	    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
	    getScrollInfo: function() {
	      var scroller = this.display.scroller;
	      return {left: scroller.scrollLeft, top: scroller.scrollTop,
	              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
	    },

	    scrollIntoView: methodOp(function(range$$1, margin) {
	      if (range$$1 == null) {
	        range$$1 = {from: this.doc.sel.primary().head, to: null};
	        if (margin == null) { margin = this.options.cursorScrollMargin; }
	      } else if (typeof range$$1 == "number") {
	        range$$1 = {from: Pos(range$$1, 0), to: null};
	      } else if (range$$1.from == null) {
	        range$$1 = {from: range$$1, to: null};
	      }
	      if (!range$$1.to) { range$$1.to = range$$1.from; }
	      range$$1.margin = margin || 0;

	      if (range$$1.from.line != null) {
	        scrollToRange(this, range$$1);
	      } else {
	        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);
	      }
	    }),

	    setSize: methodOp(function(width, height) {
	      var this$1 = this;

	      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
	      if (width != null) { this.display.wrapper.style.width = interpret(width); }
	      if (height != null) { this.display.wrapper.style.height = interpret(height); }
	      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
	      var lineNo$$1 = this.display.viewFrom;
	      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
	        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
	          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
	        ++lineNo$$1;
	      });
	      this.curOp.forceUpdate = true;
	      signal(this, "refresh", this);
	    }),

	    operation: function(f){return runInOp(this, f)},
	    startOperation: function(){return startOperation(this)},
	    endOperation: function(){return endOperation(this)},

	    refresh: methodOp(function() {
	      var oldHeight = this.display.cachedTextHeight;
	      regChange(this);
	      this.curOp.forceUpdate = true;
	      clearCaches(this);
	      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
	      updateGutterSpace(this);
	      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	        { estimateLineHeights(this); }
	      signal(this, "refresh", this);
	    }),

	    swapDoc: methodOp(function(doc) {
	      var old = this.doc;
	      old.cm = null;
	      attachDoc(this, doc);
	      clearCaches(this);
	      this.display.input.reset();
	      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
	      this.curOp.forceScroll = true;
	      signalLater(this, "swapDoc", this, old);
	      return old
	    }),

	    getInputField: function(){return this.display.input.getField()},
	    getWrapperElement: function(){return this.display.wrapper},
	    getScrollerElement: function(){return this.display.scroller},
	    getGutterElement: function(){return this.display.gutters}
	  };
	  eventMixin(CodeMirror);

	  CodeMirror.registerHelper = function(type, name, value) {
	    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
	    helpers[type][name] = value;
	  };
	  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	    CodeMirror.registerHelper(type, name, value);
	    helpers[type]._global.push({pred: predicate, val: value});
	  };
	};

	// Used for horizontal relative motion. Dir is -1 or 1 (left or
	// right), unit can be "char", "column" (like char, but doesn't
	// cross line boundaries), "word" (across next word), or "group" (to
	// the start of next group of word or non-word-non-whitespace
	// chars). The visually param controls whether, in right-to-left
	// text, direction 1 means to move towards the next index in the
	// string, or towards the character to the right of the current
	// position. The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosH(doc, pos, dir, unit, visually) {
	  var oldPos = pos;
	  var origDir = dir;
	  var lineObj = getLine(doc, pos.line);
	  function findNextLine() {
	    var l = pos.line + dir;
	    if (l < doc.first || l >= doc.first + doc.size) { return false }
	    pos = new Pos(l, pos.ch, pos.sticky);
	    return lineObj = getLine(doc, l)
	  }
	  function moveOnce(boundToLine) {
	    var next;
	    if (visually) {
	      next = moveVisually(doc.cm, lineObj, pos, dir);
	    } else {
	      next = moveLogically(lineObj, pos, dir);
	    }
	    if (next == null) {
	      if (!boundToLine && findNextLine())
	        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
	      else
	        { return false }
	    } else {
	      pos = next;
	    }
	    return true
	  }

	  if (unit == "char") {
	    moveOnce();
	  } else if (unit == "column") {
	    moveOnce(true);
	  } else if (unit == "word" || unit == "group") {
	    var sawType = null, group = unit == "group";
	    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	    for (var first = true;; first = false) {
	      if (dir < 0 && !moveOnce(!first)) { break }
	      var cur = lineObj.text.charAt(pos.ch) || "\n";
	      var type = isWordChar(cur, helper) ? "w"
	        : group && cur == "\n" ? "n"
	        : !group || /\s/.test(cur) ? null
	        : "p";
	      if (group && !first && !type) { type = "s"; }
	      if (sawType && sawType != type) {
	        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
	        break
	      }

	      if (type) { sawType = type; }
	      if (dir > 0 && !moveOnce(!first)) { break }
	    }
	  }
	  var result = skipAtomic(doc, pos, oldPos, origDir, true);
	  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
	  return result
	}

	// For relative vertical movement. Dir may be -1 or 1. Unit can be
	// "page" or "line". The resulting position will have a hitSide=true
	// property if it reached the end of the document.
	function findPosV(cm, pos, dir, unit) {
	  var doc = cm.doc, x = pos.left, y;
	  if (unit == "page") {
	    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
	    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

	  } else if (unit == "line") {
	    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	  }
	  var target;
	  for (;;) {
	    target = coordsChar(cm, x, y);
	    if (!target.outside) { break }
	    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
	    y += dir * 5;
	  }
	  return target
	}

	// CONTENTEDITABLE INPUT STYLE

	var ContentEditableInput = function(cm) {
	  this.cm = cm;
	  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	  this.polling = new Delayed();
	  this.composing = null;
	  this.gracePeriod = false;
	  this.readDOMTimeout = null;
	};

	ContentEditableInput.prototype.init = function (display) {
	    var this$1 = this;

	  var input = this, cm = input.cm;
	  var div = input.div = display.lineDiv;
	  disableBrowserMagic(div, cm.options.spellcheck);

	  on(div, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
	    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
	  });

	  on(div, "compositionstart", function (e) {
	    this$1.composing = {data: e.data, done: false};
	  });
	  on(div, "compositionupdate", function (e) {
	    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
	  });
	  on(div, "compositionend", function (e) {
	    if (this$1.composing) {
	      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
	      this$1.composing.done = true;
	    }
	  });

	  on(div, "touchstart", function () { return input.forceCompositionEnd(); });

	  on(div, "input", function () {
	    if (!this$1.composing) { this$1.readFromDOMSoon(); }
	  });

	  function onCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()});
	      if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm);
	      setLastCopied({lineWise: true, text: ranges.text});
	      if (e.type == "cut") {
	        cm.operation(function () {
	          cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	          cm.replaceSelection("", null, "cut");
	        });
	      }
	    }
	    if (e.clipboardData) {
	      e.clipboardData.clearData();
	      var content = lastCopied.text.join("\n");
	      // iOS exposes the clipboard API, but seems to discard content inserted into it
	      e.clipboardData.setData("Text", content);
	      if (e.clipboardData.getData("Text") == content) {
	        e.preventDefault();
	        return
	      }
	    }
	    // Old-fashioned briefly-focus-a-textarea hack
	    var kludge = hiddenTextarea(), te = kludge.firstChild;
	    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	    te.value = lastCopied.text.join("\n");
	    var hadFocus = document.activeElement;
	    selectInput(te);
	    setTimeout(function () {
	      cm.display.lineSpace.removeChild(kludge);
	      hadFocus.focus();
	      if (hadFocus == div) { input.showPrimarySelection(); }
	    }, 50);
	  }
	  on(div, "copy", onCopyCut);
	  on(div, "cut", onCopyCut);
	};

	ContentEditableInput.prototype.prepareSelection = function () {
	  var result = prepareSelection(this.cm, false);
	  result.focus = this.cm.state.focused;
	  return result
	};

	ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
	  if (!info || !this.cm.display.view.length) { return }
	  if (info.focus || takeFocus) { this.showPrimarySelection(); }
	  this.showMultipleSelections(info);
	};

	ContentEditableInput.prototype.showPrimarySelection = function () {
	  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
	  var from = prim.from(), to = prim.to();

	  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
	    sel.removeAllRanges();
	    return
	  }

	  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
	  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	      cmp(minPos(curAnchor, curFocus), from) == 0 &&
	      cmp(maxPos(curAnchor, curFocus), to) == 0)
	    { return }

	  var view = cm.display.view;
	  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
	      {node: view[0].measure.map[2], offset: 0};
	  var end = to.line < cm.display.viewTo && posToDOM(cm, to);
	  if (!end) {
	    var measure = view[view.length - 1].measure;
	    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
	  }

	  if (!start || !end) {
	    sel.removeAllRanges();
	    return
	  }

	  var old = sel.rangeCount && sel.getRangeAt(0), rng;
	  try { rng = range(start.node, start.offset, end.offset, end.node); }
	  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	  if (rng) {
	    if (!gecko && cm.state.focused) {
	      sel.collapse(start.node, start.offset);
	      if (!rng.collapsed) {
	        sel.removeAllRanges();
	        sel.addRange(rng);
	      }
	    } else {
	      sel.removeAllRanges();
	      sel.addRange(rng);
	    }
	    if (old && sel.anchorNode == null) { sel.addRange(old); }
	    else if (gecko) { this.startGracePeriod(); }
	  }
	  this.rememberSelection();
	};

	ContentEditableInput.prototype.startGracePeriod = function () {
	    var this$1 = this;

	  clearTimeout(this.gracePeriod);
	  this.gracePeriod = setTimeout(function () {
	    this$1.gracePeriod = false;
	    if (this$1.selectionChanged())
	      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
	  }, 20);
	};

	ContentEditableInput.prototype.showMultipleSelections = function (info) {
	  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	};

	ContentEditableInput.prototype.rememberSelection = function () {
	  var sel = window.getSelection();
	  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
	  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
	};

	ContentEditableInput.prototype.selectionInEditor = function () {
	  var sel = window.getSelection();
	  if (!sel.rangeCount) { return false }
	  var node = sel.getRangeAt(0).commonAncestorContainer;
	  return contains(this.div, node)
	};

	ContentEditableInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor") {
	    if (!this.selectionInEditor())
	      { this.showSelection(this.prepareSelection(), true); }
	    this.div.focus();
	  }
	};
	ContentEditableInput.prototype.blur = function () { this.div.blur(); };
	ContentEditableInput.prototype.getField = function () { return this.div };

	ContentEditableInput.prototype.supportsTouch = function () { return true };

	ContentEditableInput.prototype.receivedFocus = function () {
	  var input = this;
	  if (this.selectionInEditor())
	    { this.pollSelection(); }
	  else
	    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

	  function poll() {
	    if (input.cm.state.focused) {
	      input.pollSelection();
	      input.polling.set(input.cm.options.pollInterval, poll);
	    }
	  }
	  this.polling.set(this.cm.options.pollInterval, poll);
	};

	ContentEditableInput.prototype.selectionChanged = function () {
	  var sel = window.getSelection();
	  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
	};

	ContentEditableInput.prototype.pollSelection = function () {
	  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
	  var sel = window.getSelection(), cm = this.cm;
	  // On Android Chrome (version 56, at least), backspacing into an
	  // uneditable block element will put the cursor in that element,
	  // and then, because it's not editable, hide the virtual keyboard.
	  // Because Android doesn't allow us to actually detect backspace
	  // presses in a sane way, this code checks for when that happens
	  // and simulates a backspace press in this case.
	  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
	    this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
	    this.blur();
	    this.focus();
	    return
	  }
	  if (this.composing) { return }
	  this.rememberSelection();
	  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	  var head = domToPos(cm, sel.focusNode, sel.focusOffset);
	  if (anchor && head) { runInOp(cm, function () {
	    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
	    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
	  }); }
	};

	ContentEditableInput.prototype.pollContent = function () {
	  if (this.readDOMTimeout != null) {
	    clearTimeout(this.readDOMTimeout);
	    this.readDOMTimeout = null;
	  }

	  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
	  var from = sel.from(), to = sel.to();
	  if (from.ch == 0 && from.line > cm.firstLine())
	    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
	  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
	    { to = Pos(to.line + 1, 0); }
	  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

	  var fromIndex, fromLine, fromNode;
	  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	    fromLine = lineNo(display.view[0].line);
	    fromNode = display.view[0].node;
	  } else {
	    fromLine = lineNo(display.view[fromIndex].line);
	    fromNode = display.view[fromIndex - 1].node.nextSibling;
	  }
	  var toIndex = findViewIndex(cm, to.line);
	  var toLine, toNode;
	  if (toIndex == display.view.length - 1) {
	    toLine = display.viewTo - 1;
	    toNode = display.lineDiv.lastChild;
	  } else {
	    toLine = lineNo(display.view[toIndex + 1].line) - 1;
	    toNode = display.view[toIndex + 1].node.previousSibling;
	  }

	  if (!fromNode) { return false }
	  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
	  while (newText.length > 1 && oldText.length > 1) {
	    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
	    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
	    else { break }
	  }

	  var cutFront = 0, cutEnd = 0;
	  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
	  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	    { ++cutFront; }
	  var newBot = lst(newText), oldBot = lst(oldText);
	  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                           oldBot.length - (oldText.length == 1 ? cutFront : 0));
	  while (cutEnd < maxCutEnd &&
	         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	    { ++cutEnd; }
	  // Try to move start of change to start of selection if ambiguous
	  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
	    while (cutFront && cutFront > from.ch &&
	           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
	      cutFront--;
	      cutEnd++;
	    }
	  }

	  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
	  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

	  var chFrom = Pos(fromLine, cutFront);
	  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
	  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	    replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	    return true
	  }
	};

	ContentEditableInput.prototype.ensurePolled = function () {
	  this.forceCompositionEnd();
	};
	ContentEditableInput.prototype.reset = function () {
	  this.forceCompositionEnd();
	};
	ContentEditableInput.prototype.forceCompositionEnd = function () {
	  if (!this.composing) { return }
	  clearTimeout(this.readDOMTimeout);
	  this.composing = null;
	  this.updateFromDOM();
	  this.div.blur();
	  this.div.focus();
	};
	ContentEditableInput.prototype.readFromDOMSoon = function () {
	    var this$1 = this;

	  if (this.readDOMTimeout != null) { return }
	  this.readDOMTimeout = setTimeout(function () {
	    this$1.readDOMTimeout = null;
	    if (this$1.composing) {
	      if (this$1.composing.done) { this$1.composing = null; }
	      else { return }
	    }
	    this$1.updateFromDOM();
	  }, 80);
	};

	ContentEditableInput.prototype.updateFromDOM = function () {
	    var this$1 = this;

	  if (this.cm.isReadOnly() || !this.pollContent())
	    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
	};

	ContentEditableInput.prototype.setUneditable = function (node) {
	  node.contentEditable = "false";
	};

	ContentEditableInput.prototype.onKeyPress = function (e) {
	  if (e.charCode == 0) { return }
	  e.preventDefault();
	  if (!this.cm.isReadOnly())
	    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
	};

	ContentEditableInput.prototype.readOnlyChanged = function (val) {
	  this.div.contentEditable = String(val != "nocursor");
	};

	ContentEditableInput.prototype.onContextMenu = function () {};
	ContentEditableInput.prototype.resetPosition = function () {};

	ContentEditableInput.prototype.needsContentAttribute = true;

	function posToDOM(cm, pos) {
	  var view = findViewForLine(cm, pos.line);
	  if (!view || view.hidden) { return null }
	  var line = getLine(cm.doc, pos.line);
	  var info = mapFromLineView(view, line, pos.line);

	  var order = getOrder(line, cm.doc.direction), side = "left";
	  if (order) {
	    var partPos = getBidiPartAt(order, pos.ch);
	    side = partPos % 2 ? "right" : "left";
	  }
	  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	  result.offset = result.collapse == "right" ? result.end : result.start;
	  return result
	}

	function isInGutter(node) {
	  for (var scan = node; scan; scan = scan.parentNode)
	    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
	  return false
	}

	function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

	function domTextBetween(cm, from, to, fromLine, toLine) {
	  var text = "", closing = false, lineSep = cm.doc.lineSeparator();
	  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
	  function close() {
	    if (closing) {
	      text += lineSep;
	      closing = false;
	    }
	  }
	  function addText(str) {
	    if (str) {
	      close();
	      text += str;
	    }
	  }
	  function walk(node) {
	    if (node.nodeType == 1) {
	      var cmText = node.getAttribute("cm-text");
	      if (cmText != null) {
	        addText(cmText || node.textContent.replace(/\u200b/g, ""));
	        return
	      }
	      var markerID = node.getAttribute("cm-marker"), range$$1;
	      if (markerID) {
	        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
	        if (found.length && (range$$1 = found[0].find(0)))
	          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
	        return
	      }
	      if (node.getAttribute("contenteditable") == "false") { return }
	      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
	      if (isBlock) { close(); }
	      for (var i = 0; i < node.childNodes.length; i++)
	        { walk(node.childNodes[i]); }
	      if (isBlock) { closing = true; }
	    } else if (node.nodeType == 3) {
	      addText(node.nodeValue);
	    }
	  }
	  for (;;) {
	    walk(from);
	    if (from == to) { break }
	    from = from.nextSibling;
	  }
	  return text
	}

	function domToPos(cm, node, offset) {
	  var lineNode;
	  if (node == cm.display.lineDiv) {
	    lineNode = cm.display.lineDiv.childNodes[offset];
	    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
	    node = null; offset = 0;
	  } else {
	    for (lineNode = node;; lineNode = lineNode.parentNode) {
	      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
	      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
	    }
	  }
	  for (var i = 0; i < cm.display.view.length; i++) {
	    var lineView = cm.display.view[i];
	    if (lineView.node == lineNode)
	      { return locateNodeInLineView(lineView, node, offset) }
	  }
	}

	function locateNodeInLineView(lineView, node, offset) {
	  var wrapper = lineView.text.firstChild, bad = false;
	  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
	  if (node == wrapper) {
	    bad = true;
	    node = wrapper.childNodes[offset];
	    offset = 0;
	    if (!node) {
	      var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	      return badPos(Pos(lineNo(line), line.text.length), bad)
	    }
	  }

	  var textNode = node.nodeType == 3 ? node : null, topNode = node;
	  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	    textNode = node.firstChild;
	    if (offset) { offset = textNode.nodeValue.length; }
	  }
	  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
	  var measure = lineView.measure, maps = measure.maps;

	  function find(textNode, topNode, offset) {
	    for (var i = -1; i < (maps ? maps.length : 0); i++) {
	      var map$$1 = i < 0 ? measure.map : maps[i];
	      for (var j = 0; j < map$$1.length; j += 3) {
	        var curNode = map$$1[j + 2];
	        if (curNode == textNode || curNode == topNode) {
	          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	          var ch = map$$1[j] + offset;
	          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
	          return Pos(line, ch)
	        }
	      }
	    }
	  }
	  var found = find(textNode, topNode, offset);
	  if (found) { return badPos(found, bad) }

	  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	    found = find(after, after.firstChild, 0);
	    if (found)
	      { return badPos(Pos(found.line, found.ch - dist), bad) }
	    else
	      { dist += after.textContent.length; }
	  }
	  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
	    found = find(before, before.firstChild, -1);
	    if (found)
	      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
	    else
	      { dist$1 += before.textContent.length; }
	  }
	}

	// TEXTAREA INPUT STYLE

	var TextareaInput = function(cm) {
	  this.cm = cm;
	  // See input.poll and input.reset
	  this.prevInput = "";

	  // Flag that indicates whether we expect input to appear real soon
	  // now (after some event like 'keypress' or 'input') and are
	  // polling intensively.
	  this.pollingFast = false;
	  // Self-resetting timeout for the poller
	  this.polling = new Delayed();
	  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	  this.hasSelection = false;
	  this.composing = null;
	};

	TextareaInput.prototype.init = function (display) {
	    var this$1 = this;

	  var input = this, cm = this.cm;

	  // Wraps and hides input textarea
	  var div = this.wrapper = hiddenTextarea();
	  // The semihidden textarea that is focused when the editor is
	  // focused, and receives input.
	  var te = this.textarea = div.firstChild;
	  display.wrapper.insertBefore(div, display.wrapper.firstChild);

	  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	  if (ios) { te.style.width = "0px"; }

	  on(te, "input", function () {
	    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
	    input.poll();
	  });

	  on(te, "paste", function (e) {
	    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

	    cm.state.pasteIncoming = true;
	    input.fastPoll();
	  });

	  function prepareCopyCut(e) {
	    if (signalDOMEvent(cm, e)) { return }
	    if (cm.somethingSelected()) {
	      setLastCopied({lineWise: false, text: cm.getSelections()});
	    } else if (!cm.options.lineWiseCopyCut) {
	      return
	    } else {
	      var ranges = copyableRanges(cm);
	      setLastCopied({lineWise: true, text: ranges.text});
	      if (e.type == "cut") {
	        cm.setSelections(ranges.ranges, null, sel_dontScroll);
	      } else {
	        input.prevInput = "";
	        te.value = ranges.text.join("\n");
	        selectInput(te);
	      }
	    }
	    if (e.type == "cut") { cm.state.cutIncoming = true; }
	  }
	  on(te, "cut", prepareCopyCut);
	  on(te, "copy", prepareCopyCut);

	  on(display.scroller, "paste", function (e) {
	    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
	    cm.state.pasteIncoming = true;
	    input.focus();
	  });

	  // Prevent normal selection in the editor (we handle our own)
	  on(display.lineSpace, "selectstart", function (e) {
	    if (!eventInWidget(display, e)) { e_preventDefault(e); }
	  });

	  on(te, "compositionstart", function () {
	    var start = cm.getCursor("from");
	    if (input.composing) { input.composing.range.clear(); }
	    input.composing = {
	      start: start,
	      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	    };
	  });
	  on(te, "compositionend", function () {
	    if (input.composing) {
	      input.poll();
	      input.composing.range.clear();
	      input.composing = null;
	    }
	  });
	};

	TextareaInput.prototype.prepareSelection = function () {
	  // Redraw the selection and/or cursor
	  var cm = this.cm, display = cm.display, doc = cm.doc;
	  var result = prepareSelection(cm);

	  // Move the hidden textarea near the cursor to prevent scrolling artifacts
	  if (cm.options.moveInputWithCursor) {
	    var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                        headPos.top + lineOff.top - wrapOff.top));
	    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                         headPos.left + lineOff.left - wrapOff.left));
	  }

	  return result
	};

	TextareaInput.prototype.showSelection = function (drawn) {
	  var cm = this.cm, display = cm.display;
	  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	  removeChildrenAndAdd(display.selectionDiv, drawn.selection);
	  if (drawn.teTop != null) {
	    this.wrapper.style.top = drawn.teTop + "px";
	    this.wrapper.style.left = drawn.teLeft + "px";
	  }
	};

	// Reset the input to correspond to the selection (or to be empty,
	// when not typing and nothing is selected)
	TextareaInput.prototype.reset = function (typing) {
	  if (this.contextMenuPending || this.composing) { return }
	  var cm = this.cm;
	  if (cm.somethingSelected()) {
	    this.prevInput = "";
	    var content = cm.getSelection();
	    this.textarea.value = content;
	    if (cm.state.focused) { selectInput(this.textarea); }
	    if (ie && ie_version >= 9) { this.hasSelection = content; }
	  } else if (!typing) {
	    this.prevInput = this.textarea.value = "";
	    if (ie && ie_version >= 9) { this.hasSelection = null; }
	  }
	};

	TextareaInput.prototype.getField = function () { return this.textarea };

	TextareaInput.prototype.supportsTouch = function () { return false };

	TextareaInput.prototype.focus = function () {
	  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	    try { this.textarea.focus(); }
	    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	  }
	};

	TextareaInput.prototype.blur = function () { this.textarea.blur(); };

	TextareaInput.prototype.resetPosition = function () {
	  this.wrapper.style.top = this.wrapper.style.left = 0;
	};

	TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

	// Poll for input changes, using the normal rate of polling. This
	// runs as long as the editor is focused.
	TextareaInput.prototype.slowPoll = function () {
	    var this$1 = this;

	  if (this.pollingFast) { return }
	  this.polling.set(this.cm.options.pollInterval, function () {
	    this$1.poll();
	    if (this$1.cm.state.focused) { this$1.slowPoll(); }
	  });
	};

	// When an event has just come in that is likely to add or change
	// something in the input textarea, we poll faster, to ensure that
	// the change appears on the screen quickly.
	TextareaInput.prototype.fastPoll = function () {
	  var missed = false, input = this;
	  input.pollingFast = true;
	  function p() {
	    var changed = input.poll();
	    if (!changed && !missed) {missed = true; input.polling.set(60, p);}
	    else {input.pollingFast = false; input.slowPoll();}
	  }
	  input.polling.set(20, p);
	};

	// Read input from the textarea, and update the document to match.
	// When something is selected, it is present in the textarea, and
	// selected (unless it is huge, in which case a placeholder is
	// used). When nothing is selected, the cursor sits after previously
	// seen text (can be empty), which is stored in prevInput (we must
	// not reset the textarea when typing, because that breaks IME).
	TextareaInput.prototype.poll = function () {
	    var this$1 = this;

	  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
	  // Since this is called a *lot*, try to bail out as cheaply as
	  // possible when it is clear that nothing happened. hasSelection
	  // will be the case when there is a lot of text in the textarea,
	  // in which case reading its value would be expensive.
	  if (this.contextMenuPending || !cm.state.focused ||
	      (hasSelection(input) && !prevInput && !this.composing) ||
	      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	    { return false }

	  var text = input.value;
	  // If nothing changed, bail.
	  if (text == prevInput && !cm.somethingSelected()) { return false }
	  // Work around nonsensical selection resetting in IE9/10, and
	  // inexplicable appearance of private area unicode characters on
	  // some key combos in Mac (#2689).
	  if (ie && ie_version >= 9 && this.hasSelection === text ||
	      mac && /[\uf700-\uf7ff]/.test(text)) {
	    cm.display.input.reset();
	    return false
	  }

	  if (cm.doc.sel == cm.display.selForContextMenu) {
	    var first = text.charCodeAt(0);
	    if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
	    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
	  }
	  // Find the part of the input that is actually new
	  var same = 0, l = Math.min(prevInput.length, text.length);
	  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

	  runInOp(cm, function () {
	    applyTextInput(cm, text.slice(same), prevInput.length - same,
	                   null, this$1.composing ? "*compose" : null);

	    // Don't leave long text in the textarea, since it makes further polling slow
	    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
	    else { this$1.prevInput = text; }

	    if (this$1.composing) {
	      this$1.composing.range.clear();
	      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
	                                         {className: "CodeMirror-composing"});
	    }
	  });
	  return true
	};

	TextareaInput.prototype.ensurePolled = function () {
	  if (this.pollingFast && this.poll()) { this.pollingFast = false; }
	};

	TextareaInput.prototype.onKeyPress = function () {
	  if (ie && ie_version >= 9) { this.hasSelection = null; }
	  this.fastPoll();
	};

	TextareaInput.prototype.onContextMenu = function (e) {
	  var input = this, cm = input.cm, display = cm.display, te = input.textarea;
	  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	  if (!pos || presto) { return } // Opera is difficult.

	  // Reset the current text selection only if the click is done outside of the selection
	  // and 'resetSelectionOnContextMenu' option is true.
	  var reset = cm.options.resetSelectionOnContextMenu;
	  if (reset && cm.doc.sel.contains(pos) == -1)
	    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

	  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
	  input.wrapper.style.cssText = "position: absolute";
	  var wrapperBox = input.wrapper.getBoundingClientRect();
	  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	  var oldScrollY;
	  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
	  display.input.focus();
	  if (webkit) { window.scrollTo(null, oldScrollY); }
	  display.input.reset();
	  // Adds "Select all" to context menu in FF
	  if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
	  input.contextMenuPending = true;
	  display.selForContextMenu = cm.doc.sel;
	  clearTimeout(display.detectingSelectAll);

	  // Select-all will be greyed out if there's nothing to select, so
	  // this adds a zero-width space so that we can later check whether
	  // it got selected.
	  function prepareSelectAllHack() {
	    if (te.selectionStart != null) {
	      var selected = cm.somethingSelected();
	      var extval = "\u200b" + (selected ? te.value : "");
	      te.value = "\u21da"; // Used to catch context-menu undo
	      te.value = extval;
	      input.prevInput = selected ? "" : "\u200b";
	      te.selectionStart = 1; te.selectionEnd = extval.length;
	      // Re-set this, in case some other handler touched the
	      // selection in the meantime.
	      display.selForContextMenu = cm.doc.sel;
	    }
	  }
	  function rehide() {
	    input.contextMenuPending = false;
	    input.wrapper.style.cssText = oldWrapperCSS;
	    te.style.cssText = oldCSS;
	    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

	    // Try to detect the user choosing select-all
	    if (te.selectionStart != null) {
	      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
	      var i = 0, poll = function () {
	        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	            te.selectionEnd > 0 && input.prevInput == "\u200b") {
	          operation(cm, selectAll)(cm);
	        } else if (i++ < 10) {
	          display.detectingSelectAll = setTimeout(poll, 500);
	        } else {
	          display.selForContextMenu = null;
	          display.input.reset();
	        }
	      };
	      display.detectingSelectAll = setTimeout(poll, 200);
	    }
	  }

	  if (ie && ie_version >= 9) { prepareSelectAllHack(); }
	  if (captureRightClick) {
	    e_stop(e);
	    var mouseup = function () {
	      off(window, "mouseup", mouseup);
	      setTimeout(rehide, 20);
	    };
	    on(window, "mouseup", mouseup);
	  } else {
	    setTimeout(rehide, 50);
	  }
	};

	TextareaInput.prototype.readOnlyChanged = function (val) {
	  if (!val) { this.reset(); }
	  this.textarea.disabled = val == "nocursor";
	};

	TextareaInput.prototype.setUneditable = function () {};

	TextareaInput.prototype.needsContentAttribute = false;

	function fromTextArea(textarea, options) {
	  options = options ? copyObj(options) : {};
	  options.value = textarea.value;
	  if (!options.tabindex && textarea.tabIndex)
	    { options.tabindex = textarea.tabIndex; }
	  if (!options.placeholder && textarea.placeholder)
	    { options.placeholder = textarea.placeholder; }
	  // Set autofocus to true if this textarea is focused, or if it has
	  // autofocus and no other element is focused.
	  if (options.autofocus == null) {
	    var hasFocus = activeElt();
	    options.autofocus = hasFocus == textarea ||
	      textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	  }

	  function save() {textarea.value = cm.getValue();}

	  var realSubmit;
	  if (textarea.form) {
	    on(textarea.form, "submit", save);
	    // Deplorable hack to make the submit method do the right thing.
	    if (!options.leaveSubmitMethodAlone) {
	      var form = textarea.form;
	      realSubmit = form.submit;
	      try {
	        var wrappedSubmit = form.submit = function () {
	          save();
	          form.submit = realSubmit;
	          form.submit();
	          form.submit = wrappedSubmit;
	        };
	      } catch(e) {}
	    }
	  }

	  options.finishInit = function (cm) {
	    cm.save = save;
	    cm.getTextArea = function () { return textarea; };
	    cm.toTextArea = function () {
	      cm.toTextArea = isNaN; // Prevent this from being ran twice
	      save();
	      textarea.parentNode.removeChild(cm.getWrapperElement());
	      textarea.style.display = "";
	      if (textarea.form) {
	        off(textarea.form, "submit", save);
	        if (typeof textarea.form.submit == "function")
	          { textarea.form.submit = realSubmit; }
	      }
	    };
	  };

	  textarea.style.display = "none";
	  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
	    options);
	  return cm
	}

	function addLegacyProps(CodeMirror) {
	  CodeMirror.off = off;
	  CodeMirror.on = on;
	  CodeMirror.wheelEventPixels = wheelEventPixels;
	  CodeMirror.Doc = Doc;
	  CodeMirror.splitLines = splitLinesAuto;
	  CodeMirror.countColumn = countColumn;
	  CodeMirror.findColumn = findColumn;
	  CodeMirror.isWordChar = isWordCharBasic;
	  CodeMirror.Pass = Pass;
	  CodeMirror.signal = signal;
	  CodeMirror.Line = Line;
	  CodeMirror.changeEnd = changeEnd;
	  CodeMirror.scrollbarModel = scrollbarModel;
	  CodeMirror.Pos = Pos;
	  CodeMirror.cmpPos = cmp;
	  CodeMirror.modes = modes;
	  CodeMirror.mimeModes = mimeModes;
	  CodeMirror.resolveMode = resolveMode;
	  CodeMirror.getMode = getMode;
	  CodeMirror.modeExtensions = modeExtensions;
	  CodeMirror.extendMode = extendMode;
	  CodeMirror.copyState = copyState;
	  CodeMirror.startState = startState;
	  CodeMirror.innerMode = innerMode;
	  CodeMirror.commands = commands;
	  CodeMirror.keyMap = keyMap;
	  CodeMirror.keyName = keyName;
	  CodeMirror.isModifierKey = isModifierKey;
	  CodeMirror.lookupKey = lookupKey;
	  CodeMirror.normalizeKeyMap = normalizeKeyMap;
	  CodeMirror.StringStream = StringStream;
	  CodeMirror.SharedTextMarker = SharedTextMarker;
	  CodeMirror.TextMarker = TextMarker;
	  CodeMirror.LineWidget = LineWidget;
	  CodeMirror.e_preventDefault = e_preventDefault;
	  CodeMirror.e_stopPropagation = e_stopPropagation;
	  CodeMirror.e_stop = e_stop;
	  CodeMirror.addClass = addClass;
	  CodeMirror.contains = contains;
	  CodeMirror.rmClass = rmClass;
	  CodeMirror.keyNames = keyNames;
	}

	// EDITOR CONSTRUCTOR

	defineOptions(CodeMirror$1);

	addEditorMethods(CodeMirror$1);

	// Set up methods on CodeMirror's prototype to redirect to the editor's document.
	var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
	for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	  { CodeMirror$1.prototype[prop] = (function(method) {
	    return function() {return method.apply(this.doc, arguments)}
	  })(Doc.prototype[prop]); } }

	eventMixin(Doc);

	// INPUT HANDLING

	CodeMirror$1.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

	// MODE DEFINITION AND QUERYING

	// Extra arguments are stored as the mode's dependencies, which is
	// used by (legacy) mechanisms like loadmode.js to automatically
	// load a mode. (Preferred mechanism is the require/define calls.)
	CodeMirror$1.defineMode = function(name/*, mode, */) {
	  if (!CodeMirror$1.defaults.mode && name != "null") { CodeMirror$1.defaults.mode = name; }
	  defineMode.apply(this, arguments);
	};

	CodeMirror$1.defineMIME = defineMIME;

	// Minimal default mode.
	CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
	CodeMirror$1.defineMIME("text/plain", "null");

	// EXTENSIONS

	CodeMirror$1.defineExtension = function (name, func) {
	  CodeMirror$1.prototype[name] = func;
	};
	CodeMirror$1.defineDocExtension = function (name, func) {
	  Doc.prototype[name] = func;
	};

	CodeMirror$1.fromTextArea = fromTextArea;

	addLegacyProps(CodeMirror$1);

	CodeMirror$1.version = "5.31.0";

	return CodeMirror$1;

	})));


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	var baseMerge = __webpack_require__(191),
	    createAssigner = __webpack_require__(209);

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	module.exports = merge;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(61),
	    assignMergeValue = __webpack_require__(192),
	    baseFor = __webpack_require__(22),
	    baseMergeDeep = __webpack_require__(193),
	    isObject = __webpack_require__(51),
	    keysIn = __webpack_require__(206);

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    if (isObject(srcValue)) {
	      stack || (stack = new Stack);
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	module.exports = baseMerge;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(149),
	    eq = __webpack_require__(66);

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignMergeValue;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	var assignMergeValue = __webpack_require__(192),
	    cloneBuffer = __webpack_require__(194),
	    cloneTypedArray = __webpack_require__(195),
	    copyArray = __webpack_require__(197),
	    initCloneObject = __webpack_require__(198),
	    isArguments = __webpack_require__(27),
	    isArray = __webpack_require__(36),
	    isArrayLikeObject = __webpack_require__(201),
	    isBuffer = __webpack_require__(37),
	    isFunction = __webpack_require__(50),
	    isObject = __webpack_require__(51),
	    isPlainObject = __webpack_require__(202),
	    isTypedArray = __webpack_require__(40),
	    toPlainObject = __webpack_require__(203);

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = object[key],
	      srcValue = source[key],
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	module.exports = baseMergeDeep;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(31);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module)))

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(196);

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	module.exports = cloneTypedArray;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	var Uint8Array = __webpack_require__(106);

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	module.exports = cloneArrayBuffer;


/***/ }),
/* 197 */
/***/ (function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	module.exports = copyArray;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(199),
	    getPrototype = __webpack_require__(200),
	    isPrototype = __webpack_require__(46);

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	module.exports = initCloneObject;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(51);

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	module.exports = baseCreate;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(48);

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	module.exports = getPrototype;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(49),
	    isObjectLike = __webpack_require__(35);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(29),
	    getPrototype = __webpack_require__(200),
	    isObjectLike = __webpack_require__(35);

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	module.exports = isPlainObject;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(204),
	    keysIn = __webpack_require__(206);

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}

	module.exports = toPlainObject;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(205),
	    baseAssignValue = __webpack_require__(149);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(149),
	    eq = __webpack_require__(66);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(25),
	    baseKeysIn = __webpack_require__(207),
	    isArrayLike = __webpack_require__(49);

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	module.exports = keysIn;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(51),
	    isPrototype = __webpack_require__(46),
	    nativeKeysIn = __webpack_require__(208);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeysIn;


/***/ }),
/* 208 */
/***/ (function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(210),
	    isIterateeCall = __webpack_require__(217);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(54),
	    overRest = __webpack_require__(211),
	    setToString = __webpack_require__(213);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(212);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ }),
/* 212 */
/***/ (function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(214),
	    shortOut = __webpack_require__(216);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(215),
	    defineProperty = __webpack_require__(150),
	    identity = __webpack_require__(54);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ }),
/* 215 */
/***/ (function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ }),
/* 216 */
/***/ (function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(66),
	    isArrayLike = __webpack_require__(49),
	    isIndex = __webpack_require__(39),
	    isObject = __webpack_require__(51);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TelemetryQuery = undefined;

	var _map = __webpack_require__(146);

	var _map2 = _interopRequireDefault(_map);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	 * TelemetryQuery Component
	 *
	 * Generate and run queries against captured telemetry data in PCAP files and
	 * retrieve a CSV of the resulting data.
	 *
	 * Configuration attributes:
	 *      data-dir (optional): The data directory key specifying which directory
	 *          should be used when gathering telemetry data PCAPs.
	 *
	 *      packet (optional): The name of the packet definition in the telemetry
	 *          dictionary from which fields will be selected for the query.
	 *
	 *      time-field (optional): The telemetry field name that will be used as the
	 *          time baseline in the query.
	 *
	 *      Note, specifying one or more of these optional attributes will remove
	 *      the corresponding input field from the UI.
	 *
	 * Example Tags:
	 *  <bliss-telemetryquery></bliss-telemetryquery>
	 *
	 *  <bliss-telemetryquery data-dir='/tmp/fakepcapdir'
	 *                        packet='1553_EHS_Packet'
	 *                        time-field='time_coarse'>
	 *  </bliss-telemetryquery>
	 *
	 */
	var TelemetryQuery = {
	    _data_paths: {},
	    _packet: null,
	    _fields: [],
	    _querying: false,
	    _validation_errors: {},
	    _tlm_dict: null,

	    oninit: function oninit(vnode) {
	        var _this = this;

	        m.request({
	            method: 'GET',
	            url: '/data'
	        }).then(function (data) {
	            _this._data_paths = data;
	        });

	        // We need to delay setting the _packet value to the corresponding
	        // attribute in vnode.attrs (if specified) to ensure that we aren't
	        // attempting to read from the potentially unloaded tlm dictionary. We
	        // could use the tlm.promise in the other sections of the code but
	        // it increases the complexity a good bit and the logic is already
	        // present to check if this._packet is set regardless of packet being
	        // set in vnode.attrs or not.
	        bliss.tlm.promise.then(function () {
	            if ('packet' in vnode.attrs) {
	                _this._packet = vnode.attrs['packet'];
	            }
	        });
	    },
	    view: function view(vnode) {
	        var _this2 = this;

	        var dataDir = void 0;
	        if ('data-dir' in vnode.attrs) {
	            dataDir = m('input', { type: 'hidden', name: 'dataDir', value: vnode.attrs['data-dir'] });
	        } else {
	            dataDir = m('div', { class: 'form-group' }, [m('label', 'Data Directory'), m('select', { class: 'form-control', name: 'dataDir' }, [m('option', {
	                disabled: 'disabled',
	                selected: 'selected'
	            }, 'Select an option ...')].concat((0, _map2.default)(Object.keys(this._data_paths), function (k) {
	                return m('option', { value: k }, k + ': ' + _this2._data_paths[k]);
	            }))), m('p', { class: 'help-block' }, 'The archive data directory containing the relevant telemetry data over which to search')]);

	            if (this._validation_errors['dataDir']) {
	                dataDir.attrs.className += ' has-error';
	            }
	        }

	        var packets = void 0;
	        if ('packet' in vnode.attrs) {
	            packets = m('input', { type: 'hidden', name: 'packet', value: vnode.attrs['packet'] });
	        } else {
	            packets = m('div', { class: 'form-group' }, [m('label', 'Telemetry Packet'), m('select', {
	                class: 'form-control',
	                name: 'packet',
	                onchange: function onchange(e) {
	                    _this2._packet = e.currentTarget.value;
	                }
	            }, [m('option', {
	                disabled: 'disabled',
	                selected: 'selected'
	            }, 'Select an option ...')].concat((0, _map2.default)(Object.keys(bliss.tlm.dict), function (k) {
	                return m('option', { value: k }, k);
	            }))), m('p', { class: 'help-block' }, 'The telemetry packet that contains the fields to be queried')]);
	        }

	        if (this._validation_errors['packet']) {
	            packets.attrs.className += ' has-error';
	        }

	        var fieldOpts = null;
	        if (this._packet === null) {
	            fieldOpts = [];
	        } else {
	            fieldOpts = [m('option', {
	                disabled: 'disabled',
	                selected: 'selected',
	                value: 'bogusDefaultSelectOption'
	            }, 'Select an option ...')].concat((0, _map2.default)(Object.keys(bliss.tlm.dict[this._packet].fields).sort(), function (k) {
	                return m('option', { value: k }, k);
	            }));
	        }

	        var timeField = void 0;
	        if ('time-field' in vnode.attrs) {
	            timeField = m('input', { type: 'hidden', name: 'timeField', value: vnode.attrs['time-field'] });
	        } else {
	            timeField = m('div', { class: 'form-group' }, [m('label', 'Telemetry Time Field'), m('select', { class: 'form-control', name: 'timeField' }, fieldOpts), m('p', { class: 'help-block' }, 'Select and add the telemetry time field to use as a basis for the query')]);

	            if (this._validation_errors['timeField']) {
	                timeField.attrs.className += ' has-error';
	            }
	        }

	        var fields = m('div', { class: 'form-group' }, [m('label', 'Telemetry Fields'), m('div', { class: 'input-group' }, m('select', { class: 'form-control', name: 'fields' }, fieldOpts), m('div', { class: 'input-group-btn' }, m('button', {
	            class: 'btn btn-default',
	            type: 'button',
	            onmousedown: function onmousedown(e) {
	                e.preventDefault();
	                var select = e.currentTarget.parentElement.parentElement.children[0];
	                _this2._fields.push(select.value);
	                select.value = 'bogusDefaultSelectOption';
	            }
	        }, 'Add'))), m('p', { class: 'help-block' }, 'Select and add the telemetry field(s) to query')]);

	        if (this._validation_errors['fields']) {
	            fields.attrs.className += ' has-error';
	        }

	        var selectedFields = m('span');
	        if (this._fields.length !== 0) {
	            selectedFields = m('div', { class: 'form-group' }, [m('label', 'Fields selected for query'), m('div', { class: 'field_selection' }, (0, _map2.default)(this._fields, function (val, i) {
	                return m('div', {
	                    class: 'label label-default field_label',
	                    onmouseover: function onmouseover(e) {
	                        e.currentTarget.classList.add('label-danger');
	                    },
	                    onmouseout: function onmouseout(e) {
	                        e.currentTarget.classList.remove('label-danger');
	                    },
	                    onclick: function onclick(e) {
	                        _this2._fields.splice(i, 1);
	                    }
	                }, val);
	            })), m('p', { class: 'help-block' }, 'The telemetry points that will be filtered from the selected data')]);
	        }

	        var startTime = m('div', { class: 'form-group' }, [m('label', 'Start Time'), m('input', { class: 'form-control', placeholder: 'Start time YYYY-MM-DDTHH:MM:SSZ', name: 'startTime' }), m('p', { class: 'help-block' }, 'Start time for data filtering. Expected format: YYYY-MM-DDTHH:MM:SSZ')]);

	        if (this._validation_errors['startTime']) {
	            startTime.attrs.className += ' has-error';
	        }

	        var endTime = m('div', { class: 'form-group' }, [m('label', 'End Time'), m('input', { class: 'form-control', placeholder: 'End time YYYY-MM-DDTHH:MM:SSZ', name: 'endTime' }), m('p', { class: 'help-block' }, 'End time for data filtering. Expected format: YYYY-MM-DDTHH:MM:SSZ')]);

	        if (this._validation_errors['endTime']) {
	            endTime.attrs.className += ' has-error';
	        }

	        var btnText = 'Query';
	        var btnAttrs = { class: 'btn btn-success pull-right', type: 'submit' };

	        if (this._querying) {
	            btnText = m('span', { class: 'glyphicon glyphicon-refresh right-spin' });
	            btnAttrs['disabled'] = 'disabled';
	        }

	        var queryBtn = m('button', btnAttrs, btnText);

	        var form = m('form', {
	            onsubmit: function onsubmit(e) {
	                e.preventDefault();
	                var data = new FormData();
	                var form = e.currentTarget;

	                if (!_this2._validate_form(form)) {
	                    return false;
	                }

	                data.append('dataDir', _this2._data_paths[form.elements['dataDir'].value]);
	                data.append('timeField', form.elements['timeField'].value);
	                data.append('packet', form.elements['packet'].value);
	                data.append('fields', _this2._fields);
	                data.append('startTime', form.elements['startTime'].value);
	                data.append('endTime', form.elements['endTime'].value);

	                _this2._querying = true;
	                m.request({
	                    url: '/tlm/query',
	                    method: 'POST',
	                    data: data,
	                    extract: function extract(xhr) {
	                        return xhr;
	                    }
	                }).then(function (r) {
	                    _this2._querying = false;

	                    // Trigger download of the returned CSV
	                    var blob = new Blob([r.response]);
	                    var link = document.createElement('a');
	                    link.href = window.URL.createObjectURL(blob);
	                    link.download = "query_output.csv";
	                    link.click();

	                    form.reset();
	                    if (!('data-dir' in vnode.attrs)) {
	                        form.elements['dataDir'].selectedIndex = 0;
	                    }

	                    if (!('packet' in vnode.attrs)) {
	                        form.elements['packet'].selectedIndex = 0;
	                        _this2._packet = null;
	                    } else {
	                        // If packet is specified in vnode.attrs we need to
	                        // explicitly reset the Telemetry Fields select to make
	                        // sure we end up back on the default value. If we don't
	                        // it will reset to the first non-disabled value in the
	                        // select box.
	                        form.elements['fields'].selectedIndex = 0;
	                    }

	                    if (!('time-field' in vnode.attrs)) {
	                        form.elements['timeField'].selectedIndex = -1;
	                    }

	                    _this2._fields = [];
	                }).catch(function (e) {
	                    _this2._querying = false;
	                });

	                return false;
	            }
	        }, [dataDir, packets, timeField, fields, selectedFields, startTime, endTime, queryBtn]);

	        return m('bliss-telemetryquery', vnode.attrs, form);
	    },
	    _validate_form: function _validate_form(form) {
	        this._validation_errors = {};

	        if (form.elements['dataDir'].selectedIndex === 0) {
	            this._validation_errors['dataDir'] = true;
	        }
	        if (form.elements['packet'].selectedIndex === 0) {
	            this._validation_errors['packet'] = true;
	        }
	        if (form.elements['timeField'].selectedIndex === -1 || form.elements['timeField'].selectedIndex === 0) {
	            this._validation_errors['timeField'] = true;
	        }
	        if (this._fields.length === 0) {
	            this._validation_errors['fields'] = true;
	        }

	        var datetimeRegex = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\dZ/;
	        if (!datetimeRegex.test(form.elements['startTime'].value)) {
	            this._validation_errors['startTime'] = true;
	        }
	        if (!datetimeRegex.test(form.elements['endTime'].value)) {
	            this._validation_errors['endTime'] = true;
	        }

	        return Object.keys(this._validation_errors).length === 0;
	    }
	};

	exports.default = { TelemetryQuery: TelemetryQuery };
	exports.TelemetryQuery = TelemetryQuery;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MnemonicSearch = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _map = __webpack_require__(146);

	var _map2 = _interopRequireDefault(_map);

	var _defaults = __webpack_require__(220);

	var _defaults2 = _interopRequireDefault(_defaults);

	var _format = __webpack_require__(11);

	var format = _interopRequireWildcard(_format);

	var _Field = __webpack_require__(158);

	var _Field2 = _interopRequireDefault(_Field);

	var _Clock = __webpack_require__(14);

	var _Clock2 = _interopRequireDefault(_Clock);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	var typeahead = __webpack_require__(156);
	var Bloodhound = __webpack_require__(157);

	var MnemonicSearch = {
	    _packet: null,
	    _selection: null,

	    oninit: function oninit(vnode) {
	        this._packet = vnode.attrs.packet;
	        bliss.tlm.search = { dict: {} };
	    },
	    oncreate: function oncreate(vnode) {
	        var _this = this;

	        bliss.tlm.promise.then(function (dict) {
	            (0, _defaults2.default)(vnode.attrs, { 'result-count': 20 });

	            var tokenize = function tokenize(str) {
	                return str ? str.split('_') : [];
	            };

	            bliss.tlm.search.dict = new Bloodhound({
	                datumTokenizer: tokenize,
	                queryTokenizer: tokenize,
	                local: (0, _map2.default)(dict[_this._packet].fields, function (value, key) {
	                    return value.name;
	                }).sort()
	            });

	            $('input[name="tlmsearch"]', vnode.dom).typeahead({
	                highlight: true
	            }, {
	                name: 'tlm-mnemonics',
	                limit: vnode.attrs['result-count'],
	                source: bliss.tlm.search.dict
	            }).bind('typeahead:select', function (ev, suggestion) {
	                _this._selection = suggestion;
	                ev.target.blur();

	                // This is necessary to reset the typeahead query suggestions.
	                // If we don't do this the user will see a list containing
	                // their previous choice when they next focus the text field
	                // even though they haven't entered anything.
	                $('input[name="tlmsearch"]', vnode.dom).typeahead('val', '');

	                bliss.events.emit('modal:show', _this._generateModalContent());
	                m.redraw();
	            }).bind('typeahead:autocomplete', function (ev, suggestion) {
	                _this._selection = suggestion;
	                ev.target.blur();
	                $('input[name="tlmsearch"]', vnode.dom).typeahead('val', '');

	                bliss.events.emit('modal:show', _this._generateModalContent());
	                m.redraw();
	            }).bind('typeahead:close', function (ev, suggestion) {
	                ev.target.blur();
	                $('input[name="tlmsearch"]', vnode.dom).typeahead('val', '');
	                m.redraw();
	            });
	        });
	    },
	    _generateModalContent: function _generateModalContent() {
	        var _this2 = this;

	        // TODO: Need to update handling of Fields here and fix the issue of
	        // items not updating as expected. As a stop gap we should be displaying
	        // Field values by pulling values out of a packet so we can add logging
	        // functionality in a follow up ticket.
	        //
	        // TODO: Figure out how we're going to pull a time value of the Clock
	        // object to use a timestamp when logging a value so there's consistency
	        // between the displayed value snapshot and what is logged.

	        var val = 'N/A';
	        var raw = 'N/A';
	        var curTime = format.datetime(new Date());
	        var curPacket = bliss.packets[this._packet] ? bliss.packets[this._packet].get(0) : null;

	        if (curPacket !== null) {
	            val = curPacket.__get__(this._selection);
	            raw = curPacket.__get__(this._selection, true);
	        }

	        var data = {};
	        var tlm = bliss.tlm.dict[this._packet]._fields;

	        if (this._selection in tlm) {
	            var tlm_point = tlm[this._selection];
	            data.header = tlm_point['name'];
	            data.body = [];

	            var desc = tlm_point.desc ? tlm_point.desc : "None";
	            data.body.push(m('div', [m('b', 'Description: '), desc, m('br')]));

	            var type = tlm_point.type ? tlm_point.type._name : "Unknown";
	            data.body.push(m('div', [m('b', 'Data Type: '), type, m('br')]));

	            var bytes = _typeof(tlm_point.bytes) == "object" ? tlm_point.bytes[0] + " - " + tlm_point.bytes[1] : tlm_point.bytes;
	            data.body.push(m('div', [m('b', 'Byte(s) in Packet: '), bytes, m('br')]));

	            var mask = tlm_point.mask ? tlm_point.mask : 'None';
	            data.body.push(m('div', [m('b', 'Bit Mask: '), mask, m('br')]));

	            if (tlm_point.enum) {
	                data.body.push(m('div', [m('b', 'Enumerated Values: '), (0, _map2.default)(tlm_point.enum, function (k, v) {
	                    return m('div', [m('b', '\u2003' + v + ': '), m('span', k), m('br')]);
	                })]));
	            }

	            if (tlm_point.dntoeu) {
	                data.body.push(m('div', [m('b', 'DN-to-EU: '), (0, _map2.default)(tlm_point.dntoeu, function (k, v) {
	                    return m('div', [m('b', '\u2003' + v + ': '), m('span', k), m('br')]);
	                })]));
	            }

	            if (tlm_point.aliases) {
	                data.body.push(m('div', [m('b', 'Aliases: '), (0, _map2.default)(tlm_point.aliases, function (k, v) {
	                    return m('div', [m('b', '\u2003' + v + ': '), m('span', k), m('br')]);
	                })]));
	            }

	            data.body.push(m('hr'));
	            var logTlmBtnAttrs = {
	                class: 'btn glyphicon glyphicon glyphicon-save pull-right',
	                onclick: function onclick() {
	                    var msg = 'Telemetry field: ' + _this2._selection + ' -- value: ' + val + ' -- raw: ' + raw + ' -- time: ' + curTime;
	                    m.request({
	                        method: 'POST',
	                        url: '/messages',
	                        data: {
	                            severity: 'notice',
	                            message: msg
	                        }
	                    });
	                }
	            };
	            if (curPacket === null) {
	                logTlmBtnAttrs['disabled'] = 'disabled';
	            }

	            var logTlmBtn = m('button', logTlmBtnAttrs);

	            data.body.push(m('div', [m('div', [m('b', 'Value Snapshot:'), logTlmBtn]), m('table', { class: 'table table-condensed' }, [m('tr', [m('td', m('b', '\u2003Time: ')), m('td', curTime)]), m('tr', [m('td', m('b', '\u2003Value: ')), m('td', val)]), m('tr', [m('td', m('b', '\u2003Raw Value: ')), m('td', raw)])])]));

	            data.body = m('bliss-mnemonicsearch-modalbody', data.body);
	        }
	        return data;
	    },
	    view: function view(vnode) {
	        var _this3 = this;

	        var form = m('div', { class: 'search' }, [m('input', {
	            class: 'form-control typeahead',
	            type: 'text',
	            name: 'tlmsearch',
	            onfocus: function onfocus(e) {
	                _this3._selection = null;
	            },
	            onblur: function onblur(e) {
	                e.target.value = '';
	            }
	        }), m('span', { class: 'search_icon glyphicon glyphicon-search' })]);

	        var componentClasses = '';
	        (0, _defaults2.default)(vnode.attrs, {
	            'display-border': false,
	            'invert-colors': true
	        });

	        if (!vnode.attrs['display-border']) {
	            componentClasses += 'no-borders ';
	        }

	        if (vnode.attrs['invert-colors']) {
	            componentClasses += 'inverse-colors ';
	        }

	        return m('bliss-mnemonicsearch', { class: componentClasses }, form);
	    }
	};

	exports.default = { MnemonicSearch: MnemonicSearch };
	exports.MnemonicSearch = MnemonicSearch;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(212),
	    assignInWith = __webpack_require__(221),
	    baseRest = __webpack_require__(210),
	    customDefaultsAssignIn = __webpack_require__(222);

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(args) {
	  args.push(undefined, customDefaultsAssignIn);
	  return apply(assignInWith, undefined, args);
	});

	module.exports = defaults;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(204),
	    createAssigner = __webpack_require__(209),
	    keysIn = __webpack_require__(206);

	/**
	 * This method is like `_.assignIn` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extendWith
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignInWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	  copyObject(source, keysIn(source), object, customizer);
	});

	module.exports = assignInWith;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(66);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	 * of source objects to the destination object for all destination properties
	 * that resolve to `undefined`.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to assign.
	 * @param {Object} object The parent object of `objValue`.
	 * @returns {*} Returns the value to assign.
	 */
	function customDefaultsAssignIn(objValue, srcValue, key, object) {
	  if (objValue === undefined ||
	      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	    return srcValue;
	  }
	  return objValue;
	}

	module.exports = customDefaultsAssignIn;


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Sequence = undefined;

	var _map = __webpack_require__(146);

	var _map2 = _interopRequireDefault(_map);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var Sequence = {
	    _disableControls: false,
	    _filter_val: '',
	    sequences: [],

	    refreshSequenceList: function refreshSequenceList() {
	        var _this = this;

	        m.request(this._action).then(function (data) {
	            data = data.sort(function (a, b) {
	                if (a.indexOf('/') !== -1 && b.indexOf('/') !== -1) {
	                    return a < b ? -1 : 1;
	                } else if (a.indexOf('/') !== -1) {
	                    return -1;
	                } else if (b.indexOf('/') !== -1) {
	                    return 1;
	                }
	            });
	            _this.sequences = (0, _map2.default)(data, function (value, index) {
	                return m('option', { value: value, key: index }, value);
	            });
	        });
	    },
	    handleFormSubmit: function handleFormSubmit(event) {
	        event.preventDefault();
	        var data = new FormData();
	        data.append('seqfile', event.currentTarget.querySelector('select').value);

	        if (data.get('seqfile') === '') {
	            return false;
	        }

	        this._disableControls = true;
	        m.request({ method: 'POST', url: this._action, data: data });
	        return false;
	    },
	    oninit: function oninit(vnode) {
	        var _this2 = this;

	        this._action = vnode.attrs.action || '/seq';
	        this.refreshSequenceList();

	        bliss.events.on('seq:exec', function () {
	            _this2._disableControls = true;
	            m.redraw();
	        });

	        bliss.events.on('seq:done', function () {
	            _this2._disableControls = false;
	            m.redraw();
	        });

	        bliss.events.on('seq:err', function () {
	            _this2._disableControls = false;
	            m.redraw();
	        });
	    },
	    view: function view(vnode) {
	        var _this3 = this;

	        var submitBtnAttrs = {
	            type: 'submit',
	            class: 'btn btn-success pull-right'
	        };

	        var abortBtnAttrs = {
	            type: 'button',
	            class: 'btn btn-danger pull-right',
	            onclick: function onclick(e) {
	                e.preventDefault();
	                m.request({
	                    method: 'POST',
	                    url: '/seq/abort'
	                });
	            }
	        };

	        if (this._disableControls) {
	            submitBtnAttrs['style'] = 'display:none;';
	        } else {
	            abortBtnAttrs['style'] = 'display:none;';
	        }

	        var seqDisplayList = this.sequences;
	        if (this._filter_val !== '') {
	            seqDisplayList = this.sequences.filter(function (e) {
	                return e.attrs.value.indexOf(_this3._filter_val) !== -1;
	            });
	        }

	        var sequenceSelectGroup = m('div', {
	            class: 'form-group'
	        }, [m('label', 'Send Sequence'), m('div', { class: 'controls' }, m('button', {
	            type: 'button',
	            class: 'btn btn-default refresh',
	            onclick: function onclick() {
	                _this3.refreshSequenceList();
	            }
	        }, [m('span', { class: 'glyphicon glyphicon-refresh' }), 'Refresh'])), m('select', {
	            class: 'form-control',
	            multiple: 'true',
	            size: 10
	        }, seqDisplayList)]);

	        var filterInputGroup = m('div', { class: 'form-group' }, [m('label', 'Filter Sequences'), m('div', {
	            class: 'input-group'
	        }, [m('input', {
	            class: 'form-control',
	            placeholder: 'Filter list ...',
	            name: 'sequence-filter',
	            oninput: function oninput(e) {
	                _this3._filter_val = e.currentTarget.value;
	            }
	        }), m('div', { class: 'input-group-btn' }, m('button', {
	            class: 'btn btn-default',
	            type: 'button',
	            onmousedown: function onmousedown(e) {
	                var cur = e.currentTarget;
	                while (cur.parentElement && !cur.elements) {
	                    cur = cur.parentElement;
	                }
	                cur.elements['sequence-filter'].value = '';
	                _this3._filter_val = '';
	            }
	        }, m('span', { class: 'glyphicon glyphicon-remove-circle' })))])]);

	        return m('bliss-sequence', m('form', {
	            class: 'form-horizontal',
	            role: 'form',
	            method: 'POST',
	            onkeypress: function onkeypress(e) {
	                return e.keyCode !== 13;
	            },
	            onsubmit: function onsubmit(e) {
	                _this3.handleFormSubmit(e);
	            }
	        }, [filterInputGroup, sequenceSelectGroup, m('div', { class: 'form-group' }, m('button', abortBtnAttrs, 'Abort'), m('button', submitBtnAttrs, 'Send'))]));
	    }
	}; /*
	    * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	    * Bespoke Link to Instruments and Small Satellites (BLISS)
	    *
	    * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	    * RESERVED. United States Government Sponsorship acknowledged. Any
	    * commercial use must be negotiated with the Office of Technology Transfer
	    * at the California Institute of Technology.
	    *
	    * This software may be subject to U.S. export control laws. By accepting
	    * this software, the user agrees to comply with all applicable U.S. export
	    * laws and regulations. User has the responsibility to obtain export licenses,
	    * or other export authority as may be required before exporting such
	    * information to foreign countries or providing access to foreign persons.
	    */

	exports.default = { Sequence: Sequence };
	exports.Sequence = Sequence;

/***/ }),
/* 224 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	/**
	 * Displays internal state information via styled Glyphicon and tracks
	 * transitions through its' states via monitoring of the system event queue.
	 *
	 * Allows for configuration of 4 state event handlers
	 * ('on', 'off', 'pending', and 'error') via attributes on the bliss-led tag.
	 *
	 * Example:
	 *   <bliss-led on="seq:exec" off="seq:done" error="seq:err"></bliss-led>
	 *  
	 *  You can specify multiple triggers for a single state by separating the
	 *  event names with a ','
	 *
	 * Example:
	 *   <bliss-led on="seq:exec,seq:sent" off="seq:done"></bliss-led>
	 *
	 *  If you want to start the LED in a state besides 'off' set it via
	 *  the 'default' attribute
	 *
	 * Example:
	 *   <bliss-led on="seq:exec,seq:sent" default="pending"></bliss-led>
	 */
	var LED = {
	    _states: ['on', 'off', 'pending', 'error'],
	    _state: 'off',

	    oninit: function oninit(vnode) {
	        var _this = this;

	        // Set event listeners for each of the valid LED states
	        this._states.forEach(function (s) {
	            if (s in vnode.attrs) {
	                vnode.attrs[s].split(',').forEach(function (e) {
	                    bliss.events.on(e, function () {
	                        _this._state = s;
	                    });
	                });
	            }
	        });

	        this._state = vnode.attrs.default || 'off';
	    },
	    view: function view(vnode) {
	        var classes = 'glyphicon glyphicon-dot bliss-led-' + this._state;
	        return m('span', { class: classes });
	    }
	};

	/**
	 * An expansion of the base LED object for controlling the state of
	 * simulators and displaying state information with regards to their
	 * operation.
	 *
	 * Allows for configuration of 4 state event handlers for displaying information
	 * about the state of the simulator. You can configure these states
	 * ('on', 'off', 'pending', and 'error') via attributes on the tag.
	 *
	 * Example:
	 *   <bliss-simmonitor on='sim:iss:on'
	 *                     off='sim:iss:off'
	 *                     pending='sim:iss:pending'
	 *                     error='sim:iss:error'
	 *                     default='off' action='/sim/iss/'></bliss-simmonitor>
	 *  
	 *  You can specify multiple triggers for a single state by separating the
	 *  event names with a ','.
	 *
	 *  The 'default' attribute specifies the state of the monitored sim on bootup.
	 *  If you start your sim in a particular state you should update 'default'
	 *  accordingly so the component can properly track the sim. The 'off' state
	 *  is the default.
	 *
	 *  The 'action' attribute is the URL for POSTs to be made for starting and
	 *  stopping the monitored Sim. SimStatus expects the following interface
	 *  with the sim:
	 *
	 *      POST 'action' + '/start' to start the sim.
	 *      POST 'action' + '/stop' to stop the sim.
	 *
	 */
	var SimStatus = Object.assign(Object.create(LED), {
	    _hoverState: null,
	    _simRunning: false,

	    oninit: function oninit(vnode) {
	        var _this2 = this;

	        LED.oninit.call(this, vnode);
	        this.action = vnode.attrs.action;
	        bliss.events.on(vnode.attrs.on, function () {
	            _this2._simRunning = true;
	        });
	        bliss.events.on(vnode.attrs.off, function () {
	            _this2._simRunning = false;
	        });

	        if (this._state === 'on') {
	            this._simRunning = true;
	        }
	    },
	    view: function view(vnode) {
	        var _this3 = this;

	        var classes = 'sim-monitor glyphicon';

	        if (this._hoverState === 'mouseover') {
	            if (this._simRunning) {
	                classes += ' glyphicon-stop bliss-led-stop';
	            } else {
	                classes += ' glyphicon-play bliss-led-start';
	            }
	        } else {
	            classes += ' glyphicon-dot bliss-led-' + this._state;
	        }

	        return m('span', {
	            class: classes,
	            onclick: SimStatus.toggleSimState.bind(this),
	            onmouseover: function onmouseover(event) {
	                _this3._hoverState = event.type;
	                m.redraw();
	            },
	            onmouseout: function onmouseout(event) {
	                _this3._hoverState = event.type;
	                m.redraw();
	            }
	        });
	    },
	    toggleSimState: function toggleSimState() {
	        var url = this.action;
	        if (this._simRunning) {
	            url += '/stop';
	        } else {
	            url += '/start';
	        }

	        m.request({ url: url, action: 'POST', data: {} });
	    }
	});

	var Prompt = {
	    _display_prompt: false,
	    _type: null,
	    _options: null,

	    oncreate: function oncreate(vnode) {
	        var _this4 = this;

	        bliss.events.on('prompt:init', function (data) {
	            _this4._display_prompt = true;
	            _this4._type = data['type'];
	            _this4._options = data['options'];
	            m.redraw();
	        });

	        bliss.events.on('prompt:timeout', function () {
	            _this4._reset_prompt();
	            m.redraw();
	        });

	        bliss.events.on('prompt:done', function () {
	            _this4._reset_prompt();
	            m.redraw();
	        });
	    },
	    _reset_prompt: function _reset_prompt() {
	        this._display_prompt = false;
	        this._type = null;
	        this._options = null;
	    },
	    view: function view(vnode) {
	        var _this5 = this;

	        var title = m('h4', { class: 'modal-title' }, 'Title');
	        var body = m('div', 'Prompt');
	        var footer = m('div', 'Footer');

	        if (this._type === 'confirm') {
	            title = m('h4', { class: 'modal-title' }, 'Please Confirm');
	            body = m('div', this._options['msg']);
	            footer = m('div', [m('div', {
	                type: 'button',
	                class: 'btn btn-success',
	                'data-dismiss': 'modal',
	                onclick: function onclick() {
	                    m.request({
	                        'method': 'POST',
	                        'url': '/prompt/response',
	                        'data': { response: 'confirm' }
	                    }).then(function () {
	                        _this5._reset_prompt();
	                    });
	                }
	            }, 'Confirm'), m('div', {
	                type: 'button',
	                class: 'btn btn-danger',
	                'data-dismiss': 'modal',
	                onclick: function onclick() {
	                    m.request({
	                        'method': 'POST',
	                        'url': '/prompt/response',
	                        'data': { response: 'deny' }
	                    }).then(function () {
	                        _this5._reset_prompt();
	                    });
	                }
	            }, 'Deny')]);
	        }

	        var modal = m('div', { class: 'modal show', tabindex: '-1', role: 'dialog' }, m('div', { class: 'modal-dialog', 'role': 'document' }, m('div', { class: 'modal-content' }, [m('div', { class: 'modal-header' }, [title]), m('div', { class: 'modal-body' }, [body]), m('div', { class: 'modal-footer' }, [footer])])));

	        if (this._display_prompt) {
	            return m('bliss-prompt', modal);
	        } else {
	            return m('bliss-prompt');
	        }
	    }
	};

	exports.default = { LED: LED, SimStatus: SimStatus, Prompt: Prompt };
	exports.LED = LED;
	exports.SimStatus = SimStatus;
	exports.Prompt = Prompt;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TabSet = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
	                                                                                                                                                                                                                                                                               * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	                                                                                                                                                                                                                                                                               * Bespoke Link to Instruments and Small Satellites (BLISS)
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	                                                                                                                                                                                                                                                                               * RESERVED. United States Government Sponsorship acknowledged. Any
	                                                                                                                                                                                                                                                                               * commercial use must be negotiated with the Office of Technology Transfer
	                                                                                                                                                                                                                                                                               * at the California Institute of Technology.
	                                                                                                                                                                                                                                                                               *
	                                                                                                                                                                                                                                                                               * This software may be subject to U.S. export control laws. By accepting
	                                                                                                                                                                                                                                                                               * this software, the user agrees to comply with all applicable U.S. export
	                                                                                                                                                                                                                                                                               * laws and regulations. User has the responsibility to obtain export licenses,
	                                                                                                                                                                                                                                                                               * or other export authority as may be required before exporting such
	                                                                                                                                                                                                                                                                               * information to foreign countries or providing access to foreign persons.
	                                                                                                                                                                                                                                                                               */

	var _mithril = __webpack_require__(1);

	var _mithril2 = _interopRequireDefault(_mithril);

	var _util = __webpack_require__(226);

	var util = _interopRequireWildcard(_util);

	var _range = __webpack_require__(227);

	var _range2 = _interopRequireDefault(_range);

	var _times = __webpack_require__(232);

	var _times2 = _interopRequireDefault(_times);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * DragDrop
	 *
	 * DragDrop manages the drag-and-drop state and behavior for a TabSet,
	 * keeping track of the indicies of the `from` tab (i.e. the tab being
	 * dragged) and the current tab which is being dragged `over`.
	 */
	var DragDrop = {
	    _from: -1,
	    _over: -1,

	    /**
	     * Handle an HTML5 drop event for the tab at the given `index`.
	     *
	     * Calls `callback(from, to)`, where `from` is the index of the
	     * tab that was dragged and `to` is the index of the drop target
	     * tab.  In practical terms, callback is `TabSet.move(from, to)`.
	     */
	    drop: function drop(event, index, callback) {
	        if (this._from !== -1) {
	            event.preventDefault();
	            callback(this._from, index);
	        }
	    },


	    /**
	     * Handle the HTML5 `dragend` event for the tab at the given index.
	     */
	    end: function end(event, index) {
	        this._from = -1;
	        this._over = -1;
	    },


	    /**
	     * @returns true if the tab at the given index is being dragged
	     * over, false otherwise.
	     */
	    isOver: function isOver(index) {
	        return index === this._over;
	    },


	    /**
	     * Handle the HTML5 `dragover` event for the tab at the given index.
	     */
	    over: function over(event, index) {
	        event.preventDefault();
	        this._over = index;
	    },


	    /**
	     * Return CSS classes for the tab at the given index that is being
	     * dragged over.
	     *
	     * @pre  this.isOver(index) === true
	     */
	    overClass: function overClass(index) {
	        return 'drag-over-' + (this._from > index ? 'before' : 'after');
	    },


	    /**
	     * Handle the HTML5 `dragstart` event for the tab at the given index.
	     */
	    start: function start(event, index) {
	        event.dataTransfer.effectAllowed = 'move';
	        this._from = index;
	    }
	};

	/**
	 * BLISS TabSet
	 *
	 * BLISS TabSet is a Mithril UI component for a `<bliss-tabset>`,
	 * which manages a set of children `<bliss-tab>`s.  Tabs have a title
	 * attribute and their own child content.  When a TabSet is rendered
	 * to the DOM via its `view()` method, it:
	 *
	 *     1.  Uses `<bliss-tabset>` and `<bliss-tab>` HTML5 custom tags
	 *         for targeted CSS styling and customization, and
	 *
	 *     2.  Uses Bootstrap HTML structure and CSS classes
	 *
	 * A BLISS TabSet is signficantly more succinct than Bootstrap tabs.
	 * For example, compare creating a BLISS TabSet directly in HTML:
	 *
	 *     <bliss-tabset class="nav-tabs">
	 *         <bliss-tab title="Foo"> ... </bliss-tab>
	 *         <bliss-tab title="Bar"> ... </bliss-tab>
	 *         <bliss-tab title="Baz"> ... </bliss-tab>
	 *     </bliss-tab>
	 *
	 * To the corresponding Bootstrap HTML and CSS:
	 *
	 *     <ul class="nav nav-tabs">
	 *         <li> <a href="#">Foo</a> </li>
	 *         <li> <a href="#">Bar</a> </li>
	 *         <li> <a href="#">Baz</a> </li>
	 *     </ul>
	 *
	 *     <div class="tab-content">
	 *         <div class="tab-pane active"> ... </div>
	 *     </div>
	 *     <!-- Repeat for the contents of all three tabs -->
	 *
	 * Tabs may also be rendered as Bootstrap pills, stacked, justified,
	 * etc. by adding the [appropriate CSS
	 * classes](http://getbootstrap.com/components/#nav) to a
	 * <bliss-tabset>.
	 *
	 * Tabs may be reordered programmatically via `TabSet.move(from, to)`
	 * or by interactively via drag-and-drop.
	 */
	var TabSet = {
	    _active: 0, // The index of the active tab
	    _drag: null, // A DragDrop object, created in oninit()
	    _pos: [], // Maps tab position to initial DOM order
	    _uid: [], // Unique numeric ID for each tab (for Mithril keys)


	    /**
	     * Mithril `view()`-helper method
	     *
	     * Renders the `<a>` element of a Bootstrap tab.
	     *
	     * NOTE: The anchor element (`<a>`) of a tab is dragged, but it is
	     * dragged `over` and `drop`ped on parent `<li>` elements.  This
	     * is due primarily to the way Bootstrap tabs are styled and
	     * needing to accommodate CSS animations to slide tabs left or
	     * right to indicate where the dropped tab will be positioned.
	     */
	    anchor: function anchor(vnode, index) {
	        var _this = this;

	        var attrs = {
	            href: '#',
	            class: '',
	            draggable: this.isActive(index),
	            ondragstart: function ondragstart(e) {
	                return _this._drag.start(e, index);
	            },
	            ondragend: function ondragend(e) {
	                return _this._drag.end(e, index);
	            }
	        };

	        var tabName = vnode.attrs.title;
	        if (this.tabs && Object.keys(this.tabs[tabName]['___limit_error']).length > 0) {
	            attrs['class'] += ' tab_title--out-of-limit--error';
	        } else if (this.tabs && Object.keys(this.tabs[tabName]['___limit_warning']).length > 0) {
	            attrs['class'] += ' tab_title--out-of-limit--warning';
	        }

	        return (0, _mithril2.default)('a', attrs, vnode.attrs.title);
	    },


	    /**
	     * Mithril `view()`-helper method
	     *
	     * Renders the content of the given tab using Bootstrap styling.
	     *
	     * NOTE: The passed-in `index` is is used to determine if the tab
	     * is the active and to lookup the Mithril key for the element.
	     */
	    content: function content(vnode, index) {
	        var attrs = { key: this._uid[index] };
	        var classes = this.isActive(index) ? '.tab-pane.active' : '.tab-pane';

	        return (0, _mithril2.default)(classes, attrs, vnode.children || vnode.text);
	    },


	    /**
	     * @returns an array of only those Mithril `vnodes` that are
	     * `<bliss-tab>`s.
	     *
	     * This method is necessary because we cannot cache only child
	     * `<bliss-tab>` vnodes outside of a `view()` and every time the
	     * `view(vnodes)` render method is called, the passed-in `vnodes`
	     * will contain every child of a `<bliss-tabset>` (i.e. whitespace
	     * text fragments *and* `<bliss-tab>`s) in the original DOM
	     * (i.e. the HTML5 written by a user).
	     */
	    filterTabs: function filterTabs(vnodes) {
	        return vnodes.filter(function (c) {
	            return c.tag === 'bliss-tab';
	        });
	    },


	    /**
	     * @returns true if the tab at the given `index` is active, false
	     * otherwise.
	     */
	    isActive: function isActive(index) {
	        return index === this._active;
	    },


	    /**
	     * Moves the tab at index `from` to index `to`.
	     */
	    move: function move(from, to) {
	        var _this2 = this;

	        if (from === to) return;

	        var ntabs = this._pos.length;
	        var active = (0, _times2.default)(ntabs, function (index) {
	            return index === _this2._active;
	        });

	        util.move(this._pos, from, to);
	        util.move(this._uid, from, to);
	        util.move(active, from, to);

	        this._active = active.findIndex(function (elem) {
	            return elem;
	        });
	    },


	    /**
	     * Mithril lifecycle method
	     *
	     * Initializes this TabSet.
	     */
	    oninit: function oninit(vnode) {
	        var tabs = this.filterTabs(vnode.children);
	        this._pos = (0, _range2.default)(tabs.length);
	        this._uid = (0, _range2.default)(tabs.length);
	        this._drag = Object.create(DragDrop);
	    },
	    filterFields: function filterFields(children) {
	        var fields = [];

	        if (!children) {
	            return fields;
	        }

	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	            for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                var e = _step.value;

	                if (e['instance'] && e['instance']['tag'] && e['instance']['tag'] === 'bliss-field') {
	                    fields.push(e['attrs']['packet'] + '_' + e['attrs']['name']);
	                } else if (e.children && _typeof(e.children) === 'object' && e.children.length > 0) {
	                    fields = fields.concat(this.filterFields(e.children));
	                }
	            }
	        } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                }
	            } finally {
	                if (_didIteratorError) {
	                    throw _iteratorError;
	                }
	            }
	        }

	        return fields;
	    },
	    oncreate: function oncreate(vnode) {
	        var _this3 = this;

	        this.tabs = {};
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	            for (var _iterator2 = this.filterTabs(vnode.children)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                var t = _step2.value;


	                var tabName = t['attrs']['title'];
	                this.tabs[tabName] = {
	                    '___limit_warning': {},
	                    '___limit_error': {}
	                };

	                var _iteratorNormalCompletion3 = true;
	                var _didIteratorError3 = false;
	                var _iteratorError3 = undefined;

	                try {
	                    for (var _iterator3 = this.filterFields(t.children)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                        var name = _step3.value;

	                        this.tabs[tabName][name] = null;
	                    }
	                } catch (err) {
	                    _didIteratorError3 = true;
	                    _iteratorError3 = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                            _iterator3.return();
	                        }
	                    } finally {
	                        if (_didIteratorError3) {
	                            throw _iteratorError3;
	                        }
	                    }
	                }
	            }
	        } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                    _iterator2.return();
	                }
	            } finally {
	                if (_didIteratorError2) {
	                    throw _iteratorError2;
	                }
	            }
	        }

	        bliss.events.on('field:limitOut', function (f) {
	            var field = f['field'];
	            var type = '___limit_' + f['type'];
	            var other_type = '___limit_' + (f['type'] === 'warning' ? 'error' : 'warning');
	            for (var t in _this3.tabs) {
	                if (field in _this3.tabs[t]) {
	                    _this3.tabs[t][type][field] = null;
	                    delete _this3.tabs[t][other_type][field];
	                }
	            }
	        });

	        bliss.events.on('field:limitIn', function (f) {
	            for (var t in _this3.tabs) {
	                if (f in _this3.tabs[t]) {
	                    delete _this3.tabs[t]['___limit_warning'][f];
	                    delete _this3.tabs[t]['___limit_error'][f];
	                }
	            }
	        });
	    },


	    /**
	     * @returns an array of tabs, reordered according to the positions
	     * in `this._pos`.  For example, the following `pos[]` array would
	     * reverse the order of four tabs:
	     *
	     *   pos = [ 3, 2, 1, 0 ]
	     *
	     * By returning:
	     *
	     *     [ tabs[3], tabs[2], tabs[1], tabs[0] ]
	     *
	     * This method is necessary because we cannot cache child
	     * `<bliss-tab>` vnodes outside of a `view()` and every time the
	     * `view(vnodes)` render method is called, the order of
	     * `<bliss-tab>`s will be the same as the original DOM (i.e. the
	     * HTML5 written by a user).
	     */
	    reorder: function reorder(tabs) {
	        return this._pos.map(function (index) {
	            return tabs[index];
	        });
	    },


	    /**
	     * Mithril `view()`-helper method
	     *
	     * Renders the `<li>` element of a Bootstrap tab.
	     *
	     * NOTE: The anchor element (`<a>`) of a tab is dragged, but it is
	     * dragged `over` and `drop`ped on parent `<li>` elements.  This
	     * is due primarily to the way Bootstrap tabs are styled and
	     * needing to accomodate CSS animations to slide tabs left or
	     * right to indicate where the dropped tab will be positioned.
	     */
	    tab: function tab(vnode, index) {
	        var _this4 = this;

	        var move = TabSet.move.bind(this);
	        var attrs = {
	            class: this.tabClass(index),
	            key: this._uid[index],
	            onclick: function onclick() {
	                _this4._active = index;return false;
	            },
	            ondragover: function ondragover(e) {
	                return _this4._drag.over(e, index);
	            },
	            ondrop: function ondrop(e) {
	                return _this4._drag.drop(e, index, move);
	            }
	        };

	        return (0, _mithril2.default)('li', attrs, this.anchor(vnode, index));
	    },


	    /**
	     * @returns the CSS class(es) for the tab at the given `index`.
	     */
	    tabClass: function tabClass(index) {
	        var name = '';

	        if (this.isActive(index)) {
	            name = 'active';
	        } else if (this._drag.isOver(index)) {
	            name = this._drag.overClass(index);
	        }

	        return name;
	    },


	    /**
	     * Mithril `view()` method
	     *
	     * Renders this TabSet and its constituent tabs.
	     */
	    view: function view(vnode) {
	        var tabs = this.reorder(this.filterTabs(vnode.children));

	        return (0, _mithril2.default)('bliss-tabset', [(0, _mithril2.default)('ul.nav', vnode.attrs, tabs.map(TabSet.tab.bind(this))), (0, _mithril2.default)('.tab-content', tabs.map(TabSet.content.bind(this)))]);
	    }
	};

	exports.default = TabSet;
	exports.TabSet = TabSet;

/***/ }),
/* 226 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	/**
	 * Object.assign(target, ...sources) merges sources into target.
	 *
	 * @return target
	 */
	/// TODO Figure out if we want to just use _.assign here
	var merge = Object.assign;

	/**
	 * Moves array element at index `from` to index `to`, shifting all
	 * other values up and down, as appropriate.
	 *
	 * Note, there is a proposal for this to end up in Lodash, but at the
	 * moment it hasn't been integrated.
	 *
	 * https://github.com/lodash/lodash/issues/1701
	 */
	function move(array, from, to) {
	  array.splice(to, 0, array.splice(from, 1)[0]);
	}

	exports.merge = merge;
	exports.move = move;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	var createRange = __webpack_require__(228);

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range = createRange();

	module.exports = range;


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	var baseRange = __webpack_require__(229),
	    isIterateeCall = __webpack_require__(217),
	    toFinite = __webpack_require__(230);

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	    return baseRange(start, end, step, fromRight);
	  };
	}

	module.exports = createRange;


/***/ }),
/* 229 */
/***/ (function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil,
	    nativeMax = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	module.exports = baseRange;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	var toNumber = __webpack_require__(231);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	module.exports = toFinite;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(51),
	    isSymbol = __webpack_require__(128);

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	module.exports = toNumber;


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	var baseTimes = __webpack_require__(26),
	    castFunction = __webpack_require__(53),
	    toInteger = __webpack_require__(233);

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH = 4294967295;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Invokes the iteratee `n` times, returning an array of the results of
	 * each invocation. The iteratee is invoked with one argument; (index).
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 * @example
	 *
	 * _.times(3, String);
	 * // => ['0', '1', '2']
	 *
	 *  _.times(4, _.constant(0));
	 * // => [0, 0, 0, 0]
	 */
	function times(n, iteratee) {
	  n = toInteger(n);
	  if (n < 1 || n > MAX_SAFE_INTEGER) {
	    return [];
	  }
	  var index = MAX_ARRAY_LENGTH,
	      length = nativeMin(n, MAX_ARRAY_LENGTH);

	  iteratee = castFunction(iteratee);
	  n -= MAX_ARRAY_LENGTH;

	  var result = baseTimes(length, iteratee);
	  while (++index < n) {
	    iteratee(index);
	  }
	  return result;
	}

	module.exports = times;


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	var toFinite = __webpack_require__(230);

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	module.exports = toInteger;


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Modal = undefined;

	var _defaults = __webpack_require__(220);

	var _defaults2 = _interopRequireDefault(_defaults);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	 * An event toggle-able Modal Component
	 *
	 * A customizable Modal component that is toggled and configured
	 * via events. The Modal component will smoothly handle multiple
	 * simultaneous modal requests by queueing additional 'show' calls
	 * behind the currently displayed modal.
	 *
	 * Events:
	 *   'modal:show' - Display a modal to the user. Modal configuration
	 *      should be included in the body of the event.
	 *
	 *   'modal:hide' - Stop displaying the current active modal.
	 *
	 * Modal configuration is passed via the 'modal:show' event body. The following
	 * values are valid configuration values.
	 *   header
	 *      Contains the content to be displayed as the modal's title.
	 *   body
	 *      Contains the content to display as the modal's body
	 *   footer
	 *      Contains the content to display as the modal's footer
	 *   insertHeaderCloseBtn
	 *      Toggles whether a close button should be inserted
	 *      into the modal header for the caller. Defaults to true.
	 *   insertFooterCloseBtn
	 *      Toggles whether a close button should be inserted
	 *      into the modal footer for the caller. Defaults to true.
	 *   displayBackground
	 *      Toggles whether the modal background should be inserted
	 *      when rendering the modal. Defaults to true.
	 */
	var Modal = {
	    _display_modal: false,
	    _modals: [],

	    _reset_modal: function _reset_modal() {
	        this._modals.shift();

	        if (this._modals.length === 0) {
	            this._display_modal = false;
	        }
	    },
	    oncreate: function oncreate(vnode) {
	        var _this = this;

	        bliss.events.on('modal:show', function (data) {
	            _this._display_modal = true;
	            (0, _defaults2.default)(data, {
	                displayBackground: true,
	                insertHeaderCloseBtn: true,
	                insertFooterCloseBtn: true
	            });
	            _this._modals.push(data);
	            m.redraw();
	        });

	        bliss.events.on('modal:close', function () {
	            _this._reset_modal();
	            m.redraw();
	        });
	    },
	    view: function view(vnode) {
	        var _this2 = this;

	        if (!this._display_modal) {
	            return m('bliss-modal');
	        }

	        var header = m('h4', { class: 'modal-title' });
	        var body = m('span');
	        var footer = m('span');

	        if (this._modals.length !== 0) {
	            if ('header' in this._modals[0]) {
	                header = m('h4', { class: 'modal-title' }, this._modals[0].header);
	            }

	            if (this._modals[0].insertHeaderCloseBtn) {
	                header = [m('button', {
	                    type: 'button',
	                    class: 'close',
	                    'data-dimiss': modal,
	                    onclick: function onclick() {
	                        _this2._reset_modal();
	                    }
	                }, m('span', '\xD7')), header];
	            }

	            if ('body' in this._modals[0]) {
	                body = this._modals[0].body;
	            }

	            if ('footer' in this._modals[0]) {
	                footer = this._modals[0].footer;
	            }

	            if (this._modals[0].insertFooterCloseBtn) {
	                footer = [footer, m('div', {
	                    type: 'button',
	                    class: 'btn btn-default',
	                    'data-dismiss': 'modal',
	                    onclick: function onclick() {
	                        _this2._reset_modal();
	                    }
	                }, 'Close')];
	            }
	        }

	        var modal = m('div', { class: 'modal show', tabindex: '-1', role: 'dialog' }, m('div', { class: 'modal-dialog', 'role': 'document' }, m('div', { class: 'modal-content' }, [m('div', { class: 'modal-header' }, header), m('div', { class: 'modal-body' }, body), m('div', { class: 'modal-footer' }, footer)])));

	        if (this._modals[0].displayBackground) {
	            modal = [modal, m('div', { class: 'modal-backdrop fade in' })];
	        }

	        return m('bliss-modal', modal);
	    }
	}; /*
	    * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	    * Bespoke Link to Instruments and Small Satellites (BLISS)
	    *
	    * Copyright 2017, by the California Institute of Technology. ALL RIGHTS
	    * RESERVED. United States Government Sponsorship acknowledged. Any
	    * commercial use must be negotiated with the Office of Technology Transfer
	    * at the California Institute of Technology.
	    *
	    * This software may be subject to U.S. export control laws. By accepting
	    * this software, the user agrees to comply with all applicable U.S. export
	    * laws and regulations. User has the responsibility to obtain export licenses,
	    * or other export authority as may be required before exporting such
	    * information to foreign countries or providing access to foreign persons.
	    */

	exports.default = { Modal: Modal };
	exports.Modal = Modal;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.TelemetryStream = exports.TelemetryDictionary = exports.PacketScope = exports.PacketDefinition = exports.Packet = exports.FieldDefinition = undefined;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Bespoke Link to Instruments and Small Satellites (BLISS)
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * RESERVED. United States Government Sponsorship acknowledged. Any
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * commercial use must be negotiated with the Office of Technology Transfer
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * at the California Institute of Technology.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This software may be subject to U.S. export control laws. By accepting
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * this software, the user agrees to comply with all applicable U.S. export
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * laws and regulations. User has the responsibility to obtain export licenses,
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * or other export authority as may be required before exporting such
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * information to foreign countries or providing access to foreign persons.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

	var _dtype = __webpack_require__(236);

	var dtype = _interopRequireWildcard(_dtype);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FieldDefinition = function () {
	    function FieldDefinition(args) {
	        _classCallCheck(this, FieldDefinition);

	        args = args === undefined ? {} : args;

	        this.name = args.name;
	        this.mask = args.mask;
	        this.type = dtype.get(args.type);
	        this.enum = args.enum;
	        this.shift = 0;
	        this.bytes = args.bytes;
	        this.dntoeu = args.dntoeu;
	        this.desc = args.desc;
	        this.aliases = args.aliases;

	        // Bytes can be either one integer or an array,
	        // all we need is the head
	        if (args.bytes instanceof Array) {
	            this.offset = args.bytes[0];
	        } else {
	            this.offset = args.bytes;
	        }

	        // Set the shift based on the bitmask
	        var mask = this.mask;

	        if (mask !== undefined && mask !== null) {
	            while (mask !== 0 && (mask & 1) === 0) {
	                this.shift += 1;
	                mask >>= 1;
	            }
	        }
	    }

	    _createClass(FieldDefinition, [{
	        key: 'decode',
	        value: function decode(view) {
	            var skipEnumeration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	            var value = null;

	            if (this.type) {
	                value = this.type.decode(view, this.offset);

	                if (this.mask !== undefined && this.mask !== null) {
	                    value &= this.mask;
	                }

	                if (this.shift > 0) {
	                    value >>= this.shift;
	                }

	                // If enumeration exists, display that value
	                if (!skipEnumeration && this.enum !== undefined) {
	                    value = this.enum[value];
	                }
	            }

	            return value;
	        }
	    }]);

	    return FieldDefinition;
	}();

	var Packet = function () {
	    function Packet(defn, data) {
	        var raw = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	        _classCallCheck(this, Packet);

	        this._defn = defn;
	        this._data = data;
	        this._raw = raw;

	        if (Packet.prototype.__init__ === undefined) {
	            var _loop = function _loop(name) {
	                //const getter = () => this.__get__(name)
	                Object.defineProperty(Packet.prototype, name, {
	                    get: function get() {
	                        return this.__get__(name);
	                    }
	                });
	            };

	            for (var name in this._defn.fields) {
	                _loop(name);
	            }
	            Packet.prototype.__init__ = true;
	        }
	    }

	    _createClass(Packet, [{
	        key: '__get__',
	        value: function __get__(name) {
	            var raw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	            var value = undefined;

	            if (this._data instanceof DataView) {
	                var defn = this._defn.fields[name];

	                if (defn) {
	                    if (raw || this._raw || !defn.dntoeu) {
	                        value = defn.decode(this._data, raw);
	                    } else if (defn.dntoeu && defn.dntoeu.equation) {
	                        value = this._defn.scope.eval(this, defn.dntoeu.equation);
	                    }
	                }
	            }

	            return value;
	        }
	    }, {
	        key: '__clone__',
	        value: function __clone__(data) {
	            var raw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	            return new Packet(this._defn, data, raw);
	        }
	    }]);

	    return Packet;
	}();

	var PacketDefinition = function () {
	    function PacketDefinition(obj) {
	        _classCallCheck(this, PacketDefinition);

	        this._constants = obj.constants;
	        this._desc = obj.desc;
	        this._fields = {};
	        this._functions = obj.functions;
	        this._history = obj.history;
	        this._name = obj.name;
	        this._scope = new PacketScope(this);
	        this._uid = obj.uid;

	        for (var key in obj.fields) {
	            this._fields[key] = new FieldDefinition(obj.fields[key]);
	        }
	    }

	    _createClass(PacketDefinition, [{
	        key: 'constants',
	        get: function get() {
	            return this._constants;
	        }
	    }, {
	        key: 'fields',
	        get: function get() {
	            return this._fields;
	        }
	    }, {
	        key: 'functions',
	        get: function get() {
	            return this._functions;
	        }
	    }, {
	        key: 'name',
	        get: function get() {
	            return this._name;
	        }
	    }, {
	        key: 'scope',
	        get: function get() {
	            return this._scope;
	        }
	    }, {
	        key: 'uid',
	        get: function get() {
	            return this._uid;
	        }
	    }], [{
	        key: 'parse',
	        value: function parse(obj) {
	            if (typeof obj === 'string') {
	                obj = JSON.parse(obj);
	            }

	            return new PacketDefinition(obj);
	        }
	    }]);

	    return PacketDefinition;
	}();

	var PacketScope = function () {
	    /**
	     * Creates a new PacketScope based on the given PacketDefinition,
	     * which defines constants and functions.
	     *
	     * To evaluate an expression within the PacketScope, call
	     * PacketScope.eval(packet, expr).
	     */
	    function PacketScope(defn) {
	        _classCallCheck(this, PacketScope);

	        // The underlying scope object must be created using a
	        // Javascript Function object (with a string body), so that
	        // the scope it creates does not have 'use strict' semantics.
	        // (Since the code in this module is ES6, 'use strict'
	        // semantics are in effect by definition.)
	        //
	        // A function scope without 'use strict' allows the
	        // eval()uation of the string returned by this.toCode() to
	        // create new variables ("constants") and function definitions
	        // within the function scope.
	        //
	        // Thus, this._scope will contain definitions for each
	        // constant and function defined in the given packet
	        // definition.  New expressions will be evaluated in this
	        // scope when calling PacketScope.eval(packet, expr).
	        this._defn = defn;
	        this._scope = new Function('\n            eval(\'' + this.toCode() + '\')\n            return {\n              \'eval\': function(packet, expr) {\n                  var raw = packet.__clone__(packet._data, true)\n                  try {\n                    return eval(expr)\n                  } catch (e) {\n                    return null\n                  }\n              }\n            }\n        ').call();
	    }

	    _createClass(PacketScope, [{
	        key: '_sanitize',
	        value: function _sanitize(cond) {
	            return cond.replace('\u2264', '<=').replace('\u2265', '>=');
	        }

	        /**
	         * Transforms a tenary relational expression conditional into a pair of
	         * binary relational expression conditionals. For example, given the string
	         * expression '1268.1041 <= r < 6522.7358' this function returns
	         * '(1268.1041 <= r) && (r < 6522.735)'.
	         */

	    }, {
	        key: '_toBinaryCond',
	        value: function _toBinaryCond(cond) {
	            var regex = /==|!=|<=|>=|<|>/g;
	            var op = cond.match(regex);
	            var t = cond.split(regex);

	            return op.length === 2 && t.length === 3 ? '(' + t[0] + ' ' + op[0] + ' ' + t[1] + ') && (' + t[1] + ' ' + op[1] + ' ' + t[2] + ')' : cond;
	        }

	        /**
	         * Evaluates the given expression within the context of this
	         * PacketScope and the given Packet.  The packet parameter is
	         * first so that you can bind() this function to a packet and
	         * evaluate many expressions.
	         */

	    }, {
	        key: 'eval',
	        value: function _eval(packet, expr) {
	            return this._scope.eval(packet, expr);
	        }
	    }, {
	        key: 'toCode',
	        value: function toCode() {
	            var code = '';

	            for (var name in this._defn.constants) {
	                code += 'var ' + name + ' = ' + this._defn.constants[name] + '; ';
	            }

	            for (var sig in this._defn.functions) {
	                var body = this._defn.functions[sig];

	                code += 'function ' + sig + ' { ';

	                if (typeof body === 'string') {
	                    code += 'return (' + body + ') ';
	                } else if ((typeof body === 'undefined' ? 'undefined' : _typeof(body)) === 'object') {
	                    for (var cond in body) {
	                        var pred = this._toBinaryCond(this._sanitize(cond));
	                        code += 'if (' + pred + ') { return (' + body[cond] + ') } ';
	                    }
	                }

	                code += '};';
	            }

	            return code;
	        }
	    }]);

	    return PacketScope;
	}();

	var TelemetryDictionary = function () {
	    /**
	     * Creates a new (empty) TelemetryDictionary.
	     */
	    function TelemetryDictionary() {
	        _classCallCheck(this, TelemetryDictionary);
	    }

	    /**
	     * Adds the given PacketDefinition to this TelemetryDictionary.
	     */


	    _createClass(TelemetryDictionary, [{
	        key: 'add',
	        value: function add(defn) {
	            if (defn instanceof PacketDefinition) {
	                this[defn.name] = defn;
	            }
	        }

	        /**
	         * Parses the given plain Javascript Object or JSON string and
	         * returns a new TelemetryDictionary, mapping packet names to
	         * PacketDefinitions.
	         */

	    }], [{
	        key: 'parse',
	        value: function parse(obj) {
	            var dict = new TelemetryDictionary();

	            if (typeof obj === 'string') {
	                obj = JSON.parse(obj);
	            }

	            for (var name in obj) {
	                dict.add(new PacketDefinition(obj[name]));
	            }

	            return dict;
	        }
	    }]);

	    return TelemetryDictionary;
	}();

	var TelemetryStream = function () {
	    function TelemetryStream(url, dict) {
	        var _this = this;

	        _classCallCheck(this, TelemetryStream);

	        this._dict = {};
	        this._interval = 0;
	        this._socket = new WebSocket(url);
	        this._stale = 0;
	        this._url = url;

	        // Re-map telemetry dictionary to be keyed by a PacketDefinition
	        // 'id' instead of 'name'.
	        for (var name in dict) {
	            var defn = dict[name];
	            this._dict[defn.uid] = defn;
	        }

	        this._socket.binaryType = 'arraybuffer';
	        this._socket.onclose = function (event) {
	            return _this.onClose(event);
	        };
	        this._socket.onmessage = function (event) {
	            return _this.onMessage(event);
	        };
	        this._socket.onopen = function (event) {
	            return _this.onOpen(event);
	        };
	    }

	    _createClass(TelemetryStream, [{
	        key: '_emit',
	        value: function _emit(name, data) {
	            bliss.events.emit('bliss:tlm:' + name, data);
	        }
	    }, {
	        key: 'onClose',
	        value: function onClose(event) {
	            clearInterval(this._interval);
	            this._emit('close', this);
	        }
	    }, {
	        key: 'onMessage',
	        value: function onMessage(event) {
	            if (!(event.data instanceof ArrayBuffer)) return;

	            var uid = new DataView(event.data, 1, 4).getUint32(0);
	            var data = new DataView(event.data, 5);
	            var defn = this._dict[uid];

	            // Since WebSockets can stay open indefinitely, the BLISS GUI
	            // server will occasionally probe for dropped client
	            // connections by sending empty packets (data.byteLength == 0)
	            // with a packet UID of zero.  These can should be safely
	            // ignored.
	            //
	            // A UID of zero can indicate a valid packet, so it's
	            // important to also check the data length that follows.
	            //
	            // It's also possible that the packet UID is not in the client
	            // telemetry dictionary (defn === undefined).  Without a
	            // packet definition, the packet cannot be processed further.
	            if (uid == 0 && data.byteLength == 0 || !defn) return;

	            var packet = new Packet(defn, data);

	            clearInterval(this._interval);
	            this._stale = 0;
	            this._interval = setInterval(this.onStale.bind(this), 5000);

	            bliss.packets.insert(defn.name, packet);
	            this._emit('packet', packet);
	        }
	    }, {
	        key: 'onOpen',
	        value: function onOpen(event) {
	            this._interval = setInterval(this.onStale.bind(this), 5000);
	            this._stale = 0;

	            //bliss.packets.create(this._defn.name)
	            this._emit('open', this);
	        }
	    }, {
	        key: 'onStale',
	        value: function onStale() {
	            this._stale++;
	            this._emit('stale', this);
	        }
	    }]);

	    return TelemetryStream;
	}();

	exports.FieldDefinition = FieldDefinition;
	exports.Packet = Packet;
	exports.PacketDefinition = PacketDefinition;
	exports.PacketScope = PacketScope;
	exports.TelemetryDictionary = TelemetryDictionary;
	exports.TelemetryStream = TelemetryStream;

/***/ }),
/* 236 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*
	 * Advanced Multi-Mission Operations System (AMMOS) Instrument Toolkit (AIT)
	 * Bespoke Link to Instruments and Small Satellites (BLISS)
	 *
	 * Copyright 2016, by the California Institute of Technology. ALL RIGHTS
	 * RESERVED. United States Government Sponsorship acknowledged. Any
	 * commercial use must be negotiated with the Office of Technology Transfer
	 * at the California Institute of Technology.
	 *
	 * This software may be subject to U.S. export control laws. By accepting
	 * this software, the user agrees to comply with all applicable U.S. export
	 * laws and regulations. User has the responsibility to obtain export licenses,
	 * or other export authority as may be required before exporting such
	 * information to foreign countries or providing access to foreign persons.
	 */

	/**
	 * Number of milliseconds between the Unix and GPS Epochs.
	 */
	var GPSEpoch = 315964800000;

	/**
	 * Returns true if reading nbytes starting at offset is in-bounds for
	 * the given DataView, false otherwise.
	 */
	function inBounds(view, nbytes, offset) {
	    return offset + nbytes <= view.byteLength;
	}

	var CommandType = function () {
	    function CommandType(name) {
	        _classCallCheck(this, CommandType);

	        this._name = name;
	    }

	    _createClass(CommandType, [{
	        key: 'decode',
	        value: function decode(view) {
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	            if (!inBounds(view, 2, offset)) return null;

	            var dict = bliss.cmd.dict;
	            var opcode = view.getUint16(offset, false);

	            return dict ? dict.getByOpcode(opcode) : opcode;
	        }
	    }, {
	        key: 'isTime',
	        get: function get() {
	            return false;
	        }
	    }]);

	    return CommandType;
	}();

	var EVRType = function () {
	    function EVRType(name) {
	        _classCallCheck(this, EVRType);

	        this._name = name;
	    }

	    _createClass(EVRType, [{
	        key: 'decode',
	        value: function decode(view) {
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	            if (!inBounds(view, 2, offset)) return null;

	            var dict = bliss.evr.dict;
	            var code = view.getUint16(offset, false);

	            return dict ? dict.getByCode(code) : code;
	        }
	    }, {
	        key: 'isTime',
	        get: function get() {
	            return false;
	        }
	    }]);

	    return EVRType;
	}();

	/**
	 * PrimitiveType
	 *
	 * A PrimitiveType contains a number of fields that provide
	 * information on the details of a primitive type, including: name
	 * (e.g. "MSB_U32"), endianness ("MSB" or "LSB"), float, signed,
	 * nbits, nbytes, min, and max.
	 *
	 * PrimitiveTypes can decode() binary representations stored in a
	 * Javascript DataView.
	 */


	var PrimitiveType = function () {
	    /**
	     * Creates a new PrimitiveType based on the given typename
	     * (e.g. 'MSB_U16' for a big endian, 16-bit short integer).
	     */
	    function PrimitiveType(name) {
	        _classCallCheck(this, PrimitiveType);

	        this._name = name;
	        this._decode = PrimitiveTypeDecoder[name];
	        this._endian = null;
	        this._float = false;
	        this._max = null;
	        this._min = null;
	        this._signed = false;
	        this._string = false;

	        if (this._name.startsWith('LSB_') || this._name.startsWith('MSB_')) {
	            this._endian = this._name.substr(0, 3);
	            this._signed = this._name[4] !== 'U';
	            this._float = this._name[4] === 'F' || this._name[4] === 'D';
	            this._nbits = parseInt(this._name.substr(-2));
	        } else if (this._name.startsWith('S')) {
	            this._nbits = parseInt(this._name.substr(1)) * 8;
	            this._string = true;
	        } else {
	            this._signed = this._name[0] !== 'U';
	            this._nbits = parseInt(this._name.substr(-1));
	        }

	        this._nbytes = this._nbits / 8;

	        if (this._float) {
	            this._max = +Number.MAX_VALUE;
	            this._min = -Number.MAX_VALUE;
	        } else if (this._signed) {
	            this._max = Math.pow(2, this._nbits - 1);
	            this._min = -1 * (this._max - 1);
	        } else if (this._string === false) {
	            this._max = Math.pow(2, this._nbits) - 1;
	            this._min = 0;
	        }
	    }

	    _createClass(PrimitiveType, [{
	        key: 'decode',


	        /**
	         * Decodes the given DataView (starting at optional byte offset)
	         * according to this PrimitiveType definition
	         *
	         * @return the decoded value or null (on error).
	         */
	        value: function decode(view) {
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	            return this._decode && inBounds(view, this._nbytes, offset) ? this._decode(view, offset) : null;
	        }
	    }, {
	        key: 'isTime',
	        get: function get() {
	            return false;
	        }
	    }]);

	    return PrimitiveType;
	}();

	var TimeType = function () {
	    function TimeType(name) {
	        _classCallCheck(this, TimeType);

	        this._name = name;
	    }

	    _createClass(TimeType, [{
	        key: 'isTime',
	        get: function get() {
	            return true;
	        }
	    }]);

	    return TimeType;
	}();

	// FIXME: Time8 is relative, while Time32 and Time64 are absolute.


	var Time8Type = function (_TimeType) {
	    _inherits(Time8Type, _TimeType);

	    function Time8Type() {
	        _classCallCheck(this, Time8Type);

	        return _possibleConstructorReturn(this, (Time8Type.__proto__ || Object.getPrototypeOf(Time8Type)).apply(this, arguments));
	    }

	    _createClass(Time8Type, [{
	        key: 'decode',
	        value: function decode(view) {
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	            if (!inBounds(view, 1, offset)) return null;
	            return view.getUint8(offset, false) / 256.0;
	        }
	    }]);

	    return Time8Type;
	}(TimeType);

	var Time32Type = function (_TimeType2) {
	    _inherits(Time32Type, _TimeType2);

	    function Time32Type() {
	        _classCallCheck(this, Time32Type);

	        return _possibleConstructorReturn(this, (Time32Type.__proto__ || Object.getPrototypeOf(Time32Type)).apply(this, arguments));
	    }

	    _createClass(Time32Type, [{
	        key: 'decode',
	        value: function decode(view) {
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	            if (!inBounds(view, 4, offset)) return null;

	            var tv_sec = view.getUint32(offset, false);
	            return new Date(GPSEpoch + tv_sec * 1000);
	        }
	    }]);

	    return Time32Type;
	}(TimeType);

	var Time64Type = function (_TimeType3) {
	    _inherits(Time64Type, _TimeType3);

	    function Time64Type() {
	        _classCallCheck(this, Time64Type);

	        return _possibleConstructorReturn(this, (Time64Type.__proto__ || Object.getPrototypeOf(Time64Type)).apply(this, arguments));
	    }

	    _createClass(Time64Type, [{
	        key: 'decode',
	        value: function decode(view) {
	            var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	            if (!inBounds(view, 8, offset)) return null;

	            var tv_sec = view.getUint32(offset, false);
	            var tv_nsec = view.getUint32(offset + 4, false);

	            return new Date(GPSEpoch + tv_sec * 1000 + tv_nsec / 1e6);
	        }
	    }]);

	    return Time64Type;
	}(TimeType);

	// Used by PrimitiveType.decode():
	//
	//     PrimitiveTypeDecoder[typename](view, offset)
	//


	var PrimitiveTypeDecoder = {
	    'I8': function I8(view, offset) {
	        return view.getUint8(offset);
	    },
	    'U8': function U8(view, offset) {
	        return view.getUint8(offset);
	    },
	    'LSB_I16': function LSB_I16(view, offset) {
	        return view.getInt16(offset, true);
	    },
	    'MSB_I16': function MSB_I16(view, offset) {
	        return view.getInt16(offset, false);
	    },
	    'LSB_U16': function LSB_U16(view, offset) {
	        return view.getUint16(offset, true);
	    },
	    'MSB_U16': function MSB_U16(view, offset) {
	        return view.getUint16(offset, false);
	    },
	    'LSB_I32': function LSB_I32(view, offset) {
	        return view.getInt32(offset, true);
	    },
	    'MSB_I32': function MSB_I32(view, offset) {
	        return view.getInt32(offset, false);
	    },
	    'LSB_U32': function LSB_U32(view, offset) {
	        return view.getUint32(offset, true);
	    },
	    'MSB_U32': function MSB_U32(view, offset) {
	        return view.getUint32(offset, false);
	    },
	    'LSB_F32': function LSB_F32(view, offset) {
	        return view.getFloat32(offset, true);
	    },
	    'MSB_F32': function MSB_F32(view, offset) {
	        return view.getFloat32(offset, false);
	    },
	    'LSB_D64': function LSB_D64(view, offset) {
	        return view.getFloat64(offset, true);
	    },
	    'MSB_D64': function MSB_D64(view, offset) {
	        return view.getFloat64(offset, false);
	    }

	    //
	    // TypeMap
	    //
	    // Maps typenames to PrimitiveType.  Use bliss.dtype.get(typename).
	    // (Populated below based on information in PrimitiveTypeDecoder).
	    //
	};var TypeMap = {};
	Object.keys(PrimitiveTypeDecoder).map(function (typename) {
	    TypeMap[typename] = new PrimitiveType(typename);
	});

	TypeMap['CMD16'] = new CommandType('CMD16');
	TypeMap['EVR16'] = new EVRType('EVR16');
	TypeMap['TIME8'] = new Time8Type('TIME8');
	TypeMap['TIME32'] = new Time32Type('TIME32');
	TypeMap['TIME64'] = new Time64Type('TIME64');

	/**
	 * @returns the PrimitiveType for typename or undefined.
	 */
	function get(typename) {
	    return TypeMap[typename];
	}

	exports.get = get;

/***/ }),
/* 237 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
	 * Bootstrap v3.3.7 (http://getbootstrap.com)
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under the MIT license
	 */

	if (typeof jQuery === 'undefined') {
	  throw new Error('Bootstrap\'s JavaScript requires jQuery')
	}

	+function ($) {
	  'use strict';
	  var version = $.fn.jquery.split(' ')[0].split('.')
	  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {
	    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')
	  }
	}(jQuery);

	/* ========================================================================
	 * Bootstrap: transition.js v3.3.7
	 * http://getbootstrap.com/javascript/#transitions
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
	  // ============================================================

	  function transitionEnd() {
	    var el = document.createElement('bootstrap')

	    var transEndEventNames = {
	      WebkitTransition : 'webkitTransitionEnd',
	      MozTransition    : 'transitionend',
	      OTransition      : 'oTransitionEnd otransitionend',
	      transition       : 'transitionend'
	    }

	    for (var name in transEndEventNames) {
	      if (el.style[name] !== undefined) {
	        return { end: transEndEventNames[name] }
	      }
	    }

	    return false // explicit for ie8 (  ._.)
	  }

	  // http://blog.alexmaccaw.com/css-transitions
	  $.fn.emulateTransitionEnd = function (duration) {
	    var called = false
	    var $el = this
	    $(this).one('bsTransitionEnd', function () { called = true })
	    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	    setTimeout(callback, duration)
	    return this
	  }

	  $(function () {
	    $.support.transition = transitionEnd()

	    if (!$.support.transition) return

	    $.event.special.bsTransitionEnd = {
	      bindType: $.support.transition.end,
	      delegateType: $.support.transition.end,
	      handle: function (e) {
	        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
	      }
	    }
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: alert.js v3.3.7
	 * http://getbootstrap.com/javascript/#alerts
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // ALERT CLASS DEFINITION
	  // ======================

	  var dismiss = '[data-dismiss="alert"]'
	  var Alert   = function (el) {
	    $(el).on('click', dismiss, this.close)
	  }

	  Alert.VERSION = '3.3.7'

	  Alert.TRANSITION_DURATION = 150

	  Alert.prototype.close = function (e) {
	    var $this    = $(this)
	    var selector = $this.attr('data-target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    var $parent = $(selector === '#' ? [] : selector)

	    if (e) e.preventDefault()

	    if (!$parent.length) {
	      $parent = $this.closest('.alert')
	    }

	    $parent.trigger(e = $.Event('close.bs.alert'))

	    if (e.isDefaultPrevented()) return

	    $parent.removeClass('in')

	    function removeElement() {
	      // detach from parent, fire event then clean up data
	      $parent.detach().trigger('closed.bs.alert').remove()
	    }

	    $.support.transition && $parent.hasClass('fade') ?
	      $parent
	        .one('bsTransitionEnd', removeElement)
	        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
	      removeElement()
	  }


	  // ALERT PLUGIN DEFINITION
	  // =======================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.alert')

	      if (!data) $this.data('bs.alert', (data = new Alert(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }

	  var old = $.fn.alert

	  $.fn.alert             = Plugin
	  $.fn.alert.Constructor = Alert


	  // ALERT NO CONFLICT
	  // =================

	  $.fn.alert.noConflict = function () {
	    $.fn.alert = old
	    return this
	  }


	  // ALERT DATA-API
	  // ==============

	  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: button.js v3.3.7
	 * http://getbootstrap.com/javascript/#buttons
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // BUTTON PUBLIC CLASS DEFINITION
	  // ==============================

	  var Button = function (element, options) {
	    this.$element  = $(element)
	    this.options   = $.extend({}, Button.DEFAULTS, options)
	    this.isLoading = false
	  }

	  Button.VERSION  = '3.3.7'

	  Button.DEFAULTS = {
	    loadingText: 'loading...'
	  }

	  Button.prototype.setState = function (state) {
	    var d    = 'disabled'
	    var $el  = this.$element
	    var val  = $el.is('input') ? 'val' : 'html'
	    var data = $el.data()

	    state += 'Text'

	    if (data.resetText == null) $el.data('resetText', $el[val]())

	    // push to event loop to allow forms to submit
	    setTimeout($.proxy(function () {
	      $el[val](data[state] == null ? this.options[state] : data[state])

	      if (state == 'loadingText') {
	        this.isLoading = true
	        $el.addClass(d).attr(d, d).prop(d, true)
	      } else if (this.isLoading) {
	        this.isLoading = false
	        $el.removeClass(d).removeAttr(d).prop(d, false)
	      }
	    }, this), 0)
	  }

	  Button.prototype.toggle = function () {
	    var changed = true
	    var $parent = this.$element.closest('[data-toggle="buttons"]')

	    if ($parent.length) {
	      var $input = this.$element.find('input')
	      if ($input.prop('type') == 'radio') {
	        if ($input.prop('checked')) changed = false
	        $parent.find('.active').removeClass('active')
	        this.$element.addClass('active')
	      } else if ($input.prop('type') == 'checkbox') {
	        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
	        this.$element.toggleClass('active')
	      }
	      $input.prop('checked', this.$element.hasClass('active'))
	      if (changed) $input.trigger('change')
	    } else {
	      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
	      this.$element.toggleClass('active')
	    }
	  }


	  // BUTTON PLUGIN DEFINITION
	  // ========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.button')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.button', (data = new Button(this, options)))

	      if (option == 'toggle') data.toggle()
	      else if (option) data.setState(option)
	    })
	  }

	  var old = $.fn.button

	  $.fn.button             = Plugin
	  $.fn.button.Constructor = Button


	  // BUTTON NO CONFLICT
	  // ==================

	  $.fn.button.noConflict = function () {
	    $.fn.button = old
	    return this
	  }


	  // BUTTON DATA-API
	  // ===============

	  $(document)
	    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      var $btn = $(e.target).closest('.btn')
	      Plugin.call($btn, 'toggle')
	      if (!($(e.target).is('input[type="radio"], input[type="checkbox"]'))) {
	        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
	        e.preventDefault()
	        // The target component still receive the focus
	        if ($btn.is('input,button')) $btn.trigger('focus')
	        else $btn.find('input:visible,button:visible').first().trigger('focus')
	      }
	    })
	    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
	      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
	    })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: carousel.js v3.3.7
	 * http://getbootstrap.com/javascript/#carousel
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // CAROUSEL CLASS DEFINITION
	  // =========================

	  var Carousel = function (element, options) {
	    this.$element    = $(element)
	    this.$indicators = this.$element.find('.carousel-indicators')
	    this.options     = options
	    this.paused      = null
	    this.sliding     = null
	    this.interval    = null
	    this.$active     = null
	    this.$items      = null

	    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

	    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
	      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
	      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
	  }

	  Carousel.VERSION  = '3.3.7'

	  Carousel.TRANSITION_DURATION = 600

	  Carousel.DEFAULTS = {
	    interval: 5000,
	    pause: 'hover',
	    wrap: true,
	    keyboard: true
	  }

	  Carousel.prototype.keydown = function (e) {
	    if (/input|textarea/i.test(e.target.tagName)) return
	    switch (e.which) {
	      case 37: this.prev(); break
	      case 39: this.next(); break
	      default: return
	    }

	    e.preventDefault()
	  }

	  Carousel.prototype.cycle = function (e) {
	    e || (this.paused = false)

	    this.interval && clearInterval(this.interval)

	    this.options.interval
	      && !this.paused
	      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

	    return this
	  }

	  Carousel.prototype.getItemIndex = function (item) {
	    this.$items = item.parent().children('.item')
	    return this.$items.index(item || this.$active)
	  }

	  Carousel.prototype.getItemForDirection = function (direction, active) {
	    var activeIndex = this.getItemIndex(active)
	    var willWrap = (direction == 'prev' && activeIndex === 0)
	                || (direction == 'next' && activeIndex == (this.$items.length - 1))
	    if (willWrap && !this.options.wrap) return active
	    var delta = direction == 'prev' ? -1 : 1
	    var itemIndex = (activeIndex + delta) % this.$items.length
	    return this.$items.eq(itemIndex)
	  }

	  Carousel.prototype.to = function (pos) {
	    var that        = this
	    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

	    if (pos > (this.$items.length - 1) || pos < 0) return

	    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
	    if (activeIndex == pos) return this.pause().cycle()

	    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
	  }

	  Carousel.prototype.pause = function (e) {
	    e || (this.paused = true)

	    if (this.$element.find('.next, .prev').length && $.support.transition) {
	      this.$element.trigger($.support.transition.end)
	      this.cycle(true)
	    }

	    this.interval = clearInterval(this.interval)

	    return this
	  }

	  Carousel.prototype.next = function () {
	    if (this.sliding) return
	    return this.slide('next')
	  }

	  Carousel.prototype.prev = function () {
	    if (this.sliding) return
	    return this.slide('prev')
	  }

	  Carousel.prototype.slide = function (type, next) {
	    var $active   = this.$element.find('.item.active')
	    var $next     = next || this.getItemForDirection(type, $active)
	    var isCycling = this.interval
	    var direction = type == 'next' ? 'left' : 'right'
	    var that      = this

	    if ($next.hasClass('active')) return (this.sliding = false)

	    var relatedTarget = $next[0]
	    var slideEvent = $.Event('slide.bs.carousel', {
	      relatedTarget: relatedTarget,
	      direction: direction
	    })
	    this.$element.trigger(slideEvent)
	    if (slideEvent.isDefaultPrevented()) return

	    this.sliding = true

	    isCycling && this.pause()

	    if (this.$indicators.length) {
	      this.$indicators.find('.active').removeClass('active')
	      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
	      $nextIndicator && $nextIndicator.addClass('active')
	    }

	    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
	    if ($.support.transition && this.$element.hasClass('slide')) {
	      $next.addClass(type)
	      $next[0].offsetWidth // force reflow
	      $active.addClass(direction)
	      $next.addClass(direction)
	      $active
	        .one('bsTransitionEnd', function () {
	          $next.removeClass([type, direction].join(' ')).addClass('active')
	          $active.removeClass(['active', direction].join(' '))
	          that.sliding = false
	          setTimeout(function () {
	            that.$element.trigger(slidEvent)
	          }, 0)
	        })
	        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
	    } else {
	      $active.removeClass('active')
	      $next.addClass('active')
	      this.sliding = false
	      this.$element.trigger(slidEvent)
	    }

	    isCycling && this.cycle()

	    return this
	  }


	  // CAROUSEL PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.carousel')
	      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
	      var action  = typeof option == 'string' ? option : options.slide

	      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
	      if (typeof option == 'number') data.to(option)
	      else if (action) data[action]()
	      else if (options.interval) data.pause().cycle()
	    })
	  }

	  var old = $.fn.carousel

	  $.fn.carousel             = Plugin
	  $.fn.carousel.Constructor = Carousel


	  // CAROUSEL NO CONFLICT
	  // ====================

	  $.fn.carousel.noConflict = function () {
	    $.fn.carousel = old
	    return this
	  }


	  // CAROUSEL DATA-API
	  // =================

	  var clickHandler = function (e) {
	    var href
	    var $this   = $(this)
	    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
	    if (!$target.hasClass('carousel')) return
	    var options = $.extend({}, $target.data(), $this.data())
	    var slideIndex = $this.attr('data-slide-to')
	    if (slideIndex) options.interval = false

	    Plugin.call($target, options)

	    if (slideIndex) {
	      $target.data('bs.carousel').to(slideIndex)
	    }

	    e.preventDefault()
	  }

	  $(document)
	    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
	    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

	  $(window).on('load', function () {
	    $('[data-ride="carousel"]').each(function () {
	      var $carousel = $(this)
	      Plugin.call($carousel, $carousel.data())
	    })
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: collapse.js v3.3.7
	 * http://getbootstrap.com/javascript/#collapse
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */

	/* jshint latedef: false */

	+function ($) {
	  'use strict';

	  // COLLAPSE PUBLIC CLASS DEFINITION
	  // ================================

	  var Collapse = function (element, options) {
	    this.$element      = $(element)
	    this.options       = $.extend({}, Collapse.DEFAULTS, options)
	    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
	                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
	    this.transitioning = null

	    if (this.options.parent) {
	      this.$parent = this.getParent()
	    } else {
	      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
	    }

	    if (this.options.toggle) this.toggle()
	  }

	  Collapse.VERSION  = '3.3.7'

	  Collapse.TRANSITION_DURATION = 350

	  Collapse.DEFAULTS = {
	    toggle: true
	  }

	  Collapse.prototype.dimension = function () {
	    var hasWidth = this.$element.hasClass('width')
	    return hasWidth ? 'width' : 'height'
	  }

	  Collapse.prototype.show = function () {
	    if (this.transitioning || this.$element.hasClass('in')) return

	    var activesData
	    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

	    if (actives && actives.length) {
	      activesData = actives.data('bs.collapse')
	      if (activesData && activesData.transitioning) return
	    }

	    var startEvent = $.Event('show.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return

	    if (actives && actives.length) {
	      Plugin.call(actives, 'hide')
	      activesData || actives.data('bs.collapse', null)
	    }

	    var dimension = this.dimension()

	    this.$element
	      .removeClass('collapse')
	      .addClass('collapsing')[dimension](0)
	      .attr('aria-expanded', true)

	    this.$trigger
	      .removeClass('collapsed')
	      .attr('aria-expanded', true)

	    this.transitioning = 1

	    var complete = function () {
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse in')[dimension]('')
	      this.transitioning = 0
	      this.$element
	        .trigger('shown.bs.collapse')
	    }

	    if (!$.support.transition) return complete.call(this)

	    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

	    this.$element
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
	  }

	  Collapse.prototype.hide = function () {
	    if (this.transitioning || !this.$element.hasClass('in')) return

	    var startEvent = $.Event('hide.bs.collapse')
	    this.$element.trigger(startEvent)
	    if (startEvent.isDefaultPrevented()) return

	    var dimension = this.dimension()

	    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

	    this.$element
	      .addClass('collapsing')
	      .removeClass('collapse in')
	      .attr('aria-expanded', false)

	    this.$trigger
	      .addClass('collapsed')
	      .attr('aria-expanded', false)

	    this.transitioning = 1

	    var complete = function () {
	      this.transitioning = 0
	      this.$element
	        .removeClass('collapsing')
	        .addClass('collapse')
	        .trigger('hidden.bs.collapse')
	    }

	    if (!$.support.transition) return complete.call(this)

	    this.$element
	      [dimension](0)
	      .one('bsTransitionEnd', $.proxy(complete, this))
	      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
	  }

	  Collapse.prototype.toggle = function () {
	    this[this.$element.hasClass('in') ? 'hide' : 'show']()
	  }

	  Collapse.prototype.getParent = function () {
	    return $(this.options.parent)
	      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
	      .each($.proxy(function (i, element) {
	        var $element = $(element)
	        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
	      }, this))
	      .end()
	  }

	  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
	    var isOpen = $element.hasClass('in')

	    $element.attr('aria-expanded', isOpen)
	    $trigger
	      .toggleClass('collapsed', !isOpen)
	      .attr('aria-expanded', isOpen)
	  }

	  function getTargetFromTrigger($trigger) {
	    var href
	    var target = $trigger.attr('data-target')
	      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

	    return $(target)
	  }


	  // COLLAPSE PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.collapse')
	      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

	      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
	      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.collapse

	  $.fn.collapse             = Plugin
	  $.fn.collapse.Constructor = Collapse


	  // COLLAPSE NO CONFLICT
	  // ====================

	  $.fn.collapse.noConflict = function () {
	    $.fn.collapse = old
	    return this
	  }


	  // COLLAPSE DATA-API
	  // =================

	  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
	    var $this   = $(this)

	    if (!$this.attr('data-target')) e.preventDefault()

	    var $target = getTargetFromTrigger($this)
	    var data    = $target.data('bs.collapse')
	    var option  = data ? 'toggle' : $this.data()

	    Plugin.call($target, option)
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: dropdown.js v3.3.7
	 * http://getbootstrap.com/javascript/#dropdowns
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // DROPDOWN CLASS DEFINITION
	  // =========================

	  var backdrop = '.dropdown-backdrop'
	  var toggle   = '[data-toggle="dropdown"]'
	  var Dropdown = function (element) {
	    $(element).on('click.bs.dropdown', this.toggle)
	  }

	  Dropdown.VERSION = '3.3.7'

	  function getParent($this) {
	    var selector = $this.attr('data-target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    var $parent = selector && $(selector)

	    return $parent && $parent.length ? $parent : $this.parent()
	  }

	  function clearMenus(e) {
	    if (e && e.which === 3) return
	    $(backdrop).remove()
	    $(toggle).each(function () {
	      var $this         = $(this)
	      var $parent       = getParent($this)
	      var relatedTarget = { relatedTarget: this }

	      if (!$parent.hasClass('open')) return

	      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

	      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

	      if (e.isDefaultPrevented()) return

	      $this.attr('aria-expanded', 'false')
	      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
	    })
	  }

	  Dropdown.prototype.toggle = function (e) {
	    var $this = $(this)

	    if ($this.is('.disabled, :disabled')) return

	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')

	    clearMenus()

	    if (!isActive) {
	      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
	        // if mobile we use a backdrop because click events don't delegate
	        $(document.createElement('div'))
	          .addClass('dropdown-backdrop')
	          .insertAfter($(this))
	          .on('click', clearMenus)
	      }

	      var relatedTarget = { relatedTarget: this }
	      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

	      if (e.isDefaultPrevented()) return

	      $this
	        .trigger('focus')
	        .attr('aria-expanded', 'true')

	      $parent
	        .toggleClass('open')
	        .trigger($.Event('shown.bs.dropdown', relatedTarget))
	    }

	    return false
	  }

	  Dropdown.prototype.keydown = function (e) {
	    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

	    var $this = $(this)

	    e.preventDefault()
	    e.stopPropagation()

	    if ($this.is('.disabled, :disabled')) return

	    var $parent  = getParent($this)
	    var isActive = $parent.hasClass('open')

	    if (!isActive && e.which != 27 || isActive && e.which == 27) {
	      if (e.which == 27) $parent.find(toggle).trigger('focus')
	      return $this.trigger('click')
	    }

	    var desc = ' li:not(.disabled):visible a'
	    var $items = $parent.find('.dropdown-menu' + desc)

	    if (!$items.length) return

	    var index = $items.index(e.target)

	    if (e.which == 38 && index > 0)                 index--         // up
	    if (e.which == 40 && index < $items.length - 1) index++         // down
	    if (!~index)                                    index = 0

	    $items.eq(index).trigger('focus')
	  }


	  // DROPDOWN PLUGIN DEFINITION
	  // ==========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.dropdown')

	      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
	      if (typeof option == 'string') data[option].call($this)
	    })
	  }

	  var old = $.fn.dropdown

	  $.fn.dropdown             = Plugin
	  $.fn.dropdown.Constructor = Dropdown


	  // DROPDOWN NO CONFLICT
	  // ====================

	  $.fn.dropdown.noConflict = function () {
	    $.fn.dropdown = old
	    return this
	  }


	  // APPLY TO STANDARD DROPDOWN ELEMENTS
	  // ===================================

	  $(document)
	    .on('click.bs.dropdown.data-api', clearMenus)
	    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
	    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
	    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
	    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: modal.js v3.3.7
	 * http://getbootstrap.com/javascript/#modals
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // MODAL CLASS DEFINITION
	  // ======================

	  var Modal = function (element, options) {
	    this.options             = options
	    this.$body               = $(document.body)
	    this.$element            = $(element)
	    this.$dialog             = this.$element.find('.modal-dialog')
	    this.$backdrop           = null
	    this.isShown             = null
	    this.originalBodyPad     = null
	    this.scrollbarWidth      = 0
	    this.ignoreBackdropClick = false

	    if (this.options.remote) {
	      this.$element
	        .find('.modal-content')
	        .load(this.options.remote, $.proxy(function () {
	          this.$element.trigger('loaded.bs.modal')
	        }, this))
	    }
	  }

	  Modal.VERSION  = '3.3.7'

	  Modal.TRANSITION_DURATION = 300
	  Modal.BACKDROP_TRANSITION_DURATION = 150

	  Modal.DEFAULTS = {
	    backdrop: true,
	    keyboard: true,
	    show: true
	  }

	  Modal.prototype.toggle = function (_relatedTarget) {
	    return this.isShown ? this.hide() : this.show(_relatedTarget)
	  }

	  Modal.prototype.show = function (_relatedTarget) {
	    var that = this
	    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

	    this.$element.trigger(e)

	    if (this.isShown || e.isDefaultPrevented()) return

	    this.isShown = true

	    this.checkScrollbar()
	    this.setScrollbar()
	    this.$body.addClass('modal-open')

	    this.escape()
	    this.resize()

	    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

	    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
	      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
	        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
	      })
	    })

	    this.backdrop(function () {
	      var transition = $.support.transition && that.$element.hasClass('fade')

	      if (!that.$element.parent().length) {
	        that.$element.appendTo(that.$body) // don't move modals dom position
	      }

	      that.$element
	        .show()
	        .scrollTop(0)

	      that.adjustDialog()

	      if (transition) {
	        that.$element[0].offsetWidth // force reflow
	      }

	      that.$element.addClass('in')

	      that.enforceFocus()

	      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

	      transition ?
	        that.$dialog // wait for modal to slide in
	          .one('bsTransitionEnd', function () {
	            that.$element.trigger('focus').trigger(e)
	          })
	          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	        that.$element.trigger('focus').trigger(e)
	    })
	  }

	  Modal.prototype.hide = function (e) {
	    if (e) e.preventDefault()

	    e = $.Event('hide.bs.modal')

	    this.$element.trigger(e)

	    if (!this.isShown || e.isDefaultPrevented()) return

	    this.isShown = false

	    this.escape()
	    this.resize()

	    $(document).off('focusin.bs.modal')

	    this.$element
	      .removeClass('in')
	      .off('click.dismiss.bs.modal')
	      .off('mouseup.dismiss.bs.modal')

	    this.$dialog.off('mousedown.dismiss.bs.modal')

	    $.support.transition && this.$element.hasClass('fade') ?
	      this.$element
	        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
	        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
	      this.hideModal()
	  }

	  Modal.prototype.enforceFocus = function () {
	    $(document)
	      .off('focusin.bs.modal') // guard against infinite focus loop
	      .on('focusin.bs.modal', $.proxy(function (e) {
	        if (document !== e.target &&
	            this.$element[0] !== e.target &&
	            !this.$element.has(e.target).length) {
	          this.$element.trigger('focus')
	        }
	      }, this))
	  }

	  Modal.prototype.escape = function () {
	    if (this.isShown && this.options.keyboard) {
	      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
	        e.which == 27 && this.hide()
	      }, this))
	    } else if (!this.isShown) {
	      this.$element.off('keydown.dismiss.bs.modal')
	    }
	  }

	  Modal.prototype.resize = function () {
	    if (this.isShown) {
	      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
	    } else {
	      $(window).off('resize.bs.modal')
	    }
	  }

	  Modal.prototype.hideModal = function () {
	    var that = this
	    this.$element.hide()
	    this.backdrop(function () {
	      that.$body.removeClass('modal-open')
	      that.resetAdjustments()
	      that.resetScrollbar()
	      that.$element.trigger('hidden.bs.modal')
	    })
	  }

	  Modal.prototype.removeBackdrop = function () {
	    this.$backdrop && this.$backdrop.remove()
	    this.$backdrop = null
	  }

	  Modal.prototype.backdrop = function (callback) {
	    var that = this
	    var animate = this.$element.hasClass('fade') ? 'fade' : ''

	    if (this.isShown && this.options.backdrop) {
	      var doAnimate = $.support.transition && animate

	      this.$backdrop = $(document.createElement('div'))
	        .addClass('modal-backdrop ' + animate)
	        .appendTo(this.$body)

	      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
	        if (this.ignoreBackdropClick) {
	          this.ignoreBackdropClick = false
	          return
	        }
	        if (e.target !== e.currentTarget) return
	        this.options.backdrop == 'static'
	          ? this.$element[0].focus()
	          : this.hide()
	      }, this))

	      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

	      this.$backdrop.addClass('in')

	      if (!callback) return

	      doAnimate ?
	        this.$backdrop
	          .one('bsTransitionEnd', callback)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callback()

	    } else if (!this.isShown && this.$backdrop) {
	      this.$backdrop.removeClass('in')

	      var callbackRemove = function () {
	        that.removeBackdrop()
	        callback && callback()
	      }
	      $.support.transition && this.$element.hasClass('fade') ?
	        this.$backdrop
	          .one('bsTransitionEnd', callbackRemove)
	          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
	        callbackRemove()

	    } else if (callback) {
	      callback()
	    }
	  }

	  // these following methods are used to handle overflowing modals

	  Modal.prototype.handleUpdate = function () {
	    this.adjustDialog()
	  }

	  Modal.prototype.adjustDialog = function () {
	    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

	    this.$element.css({
	      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
	      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
	    })
	  }

	  Modal.prototype.resetAdjustments = function () {
	    this.$element.css({
	      paddingLeft: '',
	      paddingRight: ''
	    })
	  }

	  Modal.prototype.checkScrollbar = function () {
	    var fullWindowWidth = window.innerWidth
	    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
	      var documentElementRect = document.documentElement.getBoundingClientRect()
	      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
	    }
	    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
	    this.scrollbarWidth = this.measureScrollbar()
	  }

	  Modal.prototype.setScrollbar = function () {
	    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
	    this.originalBodyPad = document.body.style.paddingRight || ''
	    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
	  }

	  Modal.prototype.resetScrollbar = function () {
	    this.$body.css('padding-right', this.originalBodyPad)
	  }

	  Modal.prototype.measureScrollbar = function () { // thx walsh
	    var scrollDiv = document.createElement('div')
	    scrollDiv.className = 'modal-scrollbar-measure'
	    this.$body.append(scrollDiv)
	    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
	    this.$body[0].removeChild(scrollDiv)
	    return scrollbarWidth
	  }


	  // MODAL PLUGIN DEFINITION
	  // =======================

	  function Plugin(option, _relatedTarget) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.modal')
	      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

	      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
	      if (typeof option == 'string') data[option](_relatedTarget)
	      else if (options.show) data.show(_relatedTarget)
	    })
	  }

	  var old = $.fn.modal

	  $.fn.modal             = Plugin
	  $.fn.modal.Constructor = Modal


	  // MODAL NO CONFLICT
	  // =================

	  $.fn.modal.noConflict = function () {
	    $.fn.modal = old
	    return this
	  }


	  // MODAL DATA-API
	  // ==============

	  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
	    var $this   = $(this)
	    var href    = $this.attr('href')
	    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
	    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

	    if ($this.is('a')) e.preventDefault()

	    $target.one('show.bs.modal', function (showEvent) {
	      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
	      $target.one('hidden.bs.modal', function () {
	        $this.is(':visible') && $this.trigger('focus')
	      })
	    })
	    Plugin.call($target, option, this)
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: tooltip.js v3.3.7
	 * http://getbootstrap.com/javascript/#tooltip
	 * Inspired by the original jQuery.tipsy by Jason Frame
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // TOOLTIP PUBLIC CLASS DEFINITION
	  // ===============================

	  var Tooltip = function (element, options) {
	    this.type       = null
	    this.options    = null
	    this.enabled    = null
	    this.timeout    = null
	    this.hoverState = null
	    this.$element   = null
	    this.inState    = null

	    this.init('tooltip', element, options)
	  }

	  Tooltip.VERSION  = '3.3.7'

	  Tooltip.TRANSITION_DURATION = 150

	  Tooltip.DEFAULTS = {
	    animation: true,
	    placement: 'top',
	    selector: false,
	    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
	    trigger: 'hover focus',
	    title: '',
	    delay: 0,
	    html: false,
	    container: false,
	    viewport: {
	      selector: 'body',
	      padding: 0
	    }
	  }

	  Tooltip.prototype.init = function (type, element, options) {
	    this.enabled   = true
	    this.type      = type
	    this.$element  = $(element)
	    this.options   = this.getOptions(options)
	    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
	    this.inState   = { click: false, hover: false, focus: false }

	    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
	      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
	    }

	    var triggers = this.options.trigger.split(' ')

	    for (var i = triggers.length; i--;) {
	      var trigger = triggers[i]

	      if (trigger == 'click') {
	        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	      } else if (trigger != 'manual') {
	        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
	        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

	        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
	        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	      }
	    }

	    this.options.selector ?
	      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	      this.fixTitle()
	  }

	  Tooltip.prototype.getDefaults = function () {
	    return Tooltip.DEFAULTS
	  }

	  Tooltip.prototype.getOptions = function (options) {
	    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

	    if (options.delay && typeof options.delay == 'number') {
	      options.delay = {
	        show: options.delay,
	        hide: options.delay
	      }
	    }

	    return options
	  }

	  Tooltip.prototype.getDelegateOptions = function () {
	    var options  = {}
	    var defaults = this.getDefaults()

	    this._options && $.each(this._options, function (key, value) {
	      if (defaults[key] != value) options[key] = value
	    })

	    return options
	  }

	  Tooltip.prototype.enter = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)

	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }

	    if (obj instanceof $.Event) {
	      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
	    }

	    if (self.tip().hasClass('in') || self.hoverState == 'in') {
	      self.hoverState = 'in'
	      return
	    }

	    clearTimeout(self.timeout)

	    self.hoverState = 'in'

	    if (!self.options.delay || !self.options.delay.show) return self.show()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'in') self.show()
	    }, self.options.delay.show)
	  }

	  Tooltip.prototype.isInStateTrue = function () {
	    for (var key in this.inState) {
	      if (this.inState[key]) return true
	    }

	    return false
	  }

	  Tooltip.prototype.leave = function (obj) {
	    var self = obj instanceof this.constructor ?
	      obj : $(obj.currentTarget).data('bs.' + this.type)

	    if (!self) {
	      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
	      $(obj.currentTarget).data('bs.' + this.type, self)
	    }

	    if (obj instanceof $.Event) {
	      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
	    }

	    if (self.isInStateTrue()) return

	    clearTimeout(self.timeout)

	    self.hoverState = 'out'

	    if (!self.options.delay || !self.options.delay.hide) return self.hide()

	    self.timeout = setTimeout(function () {
	      if (self.hoverState == 'out') self.hide()
	    }, self.options.delay.hide)
	  }

	  Tooltip.prototype.show = function () {
	    var e = $.Event('show.bs.' + this.type)

	    if (this.hasContent() && this.enabled) {
	      this.$element.trigger(e)

	      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
	      if (e.isDefaultPrevented() || !inDom) return
	      var that = this

	      var $tip = this.tip()

	      var tipId = this.getUID(this.type)

	      this.setContent()
	      $tip.attr('id', tipId)
	      this.$element.attr('aria-describedby', tipId)

	      if (this.options.animation) $tip.addClass('fade')

	      var placement = typeof this.options.placement == 'function' ?
	        this.options.placement.call(this, $tip[0], this.$element[0]) :
	        this.options.placement

	      var autoToken = /\s?auto?\s?/i
	      var autoPlace = autoToken.test(placement)
	      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

	      $tip
	        .detach()
	        .css({ top: 0, left: 0, display: 'block' })
	        .addClass(placement)
	        .data('bs.' + this.type, this)

	      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
	      this.$element.trigger('inserted.bs.' + this.type)

	      var pos          = this.getPosition()
	      var actualWidth  = $tip[0].offsetWidth
	      var actualHeight = $tip[0].offsetHeight

	      if (autoPlace) {
	        var orgPlacement = placement
	        var viewportDim = this.getPosition(this.$viewport)

	        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
	                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
	                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
	                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
	                    placement

	        $tip
	          .removeClass(orgPlacement)
	          .addClass(placement)
	      }

	      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

	      this.applyPlacement(calculatedOffset, placement)

	      var complete = function () {
	        var prevHoverState = that.hoverState
	        that.$element.trigger('shown.bs.' + that.type)
	        that.hoverState = null

	        if (prevHoverState == 'out') that.leave(that)
	      }

	      $.support.transition && this.$tip.hasClass('fade') ?
	        $tip
	          .one('bsTransitionEnd', complete)
	          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	        complete()
	    }
	  }

	  Tooltip.prototype.applyPlacement = function (offset, placement) {
	    var $tip   = this.tip()
	    var width  = $tip[0].offsetWidth
	    var height = $tip[0].offsetHeight

	    // manually read margins because getBoundingClientRect includes difference
	    var marginTop = parseInt($tip.css('margin-top'), 10)
	    var marginLeft = parseInt($tip.css('margin-left'), 10)

	    // we must check for NaN for ie 8/9
	    if (isNaN(marginTop))  marginTop  = 0
	    if (isNaN(marginLeft)) marginLeft = 0

	    offset.top  += marginTop
	    offset.left += marginLeft

	    // $.fn.offset doesn't round pixel values
	    // so we use setOffset directly with our own function B-0
	    $.offset.setOffset($tip[0], $.extend({
	      using: function (props) {
	        $tip.css({
	          top: Math.round(props.top),
	          left: Math.round(props.left)
	        })
	      }
	    }, offset), 0)

	    $tip.addClass('in')

	    // check to see if placing tip in new offset caused the tip to resize itself
	    var actualWidth  = $tip[0].offsetWidth
	    var actualHeight = $tip[0].offsetHeight

	    if (placement == 'top' && actualHeight != height) {
	      offset.top = offset.top + height - actualHeight
	    }

	    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

	    if (delta.left) offset.left += delta.left
	    else offset.top += delta.top

	    var isVertical          = /top|bottom/.test(placement)
	    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
	    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

	    $tip.offset(offset)
	    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
	  }

	  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
	    this.arrow()
	      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
	      .css(isVertical ? 'top' : 'left', '')
	  }

	  Tooltip.prototype.setContent = function () {
	    var $tip  = this.tip()
	    var title = this.getTitle()

	    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	    $tip.removeClass('fade in top bottom left right')
	  }

	  Tooltip.prototype.hide = function (callback) {
	    var that = this
	    var $tip = $(this.$tip)
	    var e    = $.Event('hide.bs.' + this.type)

	    function complete() {
	      if (that.hoverState != 'in') $tip.detach()
	      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.
	        that.$element
	          .removeAttr('aria-describedby')
	          .trigger('hidden.bs.' + that.type)
	      }
	      callback && callback()
	    }

	    this.$element.trigger(e)

	    if (e.isDefaultPrevented()) return

	    $tip.removeClass('in')

	    $.support.transition && $tip.hasClass('fade') ?
	      $tip
	        .one('bsTransitionEnd', complete)
	        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
	      complete()

	    this.hoverState = null

	    return this
	  }

	  Tooltip.prototype.fixTitle = function () {
	    var $e = this.$element
	    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
	      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	    }
	  }

	  Tooltip.prototype.hasContent = function () {
	    return this.getTitle()
	  }

	  Tooltip.prototype.getPosition = function ($element) {
	    $element   = $element || this.$element

	    var el     = $element[0]
	    var isBody = el.tagName == 'BODY'

	    var elRect    = el.getBoundingClientRect()
	    if (elRect.width == null) {
	      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
	      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
	    }
	    var isSvg = window.SVGElement && el instanceof window.SVGElement
	    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
	    // See https://github.com/twbs/bootstrap/issues/20280
	    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())
	    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
	    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

	    return $.extend({}, elRect, scroll, outerDims, elOffset)
	  }

	  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
	    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
	           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
	        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

	  }

	  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
	    var delta = { top: 0, left: 0 }
	    if (!this.$viewport) return delta

	    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
	    var viewportDimensions = this.getPosition(this.$viewport)

	    if (/right|left/.test(placement)) {
	      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
	      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
	      if (topEdgeOffset < viewportDimensions.top) { // top overflow
	        delta.top = viewportDimensions.top - topEdgeOffset
	      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
	        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
	      }
	    } else {
	      var leftEdgeOffset  = pos.left - viewportPadding
	      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
	      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
	        delta.left = viewportDimensions.left - leftEdgeOffset
	      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
	        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
	      }
	    }

	    return delta
	  }

	  Tooltip.prototype.getTitle = function () {
	    var title
	    var $e = this.$element
	    var o  = this.options

	    title = $e.attr('data-original-title')
	      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

	    return title
	  }

	  Tooltip.prototype.getUID = function (prefix) {
	    do prefix += ~~(Math.random() * 1000000)
	    while (document.getElementById(prefix))
	    return prefix
	  }

	  Tooltip.prototype.tip = function () {
	    if (!this.$tip) {
	      this.$tip = $(this.options.template)
	      if (this.$tip.length != 1) {
	        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
	      }
	    }
	    return this.$tip
	  }

	  Tooltip.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
	  }

	  Tooltip.prototype.enable = function () {
	    this.enabled = true
	  }

	  Tooltip.prototype.disable = function () {
	    this.enabled = false
	  }

	  Tooltip.prototype.toggleEnabled = function () {
	    this.enabled = !this.enabled
	  }

	  Tooltip.prototype.toggle = function (e) {
	    var self = this
	    if (e) {
	      self = $(e.currentTarget).data('bs.' + this.type)
	      if (!self) {
	        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
	        $(e.currentTarget).data('bs.' + this.type, self)
	      }
	    }

	    if (e) {
	      self.inState.click = !self.inState.click
	      if (self.isInStateTrue()) self.enter(self)
	      else self.leave(self)
	    } else {
	      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
	    }
	  }

	  Tooltip.prototype.destroy = function () {
	    var that = this
	    clearTimeout(this.timeout)
	    this.hide(function () {
	      that.$element.off('.' + that.type).removeData('bs.' + that.type)
	      if (that.$tip) {
	        that.$tip.detach()
	      }
	      that.$tip = null
	      that.$arrow = null
	      that.$viewport = null
	      that.$element = null
	    })
	  }


	  // TOOLTIP PLUGIN DEFINITION
	  // =========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.tooltip')
	      var options = typeof option == 'object' && option

	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.tooltip

	  $.fn.tooltip             = Plugin
	  $.fn.tooltip.Constructor = Tooltip


	  // TOOLTIP NO CONFLICT
	  // ===================

	  $.fn.tooltip.noConflict = function () {
	    $.fn.tooltip = old
	    return this
	  }

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: popover.js v3.3.7
	 * http://getbootstrap.com/javascript/#popovers
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // POPOVER PUBLIC CLASS DEFINITION
	  // ===============================

	  var Popover = function (element, options) {
	    this.init('popover', element, options)
	  }

	  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

	  Popover.VERSION  = '3.3.7'

	  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
	    placement: 'right',
	    trigger: 'click',
	    content: '',
	    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
	  })


	  // NOTE: POPOVER EXTENDS tooltip.js
	  // ================================

	  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

	  Popover.prototype.constructor = Popover

	  Popover.prototype.getDefaults = function () {
	    return Popover.DEFAULTS
	  }

	  Popover.prototype.setContent = function () {
	    var $tip    = this.tip()
	    var title   = this.getTitle()
	    var content = this.getContent()

	    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
	      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
	    ](content)

	    $tip.removeClass('fade top bottom left right in')

	    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
	    // this manually by checking the contents.
	    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
	  }

	  Popover.prototype.hasContent = function () {
	    return this.getTitle() || this.getContent()
	  }

	  Popover.prototype.getContent = function () {
	    var $e = this.$element
	    var o  = this.options

	    return $e.attr('data-content')
	      || (typeof o.content == 'function' ?
	            o.content.call($e[0]) :
	            o.content)
	  }

	  Popover.prototype.arrow = function () {
	    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
	  }


	  // POPOVER PLUGIN DEFINITION
	  // =========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.popover')
	      var options = typeof option == 'object' && option

	      if (!data && /destroy|hide/.test(option)) return
	      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.popover

	  $.fn.popover             = Plugin
	  $.fn.popover.Constructor = Popover


	  // POPOVER NO CONFLICT
	  // ===================

	  $.fn.popover.noConflict = function () {
	    $.fn.popover = old
	    return this
	  }

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: scrollspy.js v3.3.7
	 * http://getbootstrap.com/javascript/#scrollspy
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // SCROLLSPY CLASS DEFINITION
	  // ==========================

	  function ScrollSpy(element, options) {
	    this.$body          = $(document.body)
	    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
	    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
	    this.selector       = (this.options.target || '') + ' .nav li > a'
	    this.offsets        = []
	    this.targets        = []
	    this.activeTarget   = null
	    this.scrollHeight   = 0

	    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
	    this.refresh()
	    this.process()
	  }

	  ScrollSpy.VERSION  = '3.3.7'

	  ScrollSpy.DEFAULTS = {
	    offset: 10
	  }

	  ScrollSpy.prototype.getScrollHeight = function () {
	    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
	  }

	  ScrollSpy.prototype.refresh = function () {
	    var that          = this
	    var offsetMethod  = 'offset'
	    var offsetBase    = 0

	    this.offsets      = []
	    this.targets      = []
	    this.scrollHeight = this.getScrollHeight()

	    if (!$.isWindow(this.$scrollElement[0])) {
	      offsetMethod = 'position'
	      offsetBase   = this.$scrollElement.scrollTop()
	    }

	    this.$body
	      .find(this.selector)
	      .map(function () {
	        var $el   = $(this)
	        var href  = $el.data('target') || $el.attr('href')
	        var $href = /^#./.test(href) && $(href)

	        return ($href
	          && $href.length
	          && $href.is(':visible')
	          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
	      })
	      .sort(function (a, b) { return a[0] - b[0] })
	      .each(function () {
	        that.offsets.push(this[0])
	        that.targets.push(this[1])
	      })
	  }

	  ScrollSpy.prototype.process = function () {
	    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
	    var scrollHeight = this.getScrollHeight()
	    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
	    var offsets      = this.offsets
	    var targets      = this.targets
	    var activeTarget = this.activeTarget
	    var i

	    if (this.scrollHeight != scrollHeight) {
	      this.refresh()
	    }

	    if (scrollTop >= maxScroll) {
	      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
	    }

	    if (activeTarget && scrollTop < offsets[0]) {
	      this.activeTarget = null
	      return this.clear()
	    }

	    for (i = offsets.length; i--;) {
	      activeTarget != targets[i]
	        && scrollTop >= offsets[i]
	        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
	        && this.activate(targets[i])
	    }
	  }

	  ScrollSpy.prototype.activate = function (target) {
	    this.activeTarget = target

	    this.clear()

	    var selector = this.selector +
	      '[data-target="' + target + '"],' +
	      this.selector + '[href="' + target + '"]'

	    var active = $(selector)
	      .parents('li')
	      .addClass('active')

	    if (active.parent('.dropdown-menu').length) {
	      active = active
	        .closest('li.dropdown')
	        .addClass('active')
	    }

	    active.trigger('activate.bs.scrollspy')
	  }

	  ScrollSpy.prototype.clear = function () {
	    $(this.selector)
	      .parentsUntil(this.options.target, '.active')
	      .removeClass('active')
	  }


	  // SCROLLSPY PLUGIN DEFINITION
	  // ===========================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.scrollspy')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.scrollspy

	  $.fn.scrollspy             = Plugin
	  $.fn.scrollspy.Constructor = ScrollSpy


	  // SCROLLSPY NO CONFLICT
	  // =====================

	  $.fn.scrollspy.noConflict = function () {
	    $.fn.scrollspy = old
	    return this
	  }


	  // SCROLLSPY DATA-API
	  // ==================

	  $(window).on('load.bs.scrollspy.data-api', function () {
	    $('[data-spy="scroll"]').each(function () {
	      var $spy = $(this)
	      Plugin.call($spy, $spy.data())
	    })
	  })

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: tab.js v3.3.7
	 * http://getbootstrap.com/javascript/#tabs
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // TAB CLASS DEFINITION
	  // ====================

	  var Tab = function (element) {
	    // jscs:disable requireDollarBeforejQueryAssignment
	    this.element = $(element)
	    // jscs:enable requireDollarBeforejQueryAssignment
	  }

	  Tab.VERSION = '3.3.7'

	  Tab.TRANSITION_DURATION = 150

	  Tab.prototype.show = function () {
	    var $this    = this.element
	    var $ul      = $this.closest('ul:not(.dropdown-menu)')
	    var selector = $this.data('target')

	    if (!selector) {
	      selector = $this.attr('href')
	      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	    }

	    if ($this.parent('li').hasClass('active')) return

	    var $previous = $ul.find('.active:last a')
	    var hideEvent = $.Event('hide.bs.tab', {
	      relatedTarget: $this[0]
	    })
	    var showEvent = $.Event('show.bs.tab', {
	      relatedTarget: $previous[0]
	    })

	    $previous.trigger(hideEvent)
	    $this.trigger(showEvent)

	    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

	    var $target = $(selector)

	    this.activate($this.closest('li'), $ul)
	    this.activate($target, $target.parent(), function () {
	      $previous.trigger({
	        type: 'hidden.bs.tab',
	        relatedTarget: $this[0]
	      })
	      $this.trigger({
	        type: 'shown.bs.tab',
	        relatedTarget: $previous[0]
	      })
	    })
	  }

	  Tab.prototype.activate = function (element, container, callback) {
	    var $active    = container.find('> .active')
	    var transition = callback
	      && $.support.transition
	      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

	    function next() {
	      $active
	        .removeClass('active')
	        .find('> .dropdown-menu > .active')
	          .removeClass('active')
	        .end()
	        .find('[data-toggle="tab"]')
	          .attr('aria-expanded', false)

	      element
	        .addClass('active')
	        .find('[data-toggle="tab"]')
	          .attr('aria-expanded', true)

	      if (transition) {
	        element[0].offsetWidth // reflow for transition
	        element.addClass('in')
	      } else {
	        element.removeClass('fade')
	      }

	      if (element.parent('.dropdown-menu').length) {
	        element
	          .closest('li.dropdown')
	            .addClass('active')
	          .end()
	          .find('[data-toggle="tab"]')
	            .attr('aria-expanded', true)
	      }

	      callback && callback()
	    }

	    $active.length && transition ?
	      $active
	        .one('bsTransitionEnd', next)
	        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
	      next()

	    $active.removeClass('in')
	  }


	  // TAB PLUGIN DEFINITION
	  // =====================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this = $(this)
	      var data  = $this.data('bs.tab')

	      if (!data) $this.data('bs.tab', (data = new Tab(this)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.tab

	  $.fn.tab             = Plugin
	  $.fn.tab.Constructor = Tab


	  // TAB NO CONFLICT
	  // ===============

	  $.fn.tab.noConflict = function () {
	    $.fn.tab = old
	    return this
	  }


	  // TAB DATA-API
	  // ============

	  var clickHandler = function (e) {
	    e.preventDefault()
	    Plugin.call($(this), 'show')
	  }

	  $(document)
	    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
	    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

	}(jQuery);

	/* ========================================================================
	 * Bootstrap: affix.js v3.3.7
	 * http://getbootstrap.com/javascript/#affix
	 * ========================================================================
	 * Copyright 2011-2016 Twitter, Inc.
	 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
	 * ======================================================================== */


	+function ($) {
	  'use strict';

	  // AFFIX CLASS DEFINITION
	  // ======================

	  var Affix = function (element, options) {
	    this.options = $.extend({}, Affix.DEFAULTS, options)

	    this.$target = $(this.options.target)
	      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
	      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

	    this.$element     = $(element)
	    this.affixed      = null
	    this.unpin        = null
	    this.pinnedOffset = null

	    this.checkPosition()
	  }

	  Affix.VERSION  = '3.3.7'

	  Affix.RESET    = 'affix affix-top affix-bottom'

	  Affix.DEFAULTS = {
	    offset: 0,
	    target: window
	  }

	  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
	    var scrollTop    = this.$target.scrollTop()
	    var position     = this.$element.offset()
	    var targetHeight = this.$target.height()

	    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

	    if (this.affixed == 'bottom') {
	      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
	      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
	    }

	    var initializing   = this.affixed == null
	    var colliderTop    = initializing ? scrollTop : position.top
	    var colliderHeight = initializing ? targetHeight : height

	    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
	    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

	    return false
	  }

	  Affix.prototype.getPinnedOffset = function () {
	    if (this.pinnedOffset) return this.pinnedOffset
	    this.$element.removeClass(Affix.RESET).addClass('affix')
	    var scrollTop = this.$target.scrollTop()
	    var position  = this.$element.offset()
	    return (this.pinnedOffset = position.top - scrollTop)
	  }

	  Affix.prototype.checkPositionWithEventLoop = function () {
	    setTimeout($.proxy(this.checkPosition, this), 1)
	  }

	  Affix.prototype.checkPosition = function () {
	    if (!this.$element.is(':visible')) return

	    var height       = this.$element.height()
	    var offset       = this.options.offset
	    var offsetTop    = offset.top
	    var offsetBottom = offset.bottom
	    var scrollHeight = Math.max($(document).height(), $(document.body).height())

	    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
	    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
	    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

	    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

	    if (this.affixed != affix) {
	      if (this.unpin != null) this.$element.css('top', '')

	      var affixType = 'affix' + (affix ? '-' + affix : '')
	      var e         = $.Event(affixType + '.bs.affix')

	      this.$element.trigger(e)

	      if (e.isDefaultPrevented()) return

	      this.affixed = affix
	      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

	      this.$element
	        .removeClass(Affix.RESET)
	        .addClass(affixType)
	        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
	    }

	    if (affix == 'bottom') {
	      this.$element.offset({
	        top: scrollHeight - height - offsetBottom
	      })
	    }
	  }


	  // AFFIX PLUGIN DEFINITION
	  // =======================

	  function Plugin(option) {
	    return this.each(function () {
	      var $this   = $(this)
	      var data    = $this.data('bs.affix')
	      var options = typeof option == 'object' && option

	      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
	      if (typeof option == 'string') data[option]()
	    })
	  }

	  var old = $.fn.affix

	  $.fn.affix             = Plugin
	  $.fn.affix.Constructor = Affix


	  // AFFIX NO CONFLICT
	  // =================

	  $.fn.affix.noConflict = function () {
	    $.fn.affix = old
	    return this
	  }


	  // AFFIX DATA-API
	  // ==============

	  $(window).on('load', function () {
	    $('[data-spy="affix"]').each(function () {
	      var $spy = $(this)
	      var data = $spy.data()

	      data.offset = data.offset || {}

	      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
	      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

	      Plugin.call($spy, data)
	    })
	  })

	}(jQuery);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(16)))

/***/ })
/******/ ]);